diff -urN ./Bit_Operations.thy /cygdrive/c/Isabelle2022/src/HOL/Bit_Operations.thy
--- ./Bit_Operations.thy	2023-05-30 11:49:54.099652200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Bit_Operations.thy	2023-05-31 14:26:38.861397700 +0900
@@ -2048,7 +2048,8 @@
 lemma and_int_unfold:
   \<open>k AND l = (if k = 0 \<or> l = 0 then 0 else if k = - 1 then l else if l = - 1 then k
     else (k mod 2) * (l mod 2) + 2 * ((k div 2) AND (l div 2)))\<close> for k l :: int
-  by (auto simp add: and_int_rec [of k l] zmult_eq_1_iff elim: oddE)
+  apply (auto split: if_splits)
+  by (simp add: and_int_rec[of k l] odd_iff_mod_2_eq_one)
 
 lemma or_int_unfold:
   \<open>k OR l = (if k = - 1 \<or> l = - 1 then - 1 else if k = 0 then l else if l = 0 then k
@@ -2058,7 +2059,9 @@
 lemma xor_int_unfold:
   \<open>k XOR l = (if k = - 1 then NOT l else if l = - 1 then NOT k else if k = 0 then l else if l = 0 then k
     else \<bar>k mod 2 - l mod 2\<bar> + 2 * ((k div 2) XOR (l div 2)))\<close> for k l :: int
-  by (auto simp add: xor_int_rec [of k l] not_int_def elim!: oddE)
+  apply (auto split: if_splits)
+  apply (simp add: xor_int_rec[of k l] odd_iff_mod_2_eq_one)
+  by auto
 
 lemma bit_minus_int_iff:
   \<open>bit (- k) n \<longleftrightarrow> bit (NOT (k - 1)) n\<close>
diff -urN ./Enum.thy /cygdrive/c/Isabelle2022/src/HOL/Enum.thy
--- ./Enum.thy	2023-05-30 11:50:42.024180400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Enum.thy	2023-06-01 11:16:35.187000700 +0900
@@ -929,15 +929,47 @@
 definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
 definition "sgn = (\<lambda>x :: finite_3. x)"
+
+lemmas [simp] = times_finite_3_def plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+  inverse_finite_3_def divide_finite_3_def sgn_finite_3_def abs_finite_3_def modulo_finite_3_def
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
-        times_finite_3_def
-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
-        abs_finite_3_def sgn_finite_3_def
-        less_finite_3_def
-        split: finite_3.splits\<close>)
+    apply standard
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  done
+
+lemmas [simp del] = times_finite_3_def plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+  inverse_finite_3_def divide_finite_3_def sgn_finite_3_def abs_finite_3_def modulo_finite_3_def
+
 end
 
 lemma two_finite_3 [simp]:
@@ -953,17 +985,30 @@
 definition [simp]: "unit_factor = (id :: finite_3 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | _ \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_3) = 1"
+
+lemmas [simp] = divide_finite_3_def times_finite_3_def
+      dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
 instance
-proof
-  fix x :: finite_3
-  assume "x \<noteq> 0"
-  then show "is_unit (unit_factor x)"
-    by (cases x) (simp_all add: dvd_finite_3_unfold)
-qed
-  (subproofs
-    \<open>auto simp add: divide_finite_3_def times_finite_3_def
+   apply intro_classes
+  subgoal by simp
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  done
+
+lemmas [simp del] = divide_finite_3_def times_finite_3_def
       dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
-      split: finite_3.splits\<close>)
+
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3
@@ -1034,11 +1079,33 @@
   | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
   | _ \<Rightarrow> a\<^sub>1)"
 
+lemmas [simp] = less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def
+
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
-        inf_finite_4_def sup_finite_4_def split: finite_4.splits\<close>)
+  apply intro_classes
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  done
+
+lemmas [simp del] = less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def
+
 end
 
 instance finite_4 :: complete_lattice ..
@@ -1048,11 +1115,14 @@
 instantiation finite_4 :: complete_boolean_algebra begin
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>4 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2 | a\<^sub>4 \<Rightarrow> a\<^sub>1)"
 definition "x - y = x \<sqinter> - (y :: finite_4)"
+lemmas [simp] =  inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def 
-        split: finite_4.splits\<close>)
+  apply intro_classes
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  done
+lemmas [simp del] =  inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4
@@ -1138,11 +1208,30 @@
    | (a\<^sub>4, _) \<Rightarrow> a\<^sub>4 | (_, a\<^sub>4) \<Rightarrow> a\<^sub>4
    | _ \<Rightarrow> a\<^sub>1)"
 
+lemmas [simp] = less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
-        Inf_finite_5_def Sup_finite_5_def split: finite_5.splits if_split_asm\<close>)
+  apply intro_classes
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  done
+lemmas [simp del] = less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def
+
 end
 
 
diff -urN ./Enum.thy~ /cygdrive/c/Isabelle2022/src/HOL/Enum.thy~
--- ./Enum.thy~	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Enum.thy~	2023-06-01 10:26:04.895887500 +0900
@@ -0,0 +1,1160 @@
+(* Author: Florian Haftmann, TU Muenchen *)
+
+section \<open>Finite types as explicit enumerations\<close>
+
+theory Enum
+imports Map Groups_List
+begin
+
+subsection \<open>Class \<open>enum\<close>\<close>
+
+class enum =
+  fixes enum :: "'a list"
+  fixes enum_all :: "('a \<Rightarrow> bool) \<Rightarrow> bool"
+  fixes enum_ex :: "('a \<Rightarrow> bool) \<Rightarrow> bool"
+  assumes UNIV_enum: "UNIV = set enum"
+    and enum_distinct: "distinct enum"
+  assumes enum_all_UNIV: "enum_all P \<longleftrightarrow> Ball UNIV P"
+  assumes enum_ex_UNIV: "enum_ex P \<longleftrightarrow> Bex UNIV P" 
+   \<comment> \<open>tailored towards simple instantiation\<close>
+begin
+
+subclass finite proof
+qed (simp add: UNIV_enum)
+
+lemma enum_UNIV:
+  "set enum = UNIV"
+  by (simp only: UNIV_enum)
+
+lemma in_enum: "x \<in> set enum"
+  by (simp add: enum_UNIV)
+
+lemma enum_eq_I:
+  assumes "\<And>x. x \<in> set xs"
+  shows "set enum = set xs"
+proof -
+  from assms UNIV_eq_I have "UNIV = set xs" by auto
+  with enum_UNIV show ?thesis by simp
+qed
+
+lemma card_UNIV_length_enum:
+  "card (UNIV :: 'a set) = length enum"
+  by (simp add: UNIV_enum distinct_card enum_distinct)
+
+lemma enum_all [simp]:
+  "enum_all = HOL.All"
+  by (simp add: fun_eq_iff enum_all_UNIV)
+
+lemma enum_ex [simp]:
+  "enum_ex = HOL.Ex" 
+  by (simp add: fun_eq_iff enum_ex_UNIV)
+
+end
+
+
+subsection \<open>Implementations using \<^class>\<open>enum\<close>\<close>
+
+subsubsection \<open>Unbounded operations and quantifiers\<close>
+
+lemma Collect_code [code]:
+  "Collect P = set (filter P enum)"
+  by (simp add: enum_UNIV)
+
+lemma vimage_code [code]:
+  "f -` B = set (filter (\<lambda>x. f x \<in> B) enum_class.enum)"
+  unfolding vimage_def Collect_code ..
+
+definition card_UNIV :: "'a itself \<Rightarrow> nat"
+where
+  [code del]: "card_UNIV TYPE('a) = card (UNIV :: 'a set)"
+
+lemma [code]:
+  "card_UNIV TYPE('a :: enum) = card (set (Enum.enum :: 'a list))"
+  by (simp only: card_UNIV_def enum_UNIV)
+
+lemma all_code [code]: "(\<forall>x. P x) \<longleftrightarrow> enum_all P"
+  by simp
+
+lemma exists_code [code]: "(\<exists>x. P x) \<longleftrightarrow> enum_ex P"
+  by simp
+
+lemma exists1_code [code]: "(\<exists>!x. P x) \<longleftrightarrow> list_ex1 P enum"
+  by (auto simp add: list_ex1_iff enum_UNIV)
+
+
+subsubsection \<open>An executable choice operator\<close>
+
+definition
+  [code del]: "enum_the = The"
+
+lemma [code]:
+  "The P = (case filter P enum of [x] \<Rightarrow> x | _ \<Rightarrow> enum_the P)"
+proof -
+  {
+    fix a
+    assume filter_enum: "filter P enum = [a]"
+    have "The P = a"
+    proof (rule the_equality)
+      fix x
+      assume "P x"
+      show "x = a"
+      proof (rule ccontr)
+        assume "x \<noteq> a"
+        from filter_enum obtain us vs
+          where enum_eq: "enum = us @ [a] @ vs"
+          and "\<forall> x \<in> set us. \<not> P x"
+          and "\<forall> x \<in> set vs. \<not> P x"
+          and "P a"
+          by (auto simp add: filter_eq_Cons_iff) (simp only: filter_empty_conv[symmetric])
+        with \<open>P x\<close> in_enum[of x, unfolded enum_eq] \<open>x \<noteq> a\<close> show "False" by auto
+      qed
+    next
+      from filter_enum show "P a" by (auto simp add: filter_eq_Cons_iff)
+    qed
+  }
+  from this show ?thesis
+    unfolding enum_the_def by (auto split: list.split)
+qed
+
+declare [[code abort: enum_the]]
+
+code_printing
+  constant enum_the \<rightharpoonup> (Eval) "(fn '_ => raise Match)"
+
+
+subsubsection \<open>Equality and order on functions\<close>
+
+instantiation "fun" :: (enum, equal) equal
+begin
+
+definition
+  "HOL.equal f g \<longleftrightarrow> (\<forall>x \<in> set enum. f x = g x)"
+
+instance proof
+qed (simp_all add: equal_fun_def fun_eq_iff enum_UNIV)
+
+end
+
+lemma [code]:
+  "HOL.equal f g \<longleftrightarrow> enum_all (%x. f x = g x)"
+  by (auto simp add: equal fun_eq_iff)
+
+lemma [code nbe]:
+  "HOL.equal (f :: _ \<Rightarrow> _) f \<longleftrightarrow> True"
+  by (fact equal_refl)
+
+lemma order_fun [code]:
+  fixes f g :: "'a::enum \<Rightarrow> 'b::order"
+  shows "f \<le> g \<longleftrightarrow> enum_all (\<lambda>x. f x \<le> g x)"
+    and "f < g \<longleftrightarrow> f \<le> g \<and> enum_ex (\<lambda>x. f x \<noteq> g x)"
+  by (simp_all add: fun_eq_iff le_fun_def order_less_le)
+
+
+subsubsection \<open>Operations on relations\<close>
+
+lemma [code]:
+  "Id = image (\<lambda>x. (x, x)) (set Enum.enum)"
+  by (auto intro: imageI in_enum)
+
+lemma tranclp_unfold [code]:
+  "tranclp r a b \<longleftrightarrow> (a, b) \<in> trancl {(x, y). r x y}"
+  by (simp add: trancl_def)
+
+lemma rtranclp_rtrancl_eq [code]:
+  "rtranclp r x y \<longleftrightarrow> (x, y) \<in> rtrancl {(x, y). r x y}"
+  by (simp add: rtrancl_def)
+
+lemma max_ext_eq [code]:
+  "max_ext R = {(X, Y). finite X \<and> finite Y \<and> Y \<noteq> {} \<and> (\<forall>x. x \<in> X \<longrightarrow> (\<exists>xa \<in> Y. (x, xa) \<in> R))}"
+  by (auto simp add: max_ext.simps)
+
+lemma max_extp_eq [code]:
+  "max_extp r x y \<longleftrightarrow> (x, y) \<in> max_ext {(x, y). r x y}"
+  by (simp add: max_ext_def)
+
+lemma mlex_eq [code]:
+  "f <*mlex*> R = {(x, y). f x < f y \<or> (f x \<le> f y \<and> (x, y) \<in> R)}"
+  by (auto simp add: mlex_prod_def)
+
+
+subsubsection \<open>Bounded accessible part\<close>
+
+primrec bacc :: "('a \<times> 'a) set \<Rightarrow> nat \<Rightarrow> 'a set" 
+where
+  "bacc r 0 = {x. \<forall> y. (y, x) \<notin> r}"
+| "bacc r (Suc n) = (bacc r n \<union> {x. \<forall>y. (y, x) \<in> r \<longrightarrow> y \<in> bacc r n})"
+
+lemma bacc_subseteq_acc:
+  "bacc r n \<subseteq> Wellfounded.acc r"
+  by (induct n) (auto intro: acc.intros)
+
+lemma bacc_mono:
+  "n \<le> m \<Longrightarrow> bacc r n \<subseteq> bacc r m"
+  by (induct rule: dec_induct) auto
+  
+lemma bacc_upper_bound:
+  "bacc (r :: ('a \<times> 'a) set)  (card (UNIV :: 'a::finite set)) = (\<Union>n. bacc r n)"
+proof -
+  have "mono (bacc r)" unfolding mono_def by (simp add: bacc_mono)
+  moreover have "\<forall>n. bacc r n = bacc r (Suc n) \<longrightarrow> bacc r (Suc n) = bacc r (Suc (Suc n))" by auto
+  moreover have "finite (range (bacc r))" by auto
+  ultimately show ?thesis
+   by (intro finite_mono_strict_prefix_implies_finite_fixpoint)
+     (auto intro: finite_mono_remains_stable_implies_strict_prefix)
+qed
+
+lemma acc_subseteq_bacc:
+  assumes "finite r"
+  shows "Wellfounded.acc r \<subseteq> (\<Union>n. bacc r n)"
+proof
+  fix x
+  assume "x \<in> Wellfounded.acc r"
+  then have "\<exists>n. x \<in> bacc r n"
+  proof (induct x arbitrary: rule: acc.induct)
+    case (accI x)
+    then have "\<forall>y. \<exists> n. (y, x) \<in> r \<longrightarrow> y \<in> bacc r n" by simp
+    from choice[OF this] obtain n where n: "\<forall>y. (y, x) \<in> r \<longrightarrow> y \<in> bacc r (n y)" ..
+    obtain n where "\<And>y. (y, x) \<in> r \<Longrightarrow> y \<in> bacc r n"
+    proof
+      fix y assume y: "(y, x) \<in> r"
+      with n have "y \<in> bacc r (n y)" by auto
+      moreover have "n y <= Max ((\<lambda>(y, x). n y) ` r)"
+        using y \<open>finite r\<close> by (auto intro!: Max_ge)
+      note bacc_mono[OF this, of r]
+      ultimately show "y \<in> bacc r (Max ((\<lambda>(y, x). n y) ` r))" by auto
+    qed
+    then show ?case
+      by (auto simp add: Let_def intro!: exI[of _ "Suc n"])
+  qed
+  then show "x \<in> (\<Union>n. bacc r n)" by auto
+qed
+
+lemma acc_bacc_eq:
+  fixes A :: "('a :: finite \<times> 'a) set"
+  assumes "finite A"
+  shows "Wellfounded.acc A = bacc A (card (UNIV :: 'a set))"
+  using assms by (metis acc_subseteq_bacc bacc_subseteq_acc bacc_upper_bound order_eq_iff)
+
+lemma [code]:
+  fixes xs :: "('a::finite \<times> 'a) list"
+  shows "Wellfounded.acc (set xs) = bacc (set xs) (card_UNIV TYPE('a))"
+  by (simp add: card_UNIV_def acc_bacc_eq)
+
+
+subsection \<open>Default instances for \<^class>\<open>enum\<close>\<close>
+
+lemma map_of_zip_enum_is_Some:
+  assumes "length ys = length (enum :: 'a::enum list)"
+  shows "\<exists>y. map_of (zip (enum :: 'a::enum list) ys) x = Some y"
+proof -
+  from assms have "x \<in> set (enum :: 'a::enum list) \<longleftrightarrow>
+    (\<exists>y. map_of (zip (enum :: 'a::enum list) ys) x = Some y)"
+    by (auto intro!: map_of_zip_is_Some)
+  then show ?thesis using enum_UNIV by auto
+qed
+
+lemma map_of_zip_enum_inject:
+  fixes xs ys :: "'b::enum list"
+  assumes length: "length xs = length (enum :: 'a::enum list)"
+      "length ys = length (enum :: 'a::enum list)"
+    and map_of: "the \<circ> map_of (zip (enum :: 'a::enum list) xs) = the \<circ> map_of (zip (enum :: 'a::enum list) ys)"
+  shows "xs = ys"
+proof -
+  have "map_of (zip (enum :: 'a list) xs) = map_of (zip (enum :: 'a list) ys)"
+  proof
+    fix x :: 'a
+    from length map_of_zip_enum_is_Some obtain y1 y2
+      where "map_of (zip (enum :: 'a list) xs) x = Some y1"
+        and "map_of (zip (enum :: 'a list) ys) x = Some y2" by blast
+    moreover from map_of
+      have "the (map_of (zip (enum :: 'a::enum list) xs) x) = the (map_of (zip (enum :: 'a::enum list) ys) x)"
+      by (auto dest: fun_cong)
+    ultimately show "map_of (zip (enum :: 'a::enum list) xs) x = map_of (zip (enum :: 'a::enum list) ys) x"
+      by simp
+  qed
+  with length enum_distinct show "xs = ys" by (rule map_of_zip_inject)
+qed
+
+definition all_n_lists :: "(('a :: enum) list \<Rightarrow> bool) \<Rightarrow> nat \<Rightarrow> bool"
+where
+  "all_n_lists P n \<longleftrightarrow> (\<forall>xs \<in> set (List.n_lists n enum). P xs)"
+
+lemma [code]:
+  "all_n_lists P n \<longleftrightarrow> (if n = 0 then P [] else enum_all (%x. all_n_lists (%xs. P (x # xs)) (n - 1)))"
+  unfolding all_n_lists_def enum_all
+  by (cases n) (auto simp add: enum_UNIV)
+
+definition ex_n_lists :: "(('a :: enum) list \<Rightarrow> bool) \<Rightarrow> nat \<Rightarrow> bool"
+where
+  "ex_n_lists P n \<longleftrightarrow> (\<exists>xs \<in> set (List.n_lists n enum). P xs)"
+
+lemma [code]:
+  "ex_n_lists P n \<longleftrightarrow> (if n = 0 then P [] else enum_ex (%x. ex_n_lists (%xs. P (x # xs)) (n - 1)))"
+  unfolding ex_n_lists_def enum_ex
+  by (cases n) (auto simp add: enum_UNIV)
+
+instantiation "fun" :: (enum, enum) enum
+begin
+
+definition
+  "enum = map (\<lambda>ys. the \<circ> map_of (zip (enum::'a list) ys)) (List.n_lists (length (enum::'a::enum list)) enum)"
+
+definition
+  "enum_all P = all_n_lists (\<lambda>bs. P (the \<circ> map_of (zip enum bs))) (length (enum :: 'a list))"
+
+definition
+  "enum_ex P = ex_n_lists (\<lambda>bs. P (the \<circ> map_of (zip enum bs))) (length (enum :: 'a list))"
+
+instance proof
+  show "UNIV = set (enum :: ('a \<Rightarrow> 'b) list)"
+  proof (rule UNIV_eq_I)
+    fix f :: "'a \<Rightarrow> 'b"
+    have "f = the \<circ> map_of (zip (enum :: 'a::enum list) (map f enum))"
+      by (auto simp add: map_of_zip_map fun_eq_iff intro: in_enum)
+    then show "f \<in> set enum"
+      by (auto simp add: enum_fun_def set_n_lists intro: in_enum)
+  qed
+next
+  from map_of_zip_enum_inject
+  show "distinct (enum :: ('a \<Rightarrow> 'b) list)"
+    by (auto intro!: inj_onI simp add: enum_fun_def
+      distinct_map distinct_n_lists enum_distinct set_n_lists)
+next
+  fix P
+  show "enum_all (P :: ('a \<Rightarrow> 'b) \<Rightarrow> bool) = Ball UNIV P"
+  proof
+    assume "enum_all P"
+    show "Ball UNIV P"
+    proof
+      fix f :: "'a \<Rightarrow> 'b"
+      have f: "f = the \<circ> map_of (zip (enum :: 'a::enum list) (map f enum))"
+        by (auto simp add: map_of_zip_map fun_eq_iff intro: in_enum)
+      from \<open>enum_all P\<close> have "P (the \<circ> map_of (zip enum (map f enum)))"
+        unfolding enum_all_fun_def all_n_lists_def
+        apply (simp add: set_n_lists)
+        apply (erule_tac x="map f enum" in allE)
+        apply (auto intro!: in_enum)
+        done
+      from this f show "P f" by auto
+    qed
+  next
+    assume "Ball UNIV P"
+    from this show "enum_all P"
+      unfolding enum_all_fun_def all_n_lists_def by auto
+  qed
+next
+  fix P
+  show "enum_ex (P :: ('a \<Rightarrow> 'b) \<Rightarrow> bool) = Bex UNIV P"
+  proof
+    assume "enum_ex P"
+    from this show "Bex UNIV P"
+      unfolding enum_ex_fun_def ex_n_lists_def by auto
+  next
+    assume "Bex UNIV P"
+    from this obtain f where "P f" ..
+    have f: "f = the \<circ> map_of (zip (enum :: 'a::enum list) (map f enum))"
+      by (auto simp add: map_of_zip_map fun_eq_iff intro: in_enum) 
+    from \<open>P f\<close> this have "P (the \<circ> map_of (zip (enum :: 'a::enum list) (map f enum)))"
+      by auto
+    from  this show "enum_ex P"
+      unfolding enum_ex_fun_def ex_n_lists_def
+      apply (auto simp add: set_n_lists)
+      apply (rule_tac x="map f enum" in exI)
+      apply (auto intro!: in_enum)
+      done
+  qed
+qed
+
+end
+
+lemma enum_fun_code [code]: "enum = (let enum_a = (enum :: 'a::{enum, equal} list)
+  in map (\<lambda>ys. the \<circ> map_of (zip enum_a ys)) (List.n_lists (length enum_a) enum))"
+  by (simp add: enum_fun_def Let_def)
+
+lemma enum_all_fun_code [code]:
+  "enum_all P = (let enum_a = (enum :: 'a::{enum, equal} list)
+   in all_n_lists (\<lambda>bs. P (the \<circ> map_of (zip enum_a bs))) (length enum_a))"
+  by (simp only: enum_all_fun_def Let_def)
+
+lemma enum_ex_fun_code [code]:
+  "enum_ex P = (let enum_a = (enum :: 'a::{enum, equal} list)
+   in ex_n_lists (\<lambda>bs. P (the \<circ> map_of (zip enum_a bs))) (length enum_a))"
+  by (simp only: enum_ex_fun_def Let_def)
+
+instantiation set :: (enum) enum
+begin
+
+definition
+  "enum = map set (subseqs enum)"
+
+definition
+  "enum_all P \<longleftrightarrow> (\<forall>A\<in>set enum. P (A::'a set))"
+
+definition
+  "enum_ex P \<longleftrightarrow> (\<exists>A\<in>set enum. P (A::'a set))"
+
+instance proof
+qed (simp_all add: enum_set_def enum_all_set_def enum_ex_set_def subseqs_powset distinct_set_subseqs
+  enum_distinct enum_UNIV)
+
+end
+
+instantiation unit :: enum
+begin
+
+definition
+  "enum = [()]"
+
+definition
+  "enum_all P = P ()"
+
+definition
+  "enum_ex P = P ()"
+
+instance proof
+qed (auto simp add: enum_unit_def enum_all_unit_def enum_ex_unit_def)
+
+end
+
+instantiation bool :: enum
+begin
+
+definition
+  "enum = [False, True]"
+
+definition
+  "enum_all P \<longleftrightarrow> P False \<and> P True"
+
+definition
+  "enum_ex P \<longleftrightarrow> P False \<or> P True"
+
+instance proof
+qed (simp_all only: enum_bool_def enum_all_bool_def enum_ex_bool_def UNIV_bool, simp_all)
+
+end
+
+instantiation prod :: (enum, enum) enum
+begin
+
+definition
+  "enum = List.product enum enum"
+
+definition
+  "enum_all P = enum_all (%x. enum_all (%y. P (x, y)))"
+
+definition
+  "enum_ex P = enum_ex (%x. enum_ex (%y. P (x, y)))"
+
+ 
+instance
+  by standard
+    (simp_all add: enum_prod_def distinct_product
+      enum_UNIV enum_distinct enum_all_prod_def enum_ex_prod_def)
+
+end
+
+instantiation sum :: (enum, enum) enum
+begin
+
+definition
+  "enum = map Inl enum @ map Inr enum"
+
+definition
+  "enum_all P \<longleftrightarrow> enum_all (\<lambda>x. P (Inl x)) \<and> enum_all (\<lambda>x. P (Inr x))"
+
+definition
+  "enum_ex P \<longleftrightarrow> enum_ex (\<lambda>x. P (Inl x)) \<or> enum_ex (\<lambda>x. P (Inr x))"
+
+instance proof
+qed (simp_all only: enum_sum_def enum_all_sum_def enum_ex_sum_def UNIV_sum,
+  auto simp add: enum_UNIV distinct_map enum_distinct)
+
+end
+
+instantiation option :: (enum) enum
+begin
+
+definition
+  "enum = None # map Some enum"
+
+definition
+  "enum_all P \<longleftrightarrow> P None \<and> enum_all (\<lambda>x. P (Some x))"
+
+definition
+  "enum_ex P \<longleftrightarrow> P None \<or> enum_ex (\<lambda>x. P (Some x))"
+
+instance proof
+qed (simp_all only: enum_option_def enum_all_option_def enum_ex_option_def UNIV_option_conv,
+  auto simp add: distinct_map enum_UNIV enum_distinct)
+
+end
+
+
+subsection \<open>Small finite types\<close>
+
+text \<open>We define small finite types for use in Quickcheck\<close>
+
+datatype (plugins only: code "quickcheck" extraction) finite_1 =
+  a\<^sub>1
+
+notation (output) a\<^sub>1  ("a\<^sub>1")
+
+lemma UNIV_finite_1:
+  "UNIV = {a\<^sub>1}"
+  by (auto intro: finite_1.exhaust)
+
+instantiation finite_1 :: enum
+begin
+
+definition
+  "enum = [a\<^sub>1]"
+
+definition
+  "enum_all P = P a\<^sub>1"
+
+definition
+  "enum_ex P = P a\<^sub>1"
+
+instance proof
+qed (simp_all only: enum_finite_1_def enum_all_finite_1_def enum_ex_finite_1_def UNIV_finite_1, simp_all)
+
+end
+
+instantiation finite_1 :: linorder
+begin
+
+definition less_finite_1 :: "finite_1 \<Rightarrow> finite_1 \<Rightarrow> bool"
+where
+  "x < (y :: finite_1) \<longleftrightarrow> False"
+
+definition less_eq_finite_1 :: "finite_1 \<Rightarrow> finite_1 \<Rightarrow> bool"
+where
+  "x \<le> (y :: finite_1) \<longleftrightarrow> True"
+
+instance
+apply (intro_classes)
+apply (auto simp add: less_finite_1_def less_eq_finite_1_def)
+apply (metis (full_types) finite_1.exhaust)
+done
+
+end
+
+instance finite_1 :: "{dense_linorder, wellorder}"
+by intro_classes (simp_all add: less_finite_1_def)
+
+instantiation finite_1 :: complete_lattice
+begin
+
+definition [simp]: "Inf = (\<lambda>_. a\<^sub>1)"
+definition [simp]: "Sup = (\<lambda>_. a\<^sub>1)"
+definition [simp]: "bot = a\<^sub>1"
+definition [simp]: "top = a\<^sub>1"
+definition [simp]: "inf = (\<lambda>_ _. a\<^sub>1)"
+definition [simp]: "sup = (\<lambda>_ _. a\<^sub>1)"
+
+instance by intro_classes(simp_all add: less_eq_finite_1_def)
+end
+
+instance finite_1 :: complete_distrib_lattice
+  by standard simp_all
+
+instance finite_1 :: complete_linorder ..
+
+lemma finite_1_eq: "x = a\<^sub>1"
+by(cases x) simp
+
+simproc_setup finite_1_eq ("x::finite_1") = \<open>
+  fn _ => fn _ => fn ct =>
+    (case Thm.term_of ct of
+      Const (\<^const_name>\<open>a\<^sub>1\<close>, _) => NONE
+    | _ => SOME (mk_meta_eq @{thm finite_1_eq}))
+\<close>
+
+instantiation finite_1 :: complete_boolean_algebra
+begin
+definition [simp]: "(-) = (\<lambda>_ _. a\<^sub>1)"
+definition [simp]: "uminus = (\<lambda>_. a\<^sub>1)"
+instance by intro_classes simp_all
+end
+
+instantiation finite_1 :: 
+  "{linordered_ring_strict, linordered_comm_semiring_strict, ordered_comm_ring,
+    ordered_cancel_comm_monoid_diff, comm_monoid_mult, ordered_ring_abs,
+    one, modulo, sgn, inverse}"
+begin
+definition [simp]: "Groups.zero = a\<^sub>1"
+definition [simp]: "Groups.one = a\<^sub>1"
+definition [simp]: "(+) = (\<lambda>_ _. a\<^sub>1)"
+definition [simp]: "(*) = (\<lambda>_ _. a\<^sub>1)"
+definition [simp]: "(mod) = (\<lambda>_ _. a\<^sub>1)" 
+definition [simp]: "abs = (\<lambda>_. a\<^sub>1)"
+definition [simp]: "sgn = (\<lambda>_. a\<^sub>1)"
+definition [simp]: "inverse = (\<lambda>_. a\<^sub>1)"
+definition [simp]: "divide = (\<lambda>_ _. a\<^sub>1)"
+
+instance by intro_classes(simp_all add: less_finite_1_def)
+end
+
+declare [[simproc del: finite_1_eq]]
+hide_const (open) a\<^sub>1
+
+datatype (plugins only: code "quickcheck" extraction) finite_2 =
+  a\<^sub>1 | a\<^sub>2
+
+notation (output) a\<^sub>1  ("a\<^sub>1")
+notation (output) a\<^sub>2  ("a\<^sub>2")
+
+lemma UNIV_finite_2:
+  "UNIV = {a\<^sub>1, a\<^sub>2}"
+  by (auto intro: finite_2.exhaust)
+
+instantiation finite_2 :: enum
+begin
+
+definition
+  "enum = [a\<^sub>1, a\<^sub>2]"
+
+definition
+  "enum_all P \<longleftrightarrow> P a\<^sub>1 \<and> P a\<^sub>2"
+
+definition
+  "enum_ex P \<longleftrightarrow> P a\<^sub>1 \<or> P a\<^sub>2"
+
+instance proof
+qed (simp_all only: enum_finite_2_def enum_all_finite_2_def enum_ex_finite_2_def UNIV_finite_2, simp_all)
+
+end
+
+instantiation finite_2 :: linorder
+begin
+
+definition less_finite_2 :: "finite_2 \<Rightarrow> finite_2 \<Rightarrow> bool"
+where
+  "x < y \<longleftrightarrow> x = a\<^sub>1 \<and> y = a\<^sub>2"
+
+definition less_eq_finite_2 :: "finite_2 \<Rightarrow> finite_2 \<Rightarrow> bool"
+where
+  "x \<le> y \<longleftrightarrow> x = y \<or> x < (y :: finite_2)"
+
+instance
+apply (intro_classes)
+apply (auto simp add: less_finite_2_def less_eq_finite_2_def)
+apply (metis finite_2.nchotomy)+
+done
+
+end
+
+instance finite_2 :: wellorder
+by(rule wf_wellorderI)(simp add: less_finite_2_def, intro_classes)
+
+instantiation finite_2 :: complete_lattice
+begin
+
+definition "\<Sqinter>A = (if a\<^sub>1 \<in> A then a\<^sub>1 else a\<^sub>2)"
+definition "\<Squnion>A = (if a\<^sub>2 \<in> A then a\<^sub>2 else a\<^sub>1)"
+definition [simp]: "bot = a\<^sub>1"
+definition [simp]: "top = a\<^sub>2"
+definition "x \<sqinter> y = (if x = a\<^sub>1 \<or> y = a\<^sub>1 then a\<^sub>1 else a\<^sub>2)"
+definition "x \<squnion> y = (if x = a\<^sub>2 \<or> y = a\<^sub>2 then a\<^sub>2 else a\<^sub>1)"
+
+lemma neq_finite_2_a\<^sub>1_iff [simp]: "x \<noteq> a\<^sub>1 \<longleftrightarrow> x = a\<^sub>2"
+by(cases x) simp_all
+
+lemma neq_finite_2_a\<^sub>1_iff' [simp]: "a\<^sub>1 \<noteq> x \<longleftrightarrow> x = a\<^sub>2"
+by(cases x) simp_all
+
+lemma neq_finite_2_a\<^sub>2_iff [simp]: "x \<noteq> a\<^sub>2 \<longleftrightarrow> x = a\<^sub>1"
+by(cases x) simp_all
+
+lemma neq_finite_2_a\<^sub>2_iff' [simp]: "a\<^sub>2 \<noteq> x \<longleftrightarrow> x = a\<^sub>1"
+by(cases x) simp_all
+
+instance
+proof
+  fix x :: finite_2 and A
+  assume "x \<in> A"
+  then show "\<Sqinter>A \<le> x" "x \<le> \<Squnion>A"
+    by(cases x; auto simp add: less_eq_finite_2_def less_finite_2_def Inf_finite_2_def Sup_finite_2_def)+
+qed(auto simp add: less_eq_finite_2_def less_finite_2_def inf_finite_2_def sup_finite_2_def Inf_finite_2_def Sup_finite_2_def)
+end
+
+instance finite_2 :: complete_linorder ..
+
+instance finite_2 :: complete_distrib_lattice ..
+
+instantiation finite_2 :: "{field, idom_abs_sgn, idom_modulo}" begin
+definition [simp]: "0 = a\<^sub>1"
+definition [simp]: "1 = a\<^sub>2"
+definition "x + y = (case (x, y) of (a\<^sub>1, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>1 | _ \<Rightarrow> a\<^sub>2)"
+definition "uminus = (\<lambda>x :: finite_2. x)"
+definition "(-) = ((+) :: finite_2 \<Rightarrow> _)"
+definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> a\<^sub>1)"
+definition "inverse = (\<lambda>x :: finite_2. x)"
+definition "divide = ((*) :: finite_2 \<Rightarrow> _)"
+definition "x mod y = (case (x, y) of (a\<^sub>2, a\<^sub>1) \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> a\<^sub>1)"
+definition "abs = (\<lambda>x :: finite_2. x)"
+definition "sgn = (\<lambda>x :: finite_2. x)"
+instance
+  by standard
+    (subproofs
+      \<open>simp_all add: plus_finite_2_def uminus_finite_2_def minus_finite_2_def
+        times_finite_2_def
+        inverse_finite_2_def divide_finite_2_def modulo_finite_2_def
+        abs_finite_2_def sgn_finite_2_def
+        split: finite_2.splits\<close>)
+end
+
+lemma two_finite_2 [simp]:
+  "2 = a\<^sub>1"
+  by (simp add: numeral.simps plus_finite_2_def)
+
+lemma dvd_finite_2_unfold:
+  "x dvd y \<longleftrightarrow> x = a\<^sub>2 \<or> y = a\<^sub>1"
+  by (auto simp add: dvd_def times_finite_2_def split: finite_2.splits)
+
+instantiation finite_2 :: "{normalization_semidom, unique_euclidean_semiring}" begin
+definition [simp]: "normalize = (id :: finite_2 \<Rightarrow> _)"
+definition [simp]: "unit_factor = (id :: finite_2 \<Rightarrow> _)"
+definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | a\<^sub>2 \<Rightarrow> 1)"
+definition [simp]: "division_segment (x :: finite_2) = 1"
+instance
+  by standard
+    (subproofs
+      \<open>auto simp add: divide_finite_2_def times_finite_2_def dvd_finite_2_unfold
+        split: finite_2.splits\<close>)
+end
+
+ 
+hide_const (open) a\<^sub>1 a\<^sub>2
+
+datatype (plugins only: code "quickcheck" extraction) finite_3 =
+  a\<^sub>1 | a\<^sub>2 | a\<^sub>3
+
+notation (output) a\<^sub>1  ("a\<^sub>1")
+notation (output) a\<^sub>2  ("a\<^sub>2")
+notation (output) a\<^sub>3  ("a\<^sub>3")
+
+lemma UNIV_finite_3:
+  "UNIV = {a\<^sub>1, a\<^sub>2, a\<^sub>3}"
+  by (auto intro: finite_3.exhaust)
+
+instantiation finite_3 :: enum
+begin
+
+definition
+  "enum = [a\<^sub>1, a\<^sub>2, a\<^sub>3]"
+
+definition
+  "enum_all P \<longleftrightarrow> P a\<^sub>1 \<and> P a\<^sub>2 \<and> P a\<^sub>3"
+
+definition
+  "enum_ex P \<longleftrightarrow> P a\<^sub>1 \<or> P a\<^sub>2 \<or> P a\<^sub>3"
+
+instance proof
+qed (simp_all only: enum_finite_3_def enum_all_finite_3_def enum_ex_finite_3_def UNIV_finite_3, simp_all)
+
+end
+
+lemma finite_3_not_eq_unfold:
+  "x \<noteq> a\<^sub>1 \<longleftrightarrow> x \<in> {a\<^sub>2, a\<^sub>3}"
+  "x \<noteq> a\<^sub>2 \<longleftrightarrow> x \<in> {a\<^sub>1, a\<^sub>3}"
+  "x \<noteq> a\<^sub>3 \<longleftrightarrow> x \<in> {a\<^sub>1, a\<^sub>2}"
+  by (cases x; simp)+
+
+instantiation finite_3 :: linorder
+begin
+
+definition less_finite_3 :: "finite_3 \<Rightarrow> finite_3 \<Rightarrow> bool"
+where
+  "x < y = (case x of a\<^sub>1 \<Rightarrow> y \<noteq> a\<^sub>1 | a\<^sub>2 \<Rightarrow> y = a\<^sub>3 | a\<^sub>3 \<Rightarrow> False)"
+
+definition less_eq_finite_3 :: "finite_3 \<Rightarrow> finite_3 \<Rightarrow> bool"
+where
+  "x \<le> y \<longleftrightarrow> x = y \<or> x < (y :: finite_3)"
+
+instance proof (intro_classes)
+qed (auto simp add: less_finite_3_def less_eq_finite_3_def split: finite_3.split_asm)
+
+end
+
+instance finite_3 :: wellorder
+proof(rule wf_wellorderI)
+  have "inv_image less_than (case_finite_3 0 1 2) = {(x, y). x < y}"
+    by(auto simp add: less_finite_3_def split: finite_3.splits)
+  from this[symmetric] show "wf \<dots>" by simp
+qed intro_classes
+
+class finite_lattice = finite +  lattice + Inf + Sup  + bot + top +
+  assumes Inf_finite_empty: "Inf {} = Sup UNIV"
+  assumes Inf_finite_insert: "Inf (insert a A) = a \<sqinter> Inf A"
+  assumes Sup_finite_empty: "Sup {} = Inf UNIV"
+  assumes Sup_finite_insert: "Sup (insert a A) = a \<squnion> Sup A"
+  assumes bot_finite_def: "bot = Inf UNIV"
+  assumes top_finite_def: "top = Sup UNIV"
+begin
+
+subclass complete_lattice
+proof
+  fix x A
+  show "x \<in> A \<Longrightarrow> \<Sqinter>A \<le> x"
+    by (metis Set.set_insert abel_semigroup.commute local.Inf_finite_insert local.inf.abel_semigroup_axioms local.inf.left_idem local.inf.orderI)
+  show "x \<in> A \<Longrightarrow> x \<le> \<Squnion>A"
+    by (metis Set.set_insert insert_absorb2 local.Sup_finite_insert local.sup.absorb_iff2)
+next
+  fix A z
+  have "\<Squnion> UNIV = z \<squnion> \<Squnion>UNIV"
+    by (subst Sup_finite_insert [symmetric], simp add: insert_UNIV)
+  from this have [simp]: "z \<le> \<Squnion>UNIV"
+    using local.le_iff_sup by auto
+  have "(\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"
+    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"])
+      (simp_all add: Inf_finite_empty Inf_finite_insert)
+  from this show "(\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow> z \<le> \<Sqinter>A"
+    by simp
+
+  have "\<Sqinter> UNIV = z \<sqinter> \<Sqinter>UNIV"
+    by (subst Inf_finite_insert [symmetric], simp add: insert_UNIV)
+  from this have [simp]: "\<Sqinter>UNIV \<le> z"
+    by (simp add: local.inf.absorb_iff2)
+  have "(\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z"
+    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z" ], simp_all add: Sup_finite_empty Sup_finite_insert)
+  from this show " (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow> \<Squnion>A \<le> z"
+    by blast
+next
+  show "\<Sqinter>{} = \<top>"
+    by (simp add: Inf_finite_empty top_finite_def)
+  show " \<Squnion>{} = \<bottom>"
+    by (simp add: Sup_finite_empty bot_finite_def)
+qed
+end
+
+class finite_distrib_lattice = finite_lattice + distrib_lattice 
+begin
+lemma finite_inf_Sup: "a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"
+proof (rule finite_induct [of A "\<lambda> A . a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"], simp_all)
+  fix x::"'a"
+  fix F
+  assume "x \<notin> F"
+  assume [simp]: "a \<sqinter> \<Squnion>F = \<Squnion>{a \<sqinter> b |b. b \<in> F}"
+  have [simp]: " insert (a \<sqinter> x) {a \<sqinter> b |b. b \<in> F} = {a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by blast
+  have "a \<sqinter> (x \<squnion> \<Squnion>F) = a \<sqinter> x \<squnion> a \<sqinter> \<Squnion>F"
+    by (simp add: inf_sup_distrib1)
+  also have "... = a \<sqinter> x \<squnion> \<Squnion>{a \<sqinter> b |b. b \<in> F}"
+    by simp
+  also have "... = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by (unfold Sup_insert[THEN sym], simp)
+  finally show "a \<sqinter> (x \<squnion> \<Squnion>F) = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by simp
+qed
+
+lemma finite_Inf_Sup: "\<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"
+proof (rule finite_induct [of A "\<lambda>A. \<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"], simp_all add: finite_UnionD)
+  fix x::"'a set"
+  fix F
+  assume "x \<notin> F"
+  have [simp]: "{\<Squnion>x \<sqinter> b |b . b \<in> Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y} } = {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  . (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by auto
+  define fa where "fa = (\<lambda> (b::'a) f Y . (if Y = x then b else f Y))"
+  have "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> insert b (f ` (F \<inter> {Y. Y \<noteq> x})) = insert (fa b f x) (fa b f ` F) \<and> fa b f x \<in> x \<and> (\<forall>Y\<in>F. fa b f Y \<in> Y)"
+    by (auto simp add: fa_def)
+  from this have B: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> fa b f ` ({x} \<union> F) \<in> {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by blast
+  have [simp]: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> b \<sqinter> (\<Sqinter>x\<in>F. f x)  \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    using B apply (rule SUP_upper2)
+    using \<open>x \<notin> F\<close> apply (simp_all add: fa_def Inf_union_distrib)
+    apply (simp add: image_mono Inf_superset_mono inf.coboundedI2)
+    done
+  assume "\<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
+
+  from this have "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>x \<sqinter> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
+    using inf.coboundedI2 by auto
+  also have "... = Sup {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by (simp add: finite_inf_Sup)
+
+  also have "... = Sup {Sup {Inf (f ` F) \<sqinter> b | b . b \<in> x} |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by (subst inf_commute) (simp add: finite_inf_Sup)
+
+  also have "... \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    apply (rule Sup_least, clarsimp)+
+    apply (subst inf_commute, simp)
+    done
+
+  finally show "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    by simp
+qed
+
+subclass complete_distrib_lattice
+  by (standard, rule finite_Inf_Sup)
+end
+
+instantiation finite_3 :: finite_lattice
+begin
+
+definition "\<Sqinter>A = (if a\<^sub>1 \<in> A then a\<^sub>1 else if a\<^sub>2 \<in> A then a\<^sub>2 else a\<^sub>3)"
+definition "\<Squnion>A = (if a\<^sub>3 \<in> A then a\<^sub>3 else if a\<^sub>2 \<in> A then a\<^sub>2 else a\<^sub>1)"
+definition [simp]: "bot = a\<^sub>1"
+definition [simp]: "top = a\<^sub>3"
+definition [simp]: "inf = (min :: finite_3 \<Rightarrow> _)"
+definition [simp]: "sup = (max :: finite_3 \<Rightarrow> _)"
+
+instance
+proof
+qed (auto simp add: Inf_finite_3_def Sup_finite_3_def max_def min_def less_eq_finite_3_def less_finite_3_def split: finite_3.split)
+end
+
+instance finite_3 :: complete_lattice ..
+
+instance finite_3 :: finite_distrib_lattice
+proof 
+qed (auto simp add: min_def max_def)
+
+instance finite_3 :: complete_distrib_lattice ..
+
+instance finite_3 :: complete_linorder ..
+
+instantiation finite_3 :: "{field, idom_abs_sgn, idom_modulo}" begin
+definition [simp]: "0 = a\<^sub>1"
+definition [simp]: "1 = a\<^sub>2"
+definition
+  "x + y = (case (x, y) of
+     (a\<^sub>1, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>1 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>1
+   | (a\<^sub>1, a\<^sub>2) \<Rightarrow> a\<^sub>2 | (a\<^sub>2, a\<^sub>1) \<Rightarrow> a\<^sub>2 | (a\<^sub>3, a\<^sub>3) \<Rightarrow> a\<^sub>2
+   | _ \<Rightarrow> a\<^sub>3)"
+definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>1 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2)"
+definition "x - y = x + (- y :: finite_3)"
+definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | (a\<^sub>3, a\<^sub>3) \<Rightarrow> a\<^sub>2 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>3 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>3 | _ \<Rightarrow> a\<^sub>1)"
+definition "inverse = (\<lambda>x :: finite_3. x)" 
+definition "x div y = x * inverse (y :: finite_3)"
+definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
+definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
+definition "sgn = (\<lambda>x :: finite_3. x)"
+instance
+  by standard
+    (subproofs
+      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+        times_finite_3_def
+        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
+        abs_finite_3_def sgn_finite_3_def
+        less_finite_3_def
+        split: finite_3.splits\<close>)
+end
+
+lemma two_finite_3 [simp]:
+  "2 = a\<^sub>3"
+  by (simp add: numeral.simps plus_finite_3_def)
+
+lemma dvd_finite_3_unfold:
+  "x dvd y \<longleftrightarrow> x = a\<^sub>2 \<or> x = a\<^sub>3 \<or> y = a\<^sub>1"
+  by (cases x) (auto simp add: dvd_def times_finite_3_def split: finite_3.splits)
+
+instantiation finite_3 :: "{normalization_semidom, unique_euclidean_semiring}" begin
+definition [simp]: "normalize x = (case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
+definition [simp]: "unit_factor = (id :: finite_3 \<Rightarrow> _)"
+definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | _ \<Rightarrow> 1)"
+definition [simp]: "division_segment (x :: finite_3) = 1"
+instance
+proof
+  fix x :: finite_3
+  assume "x \<noteq> 0"
+  then show "is_unit (unit_factor x)"
+    by (cases x) (simp_all add: dvd_finite_3_unfold)
+qed
+  (subproofs
+    \<open>auto simp add: divide_finite_3_def times_finite_3_def
+      dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
+      split: finite_3.splits\<close>)
+end
+
+hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3
+
+datatype (plugins only: code "quickcheck" extraction) finite_4 =
+  a\<^sub>1 | a\<^sub>2 | a\<^sub>3 | a\<^sub>4
+
+notation (output) a\<^sub>1  ("a\<^sub>1")
+notation (output) a\<^sub>2  ("a\<^sub>2")
+notation (output) a\<^sub>3  ("a\<^sub>3")
+notation (output) a\<^sub>4  ("a\<^sub>4")
+
+lemma UNIV_finite_4:
+  "UNIV = {a\<^sub>1, a\<^sub>2, a\<^sub>3, a\<^sub>4}"
+  by (auto intro: finite_4.exhaust)
+
+instantiation finite_4 :: enum
+begin
+
+definition
+  "enum = [a\<^sub>1, a\<^sub>2, a\<^sub>3, a\<^sub>4]"
+
+definition
+  "enum_all P \<longleftrightarrow> P a\<^sub>1 \<and> P a\<^sub>2 \<and> P a\<^sub>3 \<and> P a\<^sub>4"
+
+definition
+  "enum_ex P \<longleftrightarrow> P a\<^sub>1 \<or> P a\<^sub>2 \<or> P a\<^sub>3 \<or> P a\<^sub>4"
+
+instance proof
+qed (simp_all only: enum_finite_4_def enum_all_finite_4_def enum_ex_finite_4_def UNIV_finite_4, simp_all)
+
+end
+
+instantiation finite_4 :: finite_distrib_lattice begin
+
+text \<open>\<^term>\<open>a\<^sub>1\<close> $<$ \<^term>\<open>a\<^sub>2\<close>,\<^term>\<open>a\<^sub>3\<close> $<$ \<^term>\<open>a\<^sub>4\<close>,
+  but \<^term>\<open>a\<^sub>2\<close> and \<^term>\<open>a\<^sub>3\<close> are incomparable.\<close>
+
+definition
+  "x < y \<longleftrightarrow> (case (x, y) of
+     (a\<^sub>1, a\<^sub>1) \<Rightarrow> False | (a\<^sub>1, _) \<Rightarrow> True
+   |  (a\<^sub>2, a\<^sub>4) \<Rightarrow> True
+   |  (a\<^sub>3, a\<^sub>4) \<Rightarrow> True  | _ \<Rightarrow> False)"
+
+definition 
+  "x \<le> y \<longleftrightarrow> (case (x, y) of
+     (a\<^sub>1, _) \<Rightarrow> True
+   | (a\<^sub>2, a\<^sub>2) \<Rightarrow> True | (a\<^sub>2, a\<^sub>4) \<Rightarrow> True
+   | (a\<^sub>3, a\<^sub>3) \<Rightarrow> True | (a\<^sub>3, a\<^sub>4) \<Rightarrow> True
+   | (a\<^sub>4, a\<^sub>4) \<Rightarrow> True | _ \<Rightarrow> False)"
+
+definition
+  "\<Sqinter>A = (if a\<^sub>1 \<in> A \<or> a\<^sub>2 \<in> A \<and> a\<^sub>3 \<in> A then a\<^sub>1 else if a\<^sub>2 \<in> A then a\<^sub>2 else if a\<^sub>3 \<in> A then a\<^sub>3 else a\<^sub>4)"
+definition
+  "\<Squnion>A = (if a\<^sub>4 \<in> A \<or> a\<^sub>2 \<in> A \<and> a\<^sub>3 \<in> A then a\<^sub>4 else if a\<^sub>2 \<in> A then a\<^sub>2 else if a\<^sub>3 \<in> A then a\<^sub>3 else a\<^sub>1)"
+definition [simp]: "bot = a\<^sub>1"
+definition [simp]: "top = a\<^sub>4"
+definition
+  "x \<sqinter> y = (case (x, y) of
+     (a\<^sub>1, _) \<Rightarrow> a\<^sub>1 | (_, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>1 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>1
+   | (a\<^sub>2, _) \<Rightarrow> a\<^sub>2 | (_, a\<^sub>2) \<Rightarrow> a\<^sub>2
+   | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
+   | _ \<Rightarrow> a\<^sub>4)"
+definition
+  "x \<squnion> y = (case (x, y) of
+     (a\<^sub>4, _) \<Rightarrow> a\<^sub>4 | (_, a\<^sub>4) \<Rightarrow> a\<^sub>4 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>4 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>4
+  | (a\<^sub>2, _) \<Rightarrow> a\<^sub>2 | (_, a\<^sub>2) \<Rightarrow> a\<^sub>2
+  | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
+  | _ \<Rightarrow> a\<^sub>1)"
+
+instance
+  by standard
+    (subproofs
+      \<open>auto simp add: less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def split: finite_4.splits\<close>)
+end
+
+instance finite_4 :: complete_lattice ..
+
+instance finite_4 :: complete_distrib_lattice ..
+
+instantiation finite_4 :: complete_boolean_algebra begin
+definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>4 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2 | a\<^sub>4 \<Rightarrow> a\<^sub>1)"
+definition "x - y = x \<sqinter> - (y :: finite_4)"
+instance
+  by standard
+    (subproofs
+      \<open>simp_all add: inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def 
+        split: finite_4.splits\<close>)
+end
+
+hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4
+
+datatype (plugins only: code "quickcheck" extraction) finite_5 =
+  a\<^sub>1 | a\<^sub>2 | a\<^sub>3 | a\<^sub>4 | a\<^sub>5
+
+notation (output) a\<^sub>1  ("a\<^sub>1")
+notation (output) a\<^sub>2  ("a\<^sub>2")
+notation (output) a\<^sub>3  ("a\<^sub>3")
+notation (output) a\<^sub>4  ("a\<^sub>4")
+notation (output) a\<^sub>5  ("a\<^sub>5")
+
+lemma UNIV_finite_5:
+  "UNIV = {a\<^sub>1, a\<^sub>2, a\<^sub>3, a\<^sub>4, a\<^sub>5}"
+  by (auto intro: finite_5.exhaust)
+
+instantiation finite_5 :: enum
+begin
+
+definition
+  "enum = [a\<^sub>1, a\<^sub>2, a\<^sub>3, a\<^sub>4, a\<^sub>5]"
+
+definition
+  "enum_all P \<longleftrightarrow> P a\<^sub>1 \<and> P a\<^sub>2 \<and> P a\<^sub>3 \<and> P a\<^sub>4 \<and> P a\<^sub>5"
+
+definition
+  "enum_ex P \<longleftrightarrow> P a\<^sub>1 \<or> P a\<^sub>2 \<or> P a\<^sub>3 \<or> P a\<^sub>4 \<or> P a\<^sub>5"
+
+instance proof
+qed (simp_all only: enum_finite_5_def enum_all_finite_5_def enum_ex_finite_5_def UNIV_finite_5, simp_all)
+
+end
+
+instantiation finite_5 :: finite_lattice
+begin
+
+text \<open>The non-distributive pentagon lattice $N_5$\<close>
+
+definition
+  "x < y \<longleftrightarrow> (case (x, y) of
+     (a\<^sub>1, a\<^sub>1) \<Rightarrow> False | (a\<^sub>1, _) \<Rightarrow> True
+   | (a\<^sub>2, a\<^sub>3) \<Rightarrow> True  | (a\<^sub>2, a\<^sub>5) \<Rightarrow> True
+   | (a\<^sub>3, a\<^sub>5) \<Rightarrow> True
+   | (a\<^sub>4, a\<^sub>5) \<Rightarrow> True  | _ \<Rightarrow> False)"
+
+definition
+  "x \<le> y \<longleftrightarrow> (case (x, y) of
+     (a\<^sub>1, _) \<Rightarrow> True
+   | (a\<^sub>2, a\<^sub>2) \<Rightarrow> True | (a\<^sub>2, a\<^sub>3) \<Rightarrow> True | (a\<^sub>2, a\<^sub>5) \<Rightarrow> True
+   | (a\<^sub>3, a\<^sub>3) \<Rightarrow> True | (a\<^sub>3, a\<^sub>5) \<Rightarrow> True
+   | (a\<^sub>4, a\<^sub>4) \<Rightarrow> True | (a\<^sub>4, a\<^sub>5) \<Rightarrow> True
+   | (a\<^sub>5, a\<^sub>5) \<Rightarrow> True | _ \<Rightarrow> False)"
+
+definition
+  "\<Sqinter>A = 
+  (if a\<^sub>1 \<in> A \<or> a\<^sub>4 \<in> A \<and> (a\<^sub>2 \<in> A \<or> a\<^sub>3 \<in> A) then a\<^sub>1
+   else if a\<^sub>2 \<in> A then a\<^sub>2
+   else if a\<^sub>3 \<in> A then a\<^sub>3
+   else if a\<^sub>4 \<in> A then a\<^sub>4
+   else a\<^sub>5)"
+definition
+  "\<Squnion>A = 
+  (if a\<^sub>5 \<in> A \<or> a\<^sub>4 \<in> A \<and> (a\<^sub>2 \<in> A \<or> a\<^sub>3 \<in> A) then a\<^sub>5
+   else if a\<^sub>3 \<in> A then a\<^sub>3
+   else if a\<^sub>2 \<in> A then a\<^sub>2
+   else if a\<^sub>4 \<in> A then a\<^sub>4
+   else a\<^sub>1)"
+definition [simp]: "bot = a\<^sub>1"
+definition [simp]: "top = a\<^sub>5"
+definition
+  "x \<sqinter> y = (case (x, y) of
+     (a\<^sub>1, _) \<Rightarrow> a\<^sub>1 | (_, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>4) \<Rightarrow> a\<^sub>1 | (a\<^sub>4, a\<^sub>2) \<Rightarrow> a\<^sub>1 | (a\<^sub>3, a\<^sub>4) \<Rightarrow> a\<^sub>1 | (a\<^sub>4, a\<^sub>3) \<Rightarrow> a\<^sub>1
+   | (a\<^sub>2, _) \<Rightarrow> a\<^sub>2 | (_, a\<^sub>2) \<Rightarrow> a\<^sub>2
+   | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
+   | (a\<^sub>4, _) \<Rightarrow> a\<^sub>4 | (_, a\<^sub>4) \<Rightarrow> a\<^sub>4
+   | _ \<Rightarrow> a\<^sub>5)"
+definition
+  "x \<squnion> y = (case (x, y) of
+     (a\<^sub>5, _) \<Rightarrow> a\<^sub>5 | (_, a\<^sub>5) \<Rightarrow> a\<^sub>5 | (a\<^sub>2, a\<^sub>4) \<Rightarrow> a\<^sub>5 | (a\<^sub>4, a\<^sub>2) \<Rightarrow> a\<^sub>5 | (a\<^sub>3, a\<^sub>4) \<Rightarrow> a\<^sub>5 | (a\<^sub>4, a\<^sub>3) \<Rightarrow> a\<^sub>5
+   | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
+   | (a\<^sub>2, _) \<Rightarrow> a\<^sub>2 | (_, a\<^sub>2) \<Rightarrow> a\<^sub>2
+   | (a\<^sub>4, _) \<Rightarrow> a\<^sub>4 | (_, a\<^sub>4) \<Rightarrow> a\<^sub>4
+   | _ \<Rightarrow> a\<^sub>1)"
+
+instance
+  by standard
+    (subproofs
+      \<open>auto simp add: less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def split: finite_5.splits if_split_asm\<close>)
+end
+
+
+instance  finite_5 :: complete_lattice ..
+
+
+hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4 a\<^sub>5
+
+
+subsection \<open>Closing up\<close>
+
+hide_type (open) finite_1 finite_2 finite_3 finite_4 finite_5
+hide_const (open) enum enum_all enum_ex all_n_lists ex_n_lists ntrancl
+
+end
diff -urN ./Euclidean_Division.thy /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy
--- ./Euclidean_Division.thy	2023-05-30 11:50:42.373685700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy	2023-05-31 15:33:10.919027800 +0900
@@ -2795,8 +2795,8 @@
   finally have *: \<open>\<bar>k\<bar> div \<bar>l\<bar> \<noteq> 0 \<longleftrightarrow> \<bar>l\<bar> \<le> \<bar>k\<bar>\<close> .
   show ?thesis
     using \<open>0 \<le> \<bar>k\<bar> div \<bar>l\<bar>\<close> False
-  by (auto simp add: div_eq_div_abs [of k l] div_eq_sgn_abs [of k l]
-    sgn_mult sgn_1_pos sgn_1_neg sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest: sgn_not_eq_imp)
+  by (auto simp add: div_eq_div_abs [of k l] (* redundant and looping! div_eq_sgn_abs [of k l] *)
+    sgn_mult sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest!: sgn_not_eq_imp)
 qed
 
 
diff -urN ./Factorial.thy /cygdrive/c/Isabelle2022/src/HOL/Factorial.thy
--- ./Factorial.thy	2023-05-30 11:49:53.645647300 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Factorial.thy	2023-05-31 14:26:38.861397700 +0900
@@ -28,7 +28,7 @@
   have "prod Suc {0..<n} = \<Prod>{1..n}"
     by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
   then have "prod Suc {0..<n} = prod ((-) (n + 1)) {1..n}"
-    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by presburger
+    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by auto
   then show ?thesis
     unfolding fact_prod_Suc by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
 qed
diff -urN ./Groups_List.thy /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy
--- ./Groups_List.thy	2023-05-30 11:49:53.253421400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy	2023-05-31 15:58:09.698128300 +0900
@@ -3,7 +3,7 @@
 section \<open>Sum and product over lists\<close>
 
 theory Groups_List
-imports List
+imports List Divides
 begin
 
 locale monoid_list = monoid
diff -urN ./List.thy /cygdrive/c/Isabelle2022/src/HOL/List.thy
--- ./List.thy	2023-05-30 11:50:42.721423600 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/List.thy	2023-05-31 14:26:38.879025000 +0900
@@ -5,7 +5,7 @@
 section \<open>The datatype of finite lists\<close>
 
 theory List
-imports Sledgehammer Lifting_Set
+imports Lifting_Set Set_Interval Numeral_Simprocs
 begin
 
 datatype (set: 'a) list =
@@ -962,13 +962,13 @@
 by (induct xs) auto
 
 lemma hd_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> hd (xs @ ys) = hd xs"
-by (simp add: hd_append split: list.split)
+by (simp add: hd_append)
 
 lemma tl_append: "tl (xs @ ys) = (case xs of [] \<Rightarrow> tl ys | z#zs \<Rightarrow> zs @ ys)"
-by (simp split: list.split)
+by (cases xs; simp)
 
 lemma tl_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> tl (xs @ ys) = tl xs @ ys"
-by (simp add: tl_append split: list.split)
+by (cases xs;simp add: tl_append)
 
 lemma tl_append_if: "tl (xs @ ys) = (if xs = [] then tl ys else tl xs @ ys)"
 by (simp)
@@ -1520,6 +1520,7 @@
 in K list_neq end
 \<close>
 
+
 subsubsection \<open>\<^const>\<open>filter\<close>\<close>
 
 lemma filter_append [simp]: "filter P (xs @ ys) = filter P xs @ filter P ys"
@@ -1591,7 +1592,7 @@
   proof (cases)
     assume "p x"
     hence eq: "?S' = insert 0 (Suc ` ?S)"
-      by(auto simp: image_def split:nat.split dest:gr0_implies_Suc)
+      by (auto simp: image_def dest:gr0_implies_Suc)
     have "length (filter p (x # xs)) = Suc(card ?S)"
       using Cons \<open>p x\<close> by simp
     also have "\<dots> = Suc(card(Suc ` ?S))" using fin
@@ -1854,7 +1855,6 @@
   qed
 qed
 
-
 subsubsection \<open>\<^const>\<open>list_update\<close>\<close>
 
 lemma length_list_update [simp]: "length(xs[i:=x]) = length xs"
@@ -2376,7 +2376,6 @@
 lemma nth_image: "l \<le> size xs \<Longrightarrow> nth xs ` {0..<l} = set(take l xs)"
   by (simp add: set_conv_nth) force
 
-
 subsubsection \<open>\<^const>\<open>takeWhile\<close> and \<^const>\<open>dropWhile\<close>\<close>
 
 lemma length_takeWhile_le: "length (takeWhile P xs) \<le> length xs"
@@ -2440,7 +2439,7 @@
   by (induct xs) (auto split: if_split_asm)
 
 lemma set_takeWhileD: "x \<in> set (takeWhile P xs) \<Longrightarrow> x \<in> set xs \<and> P x"
-  by (induct xs) (auto split: if_split_asm)
+  by (induct xs;auto) 
 
 lemma takeWhile_eq_all_conv[simp]:
   "(takeWhile P xs = xs) = (\<forall>x \<in> set xs. P x)"
@@ -2596,7 +2595,7 @@
 
 lemma zip_Cons1:
   "zip (x#xs) ys = (case ys of [] \<Rightarrow> [] | y#ys \<Rightarrow> (x,y)#zip xs ys)"
-  by(auto split:list.split)
+  by (cases xs; cases ys; simp)
 
 lemma length_zip [simp]:
   "length (zip xs ys) = min (length xs) (length ys)"
@@ -3072,7 +3071,6 @@
   then show "xs \<in> ?L" by induct auto
 qed
 
-
 subsubsection \<open>\<^const>\<open>fold\<close> with natural argument order\<close>
 
 lemma fold_simps [code]: \<comment> \<open>eta-expanded variant for generated code -- enables tail-recursion optimisation in Scala\<close>
@@ -3421,7 +3419,6 @@
     by simp
 qed
 
-
 subsubsection \<open>\<open>upto\<close>: interval-list on \<^typ>\<open>int\<close>\<close>
 
 function upto :: "int \<Rightarrow> int \<Rightarrow> int list" ("(1[_../_])") where
@@ -4159,7 +4156,7 @@
 
 lemma remdups_adj_append'': "xs \<noteq> []
   \<Longrightarrow> remdups_adj (xs @ ys) = remdups_adj xs @ remdups_adj (dropWhile (\<lambda>y. y = last xs) ys)"
-by (induction xs rule: remdups_adj.induct) (auto simp: remdups_adj_Cons')
+  by (induction xs rule: remdups_adj.induct) (auto simp: remdups_adj_Cons')
 
 
 subsection \<open>@{const distinct_adj}\<close>
@@ -4462,9 +4459,14 @@
   distinct (removeAll [] xs) \<and>
   (\<forall>ys. ys \<in> set xs \<longrightarrow> distinct ys) \<and>
   (\<forall>ys zs. ys \<in> set xs \<and> zs \<in> set xs \<and> ys \<noteq> zs \<longrightarrow> set ys \<inter> set zs = {})"
-apply (induct xs)
- apply(simp_all, safe, auto)
-by (metis Int_iff UN_I empty_iff equals0I set_empty)
+  apply (fold disjnt_def)
+proof(induct xs)
+  case Nil
+  then show ?case by simp
+next
+  case (Cons a xs)
+  show ?case by (auto simp: Cons Ball_def disjnt_def[symmetric] disjnt_sym)
+qed
 
 
 subsubsection \<open>\<^const>\<open>replicate\<close>\<close>
@@ -4946,7 +4948,6 @@
   with Cons show ?case by(simp add: nths_Cons cong:filter_cong)
 qed
 
-
 subsubsection \<open>\<^const>\<open>subseqs\<close> and \<^const>\<open>List.n_lists\<close>\<close>
 
 lemma length_subseqs: "length (subseqs xs) = 2 ^ length xs"
@@ -5050,7 +5051,16 @@
   "z # zs \<in> shuffles xs ys \<longleftrightarrow>
     (xs \<noteq> [] \<and> hd xs = z \<and> zs \<in> shuffles (tl xs) ys \<or>
      ys \<noteq> [] \<and> hd ys = z \<and> zs \<in> shuffles xs (tl ys))"
-  by (induct xs ys rule: shuffles.induct) auto
+proof(induct xs ys rule: shuffles.induct)
+  case (1 ys)
+  then show ?case by auto
+next
+  case (2 xs)
+  then show ?case by auto
+next
+  case (3 x xs y ys)
+  show ?case by (auto simp add: 3)
+qed
 
 lemma splice_in_shuffles [simp, intro]: "splice xs ys \<in> shuffles xs ys"
   by (induction xs ys rule: splice.induct) (simp_all add: Cons_in_shuffles_iff shuffles_commutes)
@@ -5197,20 +5207,29 @@
   (is "max _ ?foldB = Suc (max _ ?foldA)")
 proof (cases "(filter (\<lambda>ys. ys \<noteq> []) xss) = []")
   case True
-  hence "foldr (\<lambda>xs. max (length xs)) xss 0 = 0"
+  then show ?thesis 
   proof (induct xss)
-    case (Cons x xs)
-    then have "x = []" by (cases x) auto
-    with Cons show ?case by auto
-  qed simp
-  thus ?thesis using True by simp
+    case Nil
+    then show ?case by simp
+  next
+    case (Cons a xsss)
+    then show ?case 
+      by (cases a; simp add: filter_def)
+  qed
 next
   case False
 
   have foldA: "?foldA = foldr (\<lambda>x. max (length x)) (filter (\<lambda>ys. ys \<noteq> []) xss) 0 - 1"
-    by (induct xss) auto
+  proof(induct xss)
+    case Nil
+    then show ?case by simp
+  next
+    case IH: (Cons a xss)
+    then show ?case by (cases a; simp add: filter_def)
+  qed
+
   have foldB: "?foldB = foldr (\<lambda>x. max (length x)) (filter (\<lambda>ys. ys \<noteq> []) xss) 0"
-    by (induct xss) auto
+    by (induct xss; simp) 
 
   have "0 < ?foldB"
   proof -
@@ -6363,7 +6382,7 @@
 
 lemma sorted_list_of_set_lessThan_Suc [simp]:
   "sorted_list_of_set {..<Suc k} = sorted_list_of_set {..<k} @ [k]"
-  using le0 lessThan_atLeast0 sorted_list_of_set_range upt_Suc_append by presburger
+  using lessThan_atLeast0 by auto
 
 lemma sorted_list_of_set_atMost_Suc [simp]:
   "sorted_list_of_set {..Suc k} = sorted_list_of_set {..k} @ [Suc k]"
@@ -6835,7 +6854,7 @@
     by blast
   hence "((u@v)!i, (w@z)!i) \<in> r"
     unfolding nth_append using less_le_trans[OF \<open>i < length w\<close> assms(2)] \<open>(u!i,w!i) \<in> r\<close>
-    by presburger
+    by auto
   moreover have "i < min (length (u@v)) (length (w@z))"
     using assms(2) \<open>i < length w\<close> by simp
   moreover have "take i (u@v) = take i (w@z)"
diff -urN ./MacLaurin.thy /cygdrive/c/Isabelle2022/src/HOL/MacLaurin.thy
--- ./MacLaurin.thy	2023-05-30 11:50:42.798563100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/MacLaurin.thy	2023-05-31 14:26:38.879025000 +0900
@@ -22,7 +22,7 @@
 
 lemma eq_diff_eq': "x = y - z \<longleftrightarrow> y = x + z"
   for x y z :: real
-  by arith
+  by (auto elim: iffE)
 
 lemma fact_diff_Suc: "n < Suc m \<Longrightarrow> fact (Suc m - n) = (Suc m - n) * fact (m - n)"
   by (subst fact_reduce) auto
@@ -343,25 +343,37 @@
 lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
 
+lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "even m")
+  case t: True
+    then show ?thesis by (simp add: sin_coeff_def sin_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: sin_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_sin_expansion2:
   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
 proof (cases "n = 0 \<or> x = 0")
+  case True
+  then show ?thesis by auto
+next
   case False
-  let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
-  have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
+    let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
+    have tex: "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
       (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
-  proof (rule Maclaurin_all_lt)
-    show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
+    proof (rule Maclaurin_all_lt)
+      show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
            sin (x + 1/2 * real (Suc m) * pi)) (at x)"
-      by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
-  qed (use False in auto)
-  then show ?thesis
-    apply (rule ex_forward, simp)
-    apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
-qed auto
+        by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
+    qed (use False in auto)
+    from tex show ?thesis
+      apply (rule ex_forward, simp)
+      apply (rule sum.cong[OF refl])
+      by (simp add: sin_coeff_lemma)
+  qed
 
 lemma Maclaurin_sin_expansion:
   "\<exists>t. sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -385,8 +397,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 lemma Maclaurin_sin_expansion4:
@@ -406,8 +417,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 
@@ -419,6 +429,16 @@
 lemma cos_expansion_lemma: "cos (x + real (Suc m) * pi / 2) = - sin (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add distrib_right add_divide_distrib)
 
+lemma cos_coeff_lemma: "cos_coeff m * x ^ m  = cos (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "odd m")
+  case t: True
+    then show ?thesis by (simp add: cos_coeff_def cos_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: cos_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_cos_expansion:
   "\<exists>t::real. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     cos x = (\<Sum>m<n. cos_coeff m * x ^ m) + (cos(t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -436,8 +456,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE simp del: of_nat_Suc)
-    done
+    by (simp add: cos_coeff_lemma)
 qed auto
 
 lemma Maclaurin_cos_expansion2:
@@ -456,8 +475,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 lemma Maclaurin_minus_cos_expansion:
@@ -476,8 +494,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 
@@ -537,7 +554,7 @@
   shows "\<exists>t::real. c < t \<and> t < b \<and>
     f b = (\<Sum>m<n. (diff m c / fact m) * (b - c)^m) + (diff n t / fact n) * (b - c)^n"
 proof -
-  from INTERV have "0 < b - c" by arith
+  from INTERV have "0 < b - c" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -573,7 +590,7 @@
   shows "\<exists>t. a < t \<and> t < c \<and>
     f a = (\<Sum>m<n. (diff m c / fact m) * (a - c)^m) + (diff n t / fact n) * (a - c)^n"
 proof -
-  from INTERV have "a-c < 0" by arith
+  from INTERV have "a-c < 0" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -627,9 +644,9 @@
   moreover have "\<forall>m t. m < n \<and> a \<le> t \<and> t \<le> x \<longrightarrow> DERIV (diff m) t :> diff (Suc m) t"
     using DERIV and INTERV by fastforce
   moreover from INTERV have "a \<le> c"
-    by arith
+    by simp
   moreover from False and INTERV have "c < x"
-    by arith
+    by simp
   ultimately have "\<exists>t>c. t < x \<and> f x =
     (\<Sum>m<n. diff m c / (fact m) * (x - c) ^ m) + diff n t / (fact n) * (x - c) ^ n"
     by (rule Taylor_up)
diff -urN ./Main.thy /cygdrive/c/Isabelle2022/src/HOL/Main.thy
--- ./Main.thy	2023-05-30 11:49:55.729754800 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Main.thy	2023-05-31 14:26:38.879025000 +0900
@@ -8,10 +8,10 @@
 theory Main
   imports
     Predicate_Compile
-    Quickcheck_Narrowing
+    (*Quickcheck_Narrowing*)
     Mirabelle
     Extraction
-    Nunchaku
+    (*Nunchaku*)
     BNF_Greatest_Fixpoint
     Filter
     Conditionally_Complete_Lattices
diff -urN ./Nitpick.thy /cygdrive/c/Isabelle2022/src/HOL/Nitpick.thy
--- ./Nitpick.thy	2023-05-30 11:49:54.739036200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Nitpick.thy	2023-05-31 14:26:38.879025000 +0900
@@ -8,7 +8,7 @@
 section \<open>Nitpick: Yet Another Counterexample Generator for Isabelle/HOL\<close>
 
 theory Nitpick
-imports Record GCD
+imports Record GCD Sledgehammer
 keywords
   "nitpick" :: diag and
   "nitpick_params" :: thy_decl
diff -urN ./Predicate_Compile.thy /cygdrive/c/Isabelle2022/src/HOL/Predicate_Compile.thy
--- ./Predicate_Compile.thy	2023-05-30 11:49:55.926685800 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Predicate_Compile.thy	2023-05-31 14:26:38.879025000 +0900
@@ -1,11 +1,7 @@
-(*  Title:      HOL/Predicate_Compile.thy
-    Author:     Stefan Berghofer, Lukas Bulwahn, Florian Haftmann, TU Muenchen
-*)
-
 section \<open>A compiler for predicates defined by introduction rules\<close>
 
 theory Predicate_Compile
-imports Random_Sequence Quickcheck_Exhaustive
+imports Random_Sequence Random_Prep (*Quickcheck_Exhaustive*)
 keywords
   "code_pred" :: thy_goal and
   "values" :: diag
diff -urN ./Quickcheck_Exhaustive.thy /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Exhaustive.thy
--- ./Quickcheck_Exhaustive.thy	2023-05-30 11:49:56.585222900 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Exhaustive.thy	2023-05-31 14:26:38.894298600 +0900
@@ -15,14 +15,14 @@
   where [code_unfold]: "x orelse y = (case x of Some x' \<Rightarrow> Some x' | None \<Rightarrow> y)"
 
 
-subsection \<open>Exhaustive generator type classes\<close>
+(*subsection \<open>Exhaustive generator type classes\<close>
 
 class exhaustive = term_of +
   fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
 
 class full_exhaustive = term_of +
   fixes full_exhaustive ::
-    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"*)
 
 instantiation natural :: full_exhaustive
 begin
@@ -226,7 +226,7 @@
      else
       f valterm_emptyset orelse
       full_exhaustive_set
-        (\<lambda>A. f A orelse Quickcheck_Exhaustive.full_exhaustive
+        (\<lambda>A. f A orelse Random_Prep.full_exhaustive
           (\<lambda>x. if fst x \<in> fst A then None else f (valtermify_insert x A)) (i - 1)) (i - 1))"
 
 instance ..
@@ -649,7 +649,7 @@
     (Quickcheck) "(((_); NONE) handle Exhaustive'_Generators.Counterexample ts \<Rightarrow> SOME ts)"
 
 
-subsection \<open>Continuation passing style functions as plus monad\<close>
+(*subsection \<open>Continuation passing style functions as plus monad\<close>
 
 type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
 
@@ -731,7 +731,7 @@
 
 definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
   where "pos_bound_cps_not n =
-    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"*)
 
 
 subsection \<open>Defining generators for any first-order data type\<close>
@@ -766,13 +766,13 @@
   check_all enum_term_of
   orelse unknown mk_map_term check_all_n_lists check_all_subsets
 
-hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+(*hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
 
 hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
   pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
   pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
   neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
   neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
-  Unknown Known Unknown_value Value No_value
+  Unknown Known Unknown_value Value No_value*)
 
 end
diff -urN ./Quickcheck_Random.thy /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Random.thy
--- ./Quickcheck_Random.thy	2023-05-30 11:49:56.406913000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Random.thy	2023-05-31 14:26:38.896504500 +0900
@@ -5,7 +5,7 @@
 section \<open>A simple counterexample generator performing random testing\<close>
 
 theory Quickcheck_Random
-imports Random Code_Evaluation Enum
+  imports Random_Prep
 begin
 
 setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>
@@ -19,7 +19,7 @@
 
 code_reserved Quickcheck Match
 
-subsection \<open>The \<open>random\<close> class\<close>
+(*subsection \<open>The \<open>random\<close> class\<close>
 
 class random = typerep +
   fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
@@ -182,7 +182,7 @@
 
 instance ..
 
-end
+end*)
 
 text \<open>Towards type copies and datatypes\<close>
 
@@ -213,7 +213,7 @@
 
 end
 
-instantiation set :: (random) random
+instantiation set :: (Random_Prep.random) Random_Prep.random
 begin
 
 context
@@ -227,12 +227,13 @@
     collapse (Random.select_weight
       [(1, Pair valterm_emptyset),
        (Code_Numeral.Suc i,
-        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+        Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
 
 lemma [code]:
   "random_aux_set i j =
     collapse (Random.select_weight [(1, Pair valterm_emptyset),
-      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+      (i, Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
 proof (induct i rule: natural.induct)
   case zero
   show ?case by (subst select_weight_drop_zero [symmetric])
@@ -259,6 +260,10 @@
 
 subsection \<open>Deriving random generators for datatypes\<close>
 
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
 ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
 ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
 
@@ -266,15 +271,15 @@
 subsection \<open>Code setup\<close>
 
 code_printing
-  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  constant Random_Prep.random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
   \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
   for this reason we use a distinguished target \<open>Quickcheck\<close>
   not spoiling the regular trusted code generation\<close>
 
 code_reserved Quickcheck Random_Generators
 
-hide_const (open) catch_match random collapse beyond random_fun_aux random_fun_lift
+hide_const (open) catch_match random collapse beyond (*random_fun_aux random_fun_lift*)
 
-hide_fact (open) collapse_def beyond_def random_fun_lift_def
+hide_fact (open) collapse_def beyond_def (*random_fun_lift_def*)
 
 end
diff -urN ./R /cygdrive/c/Isabelle2022/src/HOL/R
--- ./R	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/R	2023-05-30 16:51:07.314648500 +0900
@@ -0,0 +1,112 @@
+--- Enum.thy	2022-10-25 03:37:32.000000000 +0900
++++ Enum.thy	2023-05-30 15:37:49.000000000 +0900
+@@ -985,21 +1047,56 @@
+    | _ \<Rightarrow> a\<^sub>3)"
+ definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>1 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2)"
+ definition "x - y = x + (- y :: finite_3)"
++definition [simp]: "1 = a\<^sub>2"
+ definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | (a\<^sub>3, a\<^sub>3) \<Rightarrow> a\<^sub>2 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>3 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>3 | _ \<Rightarrow> a\<^sub>1)"
+ definition "inverse = (\<lambda>x :: finite_3. x)" 
+ definition "x div y = x * inverse (y :: finite_3)"
++
++
++instance
++proof(intro_classes)
++  fix a b c :: finite_3
++  show "a + b + c = a + (b + c)" 
++    by (cases a; cases b; cases c; simp add: plus_finite_3_def)
++  show "0 + a = a" by (cases a; simp add: plus_finite_3_def)
++  show "-a + a = 0" by (cases a; simp add: plus_finite_3_def uminus_finite_3_def)
++  show "a - b = a + -b" by (simp add: minus_finite_3_def)
++  show "a * b * c = a * (b * c)" by (cases a; cases b; cases c; simp add: times_finite_3_def)
++  show "a * b = b * a" by (cases a; cases b; simp add: times_finite_3_def)
++  show "1 * a = a" by (cases a; simp add: times_finite_3_def)
++  show "a + b = b + a" by (cases a; cases b; simp add: plus_finite_3_def)
++  show "(a + b) * c = a * c + b * c" 
++    by (cases a; cases b; cases c; simp add: plus_finite_3_def times_finite_3_def)
++  show "(0::finite_3) \<noteq> 1" by simp
++  show "a \<noteq> 0 \<Longrightarrow> inverse a * a = 1" 
++    by (cases a; simp add: times_finite_3_def inverse_finite_3_def)
++  show "a div b = a * inverse b" by (simp add: divide_finite_3_def)
++  show "inverse (0::finite_3) = 0" by (simp add: inverse_finite_3_def)
++qed
++  
++end
++
++instantiation finite_3 :: "{idom_abs_sgn, idom_modulo}" begin
+ definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
+ definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
+ definition "sgn = (\<lambda>x :: finite_3. x)"
++
+ instance
+-  by standard
+-    (subproofs
+-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+-        times_finite_3_def
+-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
+-        abs_finite_3_def sgn_finite_3_def
+-        less_finite_3_def
+-        split: finite_3.splits\<close>)
++proof(intro_classes)
++  fix a b :: finite_3
++  show "sgn a * \<bar>a\<bar> = a" by (cases a; simp add: abs_finite_3_def sgn_finite_3_def)
++  show "sgn (sgn a) = sgn a" by (simp add: sgn_finite_3_def)
++  show "\<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>" by (cases a; simp add: abs_finite_3_def)
++  show "\<bar>(0::finite_3)\<bar> = 0" by (simp add: abs_finite_3_def)
++  show "sgn (0::finite_3) = 0" by (simp add: sgn_finite_3_def)
++  show "sgn (1::finite_3) = 1" by (simp add: sgn_finite_3_def)
++  show "sgn (- (1::finite_3)) = - 1" by (simp add: sgn_finite_3_def)
++  show "sgn (a * b) = sgn a * sgn b" by (simp add: sgn_finite_3_def)
++  show "a / b * b + a mod b = a" 
++    by (cases a; cases b; 
++        simp add: plus_finite_3_def times_finite_3_def modulo_finite_3_def 
++          divide_finite_3_def inverse_finite_3_def)
++qed
+ end
+ 
+ lemma two_finite_3 [simp]:
+--- MacLaurin.thy	2022-10-25 03:37:32.000000000 +0900
++++ MacLaurin.thy	2023-05-30 15:37:49.000000000 +0900
+@@ -343,25 +343,37 @@
+ lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
+   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
+ 
++lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
++proof(cases "even m")
++  case t: True
++    then show ?thesis by (simp add: sin_coeff_def sin_zero_iff)
++ next
++  case False
++    then show ?thesis using False 
++      by (auto simp add: sin_coeff_def elim: oddE simp del: of_nat_Suc) 
++qed
++
+ lemma Maclaurin_sin_expansion2:
+   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
+     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
+ proof (cases "n = 0 \<or> x = 0")
++  case True
++  then show ?thesis by auto
++next
+   case False
+   let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
+-  have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
++    have tex: "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
+       (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
+   proof (rule Maclaurin_all_lt)
+     show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
+            sin (x + 1/2 * real (Suc m) * pi)) (at x)"
+       by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
+   qed (use False in auto)
+-  then show ?thesis
++    from tex show ?thesis
+     apply (rule ex_forward, simp)
+     apply (rule sum.cong[OF refl])
+-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
+-    done
+-qed auto
++      by (simp add: sin_coeff_lemma)
++  qed
+ 
+ lemma Maclaurin_sin_expansion:
+   "\<exists>t. sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
diff -urN ./Random_Pred.thy /cygdrive/c/Isabelle2022/src/HOL/Random_Pred.thy
--- ./Random_Pred.thy	2023-05-30 11:49:57.822544100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Random_Pred.thy	2023-05-31 14:26:38.898682900 +0900
@@ -4,13 +4,13 @@
 section \<open>The Random-Predicate Monad\<close>
 
 theory Random_Pred
-imports Quickcheck_Random
+imports Random_Prep
 begin
 
 fun iter' :: "'a itself \<Rightarrow> natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
 where
   "iter' T nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter' T (nrandom - 1) sz seed')))"
 
 definition iter :: "natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
@@ -19,7 +19,7 @@
 
 lemma [code]:
   "iter nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter (nrandom - 1) sz seed')))"
    unfolding iter_def iter'.simps [of _ nrandom] ..
 
diff -urN ./Random_Prep.thy /cygdrive/c/Isabelle2022/src/HOL/Random_Prep.thy
--- ./Random_Prep.thy	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Random_Prep.thy	2023-05-31 14:31:21.495846600 +0900
@@ -0,0 +1,386 @@
+(*  Title:      HOL/Quickcheck_Random.thy
+    Author:     Florian Haftmann & Lukas Bulwahn, TU Muenchen
+*)
+
+section \<open>A simple counterexample generator performing random testing\<close>
+
+theory Random_Prep
+imports Random Code_Evaluation Enum
+begin
+
+(*setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>*)
+
+(*subsection \<open>Catching Match exceptions\<close>
+
+axiomatization catch_match :: "'a => 'a => 'a"
+
+code_printing
+  constant catch_match \<rightharpoonup> (Quickcheck) "((_) handle Match => _)"
+
+code_reserved Quickcheck Match*)
+
+subsection \<open>The \<open>random\<close> class\<close>
+
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
+subsection \<open>Fundamental and numeric types\<close>
+
+instantiation bool :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range 2 \<circ>\<rightarrow>
+    (\<lambda>k. Pair (if k = 0 then Code_Evaluation.valtermify False else Code_Evaluation.valtermify True))"
+
+instance ..
+
+end
+
+end
+
+instantiation itself :: (typerep) random
+begin
+
+definition
+  random_itself :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a itself \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where "random_itself _ = Pair (Code_Evaluation.valtermify TYPE('a))"
+
+instance ..
+
+end
+
+instantiation char :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random _ = Random.select (Enum.enum :: char list) \<circ>\<rightarrow> (\<lambda>c. Pair (c, \<lambda>u. Code_Evaluation.term_of c))"
+
+instance ..
+
+end
+
+end
+
+instantiation String.literal :: random
+begin
+
+definition
+  "random _ = Pair (STR '''', \<lambda>u. Code_Evaluation.term_of (STR ''''))"
+
+instance ..
+
+end
+
+instantiation nat :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_nat :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (nat \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_nat i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let n = nat_of_natural k
+     in (n, \<lambda>_. Code_Evaluation.term_of n)))"
+
+instance ..
+
+end
+
+end
+
+instantiation int :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then int (nat_of_natural (k - i)) else - (int (nat_of_natural (i - k))))
+     in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+instantiation natural :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_natural :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (natural \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_natural i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>n. Pair (n, \<lambda>_. Code_Evaluation.term_of n))"
+
+instance ..
+
+end
+
+end
+
+instantiation integer :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_integer :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (integer \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_integer i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then integer_of_natural (k - i) else - (integer_of_natural (i - k)))
+      in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+
+subsection \<open>Complex generators\<close>
+
+text \<open>Towards \<^typ>\<open>'a \<Rightarrow> 'b\<close>\<close>
+
+axiomatization random_fun_aux :: "typerep \<Rightarrow> typerep \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a \<Rightarrow> term)
+  \<Rightarrow> (Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> (Random.seed \<Rightarrow> Random.seed \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+definition random_fun_lift :: "(Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a::term_of \<Rightarrow> 'b::typerep) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where
+  "random_fun_lift f =
+    random_fun_aux TYPEREP('a) TYPEREP('b) (=) Code_Evaluation.term_of f Random.split_seed"
+
+instantiation "fun" :: ("{equal, term_of}", random) random
+begin
+
+definition
+  random_fun :: "natural \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+  where "random i = random_fun_lift (random i)"
+
+instance ..
+
+end
+
+(*text \<open>Towards type copies and datatypes\<close>
+
+context
+  includes state_combinator_syntax
+begin
+
+definition collapse :: "('a \<Rightarrow> ('a \<Rightarrow> 'b \<times> 'a) \<times> 'a) \<Rightarrow> 'a \<Rightarrow> 'b \<times> 'a"
+  where "collapse f = (f \<circ>\<rightarrow> id)"
+
+end
+
+definition beyond :: "natural \<Rightarrow> natural \<Rightarrow> natural"
+  where "beyond k l = (if l > k then l else 0)"
+
+lemma beyond_zero: "beyond k 0 = 0"
+  by (simp add: beyond_def)
+
+context
+  includes term_syntax
+begin
+
+definition [code_unfold]:
+  "valterm_emptyset = Code_Evaluation.valtermify ({} :: ('a :: typerep) set)"
+
+definition [code_unfold]:
+  "valtermify_insert x s = Code_Evaluation.valtermify insert {\<cdot>} (x :: ('a :: typerep * _)) {\<cdot>} s"
+
+end
+
+instantiation set :: (random) random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+
+fun random_aux_set
+where
+  "random_aux_set 0 j = collapse (Random.select_weight [(1, Pair valterm_emptyset)])"
+| "random_aux_set (Code_Numeral.Suc i) j =
+    collapse (Random.select_weight
+      [(1, Pair valterm_emptyset),
+       (Code_Numeral.Suc i,
+        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
+
+lemma [code]:
+  "random_aux_set i j =
+    collapse (Random.select_weight [(1, Pair valterm_emptyset),
+      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+proof (induct i rule: natural.induct)
+  case zero
+  show ?case by (subst select_weight_drop_zero [symmetric])
+    (simp add: random_aux_set.simps [simplified] less_natural_def)
+next
+  case (Suc i)
+  show ?case by (simp only: random_aux_set.simps(2) [of "i"] Suc_natural_minus_one)
+qed
+
+definition "random_set i = random_aux_set i i"
+
+instance ..
+
+end
+
+end
+
+lemma random_aux_rec:
+  fixes random_aux :: "natural \<Rightarrow> 'a"
+  assumes "random_aux 0 = rhs 0"
+    and "\<And>k. random_aux (Code_Numeral.Suc k) = rhs (Code_Numeral.Suc k)"
+  shows "random_aux k = rhs k"
+  using assms by (rule natural.induct)*)
+
+(*subsection \<open>Deriving random generators for datatypes\<close>
+
+ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
+ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
+
+
+subsection \<open>Code setup\<close>
+
+code_printing
+  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
+  for this reason we use a distinguished target \<open>Quickcheck\<close>
+  not spoiling the regular trusted code generation\<close>
+
+code_reserved Quickcheck Random_Generators*)
+
+hide_const (open) (*catch_match*) random (*collapse beyond*) random_fun_aux random_fun_lift
+
+hide_fact (open) (*collapse_def beyond_def*) random_fun_lift_def
+
+
+
+subsection \<open>Continuation passing style functions as plus monad\<close>
+
+type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
+
+definition cps_empty :: "'a cps"
+  where "cps_empty = (\<lambda>cont. None)"
+
+definition cps_single :: "'a \<Rightarrow> 'a cps"
+  where "cps_single v = (\<lambda>cont. cont v)"
+
+definition cps_bind :: "'a cps \<Rightarrow> ('a \<Rightarrow> 'b cps) \<Rightarrow> 'b cps"
+  where "cps_bind m f = (\<lambda>cont. m (\<lambda>a. (f a) cont))"
+
+definition cps_plus :: "'a cps \<Rightarrow> 'a cps \<Rightarrow> 'a cps"
+  where "cps_plus a b = (\<lambda>c. case a c of None \<Rightarrow> b c | Some x \<Rightarrow> Some x)"
+
+definition cps_if :: "bool \<Rightarrow> unit cps"
+  where "cps_if b = (if b then cps_single () else cps_empty)"
+
+definition cps_not :: "unit cps \<Rightarrow> unit cps"
+  where "cps_not n = (\<lambda>c. case n (\<lambda>u. Some []) of None \<Rightarrow> c () | Some _ \<Rightarrow> None)"
+
+type_synonym 'a pos_bound_cps =
+  "('a \<Rightarrow> (bool * term list) option) \<Rightarrow> natural \<Rightarrow> (bool * term list) option"
+
+definition pos_bound_cps_empty :: "'a pos_bound_cps"
+  where "pos_bound_cps_empty = (\<lambda>cont i. None)"
+
+definition pos_bound_cps_single :: "'a \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_single v = (\<lambda>cont i. cont v)"
+
+definition pos_bound_cps_bind :: "'a pos_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b pos_bound_cps) \<Rightarrow> 'b pos_bound_cps"
+  where "pos_bound_cps_bind m f = (\<lambda>cont i. if i = 0 then None else (m (\<lambda>a. (f a) cont i) (i - 1)))"
+
+definition pos_bound_cps_plus :: "'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_plus a b = (\<lambda>c i. case a c i of None \<Rightarrow> b c i | Some x \<Rightarrow> Some x)"
+
+definition pos_bound_cps_if :: "bool \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_if b = (if b then pos_bound_cps_single () else pos_bound_cps_empty)"
+
+datatype (plugins only: code extraction) (dead 'a) unknown =
+  Unknown | Known 'a
+
+datatype (plugins only: code extraction) (dead 'a) three_valued =
+  Unknown_value | Value 'a | No_value
+
+type_synonym 'a neg_bound_cps =
+  "('a unknown \<Rightarrow> term list three_valued) \<Rightarrow> natural \<Rightarrow> term list three_valued"
+
+definition neg_bound_cps_empty :: "'a neg_bound_cps"
+  where "neg_bound_cps_empty = (\<lambda>cont i. No_value)"
+
+definition neg_bound_cps_single :: "'a \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_single v = (\<lambda>cont i. cont (Known v))"
+
+definition neg_bound_cps_bind :: "'a neg_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b neg_bound_cps) \<Rightarrow> 'b neg_bound_cps"
+  where "neg_bound_cps_bind m f =
+    (\<lambda>cont i.
+      if i = 0 then cont Unknown
+      else m (\<lambda>a. case a of Unknown \<Rightarrow> cont Unknown | Known a' \<Rightarrow> f a' cont i) (i - 1))"
+
+definition neg_bound_cps_plus :: "'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_plus a b =
+    (\<lambda>c i.
+      case a c i of
+        No_value \<Rightarrow> b c i
+      | Value x \<Rightarrow> Value x
+      | Unknown_value \<Rightarrow>
+          (case b c i of
+            No_value \<Rightarrow> Unknown_value
+          | Value x \<Rightarrow> Value x
+          | Unknown_value \<Rightarrow> Unknown_value))"
+
+definition neg_bound_cps_if :: "bool \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_if b = (if b then neg_bound_cps_single () else neg_bound_cps_empty)"
+
+definition neg_bound_cps_not :: "unit pos_bound_cps \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Some (True, [])) i of None \<Rightarrow> c (Known ()) | Some _ \<Rightarrow> No_value)"
+
+definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+
+hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+
+hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
+  pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
+  pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
+  neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
+  neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
+  Unknown Known Unknown_value Value No_value
+
+class exhaustive = term_of +
+  fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+class full_exhaustive = term_of +
+  fixes full_exhaustive ::
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+
+
+end
diff -urN ./Rat.thy /cygdrive/c/Isabelle2022/src/HOL/Rat.thy
--- ./Rat.thy	2023-05-30 11:50:42.466861600 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Rat.thy	2023-05-31 14:26:38.902063300 +0900
@@ -1010,7 +1010,7 @@
   by (cases p) (simp add: quotient_of_Fract of_rat_rat)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1129,7 +1129,7 @@
   inverse_rat_inst.inverse_rat
   one_rat_inst.one_rat ord_rat_inst.less_rat
   ord_rat_inst.less_eq_rat plus_rat_inst.plus_rat times_rat_inst.times_rat
-  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat
+  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat*)
 
 
 subsection \<open>Float syntax\<close>
diff -urN ./Real.thy /cygdrive/c/Isabelle2022/src/HOL/Real.thy
--- ./Real.thy	2023-05-30 11:50:42.529129200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Real.thy	2023-05-31 14:26:38.904474700 +0900
@@ -1655,7 +1655,7 @@
       of_int_floor_le of_rat_of_int_eq real_less_eq_code)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1731,7 +1731,7 @@
 lemmas [nitpick_unfold] = inverse_real_inst.inverse_real one_real_inst.one_real
   ord_real_inst.less_real ord_real_inst.less_eq_real plus_real_inst.plus_real
   times_real_inst.times_real uminus_real_inst.uminus_real
-  zero_real_inst.zero_real
+  zero_real_inst.zero_real*)
 
 
 subsection \<open>Setup for SMT\<close>
diff -urN ./String.thy /cygdrive/c/Isabelle2022/src/HOL/String.thy
--- ./String.thy	2023-05-30 11:50:00.046418000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/String.thy	2023-05-31 17:18:55.605821500 +0900
@@ -40,11 +40,21 @@
 
 lemma (in comm_semiring_1) of_nat_of_char:
   \<open>of_nat (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(* this is more explicit:
+ by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_nat_add of_nat_mult of_nat_of_bool of_nat_numeral of_nat_0)
+*)
 
 lemma (in comm_ring_1) of_int_of_char:
   \<open>of_int (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(*
+  by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_int_add of_int_mult of_int_of_bool of_int_numeral of_int_0)
+*)
 
 lemma nat_of_char [simp]:
   \<open>nat (of_char c) = of_char c\<close>
@@ -698,9 +708,9 @@
 
 lemma [code]:
   \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
-    [foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
+    [foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
 proof -
-  have \<open>foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
+  have \<open>foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
     by simp
   moreover have \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
     [of_char (Char b0 b1 b2 b3 b4 b5 b6 False)] + s\<close>
diff -urN ./Tools/Predicate_Compile/predicate_compile_compilations.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML
--- ./Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-30 11:49:58.264752400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-31 14:26:38.908985500 +0900
@@ -76,21 +76,21 @@
       (Type ("fun", [Type ("fun", [T, \<^typ>\<open>term list option\<close>]), \<^typ>\<open>term list option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
@@ -98,7 +98,7 @@
 fun mk_not t =
   let
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_not\<close>, T --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.cps_not\<close>, T --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -127,33 +127,33 @@
   \<^typ>\<open>natural => (bool * term list) option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], [])
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.pos_bound_cps_plus\<close>
 
 fun mk_if cond =
-  Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_if\<close>,
+  Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_if\<close>,
     HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
 
 fun mk_not t =
   let
-    val nT = \<^typ>\<open>(unit Quickcheck_Exhaustive.unknown =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued) => natural =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+    val nT = \<^typ>\<open>(unit Random_Prep.unknown =>
+      Code_Evaluation.term list Random_Prep.three_valued) => natural =>
+      Code_Evaluation.term list Random_Prep.three_valued\<close>
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_not\<close>, nT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_not\<close>, nT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -176,31 +176,31 @@
 struct
 
 fun mk_monadT T =
-  (Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T])
-    --> \<^typ>\<open>Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>)
-    --> \<^typ>\<open>natural => Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+  (Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T])
+    --> \<^typ>\<open>Code_Evaluation.term list Random_Prep.three_valued\<close>)
+    --> \<^typ>\<open>natural => Code_Evaluation.term list Random_Prep.three_valued\<close>
 
 fun dest_monadT
-    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T]),
-      \<^typ>\<open>term list Quickcheck_Exhaustive.three_valued\<close>]),
-      \<^typ>\<open>natural => term list Quickcheck_Exhaustive.three_valued\<close>])) = T
+    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T]),
+      \<^typ>\<open>term list Random_Prep.three_valued\<close>]),
+      \<^typ>\<open>natural => term list Random_Prep.three_valued\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.neg_bound_cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented"
@@ -210,7 +210,7 @@
     val T = mk_monadT HOLogic.unitT
     val pT = \<^typ>\<open>(unit => (bool * Code_Evaluation.term list) option)\<close>
       --> \<^typ>\<open>natural => (bool * Code_Evaluation.term list) option\<close>
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_not\<close>, pT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_not\<close>, pT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
diff -urN ./Tools/Predicate_Compile/predicate_compile_compilations.ML.rej /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML.rej
--- ./Tools/Predicate_Compile/predicate_compile_compilations.ML.rej	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML.rej	2023-05-30 16:53:56.944734800 +0900
@@ -0,0 +1,133 @@
+--- /Applications/Isabelle2022.app/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-30 15:37:49.000000000 +0900
++++ ./Tools/Predicate_Compile/predicate_compile_compilations.ML	2022-10-25 03:37:32.000000000 +0900
+@@ -76,21 +76,21 @@
+       (Type ("fun", [Type ("fun", [T, \<^typ>\<open>term list option\<close>]), \<^typ>\<open>term list option\<close>])) = T
+   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
+ 
+-fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.cps_empty\<close>, mk_monadT T)
++fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_empty\<close>, mk_monadT T)
+ 
+ fun mk_single t =
+   let val T = fastype_of t
+-  in Const(\<^const_name>\<open>Random_Prep.cps_single\<close>, T --> mk_monadT T) $ t end
++  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.cps_single\<close>, T --> mk_monadT T) $ t end
+ 
+ fun mk_bind (x, f) =
+   let val T as Type ("fun", [_, U]) = fastype_of f
+   in
+-    Const (\<^const_name>\<open>Random_Prep.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
++    Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+   end
+ 
+-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.cps_plus\<close>
++val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.cps_plus\<close>
+ 
+-fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.cps_if\<close>,
++fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_if\<close>,
+   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
+ 
+ fun mk_iterate_upto _ _ = error "not implemented yet"
+@@ -98,7 +98,7 @@
+ fun mk_not t =
+   let
+     val T = mk_monadT HOLogic.unitT
+-  in Const (\<^const_name>\<open>Random_Prep.cps_not\<close>, T --> T) $ t end
++  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_not\<close>, T --> T) $ t end
+ 
+ fun mk_Enum _ = error "not implemented"
+ 
+@@ -127,33 +127,33 @@
+   \<^typ>\<open>natural => (bool * term list) option\<close>])) = T
+   | dest_monadT T = raise TYPE ("dest_monadT", [T], [])
+ 
+-fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_empty\<close>, mk_monadT T)
++fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_empty\<close>, mk_monadT T)
+ 
+ fun mk_single t =
+   let val T = fastype_of t
+-  in Const(\<^const_name>\<open>Random_Prep.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
++  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+ 
+ fun mk_bind (x, f) =
+   let val T as Type ("fun", [_, U]) = fastype_of f
+   in
+-    Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
++    Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+   end;
+ 
+-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.pos_bound_cps_plus\<close>
++val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_plus\<close>
+ 
+ fun mk_if cond =
+-  Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_if\<close>,
++  Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_if\<close>,
+     HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
+ 
+ fun mk_iterate_upto _ _ = error "not implemented yet"
+ 
+ fun mk_not t =
+   let
+-    val nT = \<^typ>\<open>(unit Random_Prep.unknown =>
+-      Code_Evaluation.term list Random_Prep.three_valued) => natural =>
+-      Code_Evaluation.term list Random_Prep.three_valued\<close>
++    val nT = \<^typ>\<open>(unit Quickcheck_Exhaustive.unknown =>
++      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued) => natural =>
++      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+     val T = mk_monadT HOLogic.unitT
+-  in Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_not\<close>, nT --> T) $ t end
++  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_not\<close>, nT --> T) $ t end
+ 
+ fun mk_Enum _ = error "not implemented"
+ 
+@@ -176,31 +176,31 @@
+ struct
+ 
+ fun mk_monadT T =
+-  (Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T])
+-    --> \<^typ>\<open>Code_Evaluation.term list Random_Prep.three_valued\<close>)
+-    --> \<^typ>\<open>natural => Code_Evaluation.term list Random_Prep.three_valued\<close>
++  (Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T])
++    --> \<^typ>\<open>Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>)
++    --> \<^typ>\<open>natural => Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+ 
+ fun dest_monadT
+-    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T]),
+-      \<^typ>\<open>term list Random_Prep.three_valued\<close>]),
+-      \<^typ>\<open>natural => term list Random_Prep.three_valued\<close>])) = T
++    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T]),
++      \<^typ>\<open>term list Quickcheck_Exhaustive.three_valued\<close>]),
++      \<^typ>\<open>natural => term list Quickcheck_Exhaustive.three_valued\<close>])) = T
+   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
+ 
+-fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_empty\<close>, mk_monadT T)
++fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_empty\<close>, mk_monadT T)
+ 
+ fun mk_single t =
+   let val T = fastype_of t
+-  in Const(\<^const_name>\<open>Random_Prep.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
++  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+ 
+ fun mk_bind (x, f) =
+   let val T as Type ("fun", [_, U]) = fastype_of f
+   in
+-    Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
++    Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+   end;
+ 
+-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.neg_bound_cps_plus\<close>
++val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_plus\<close>
+ 
+-fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_if\<close>,
++fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_if\<close>,
+   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
+ 
+ fun mk_iterate_upto _ _ = error "not implemented"
+@@ -210,7 +210,7 @@
+     val T = mk_monadT HOLogic.unitT
+     val pT = \<^typ>\<open>(unit => (bool * Code_Evaluation.term list) option)\<close>
+       --> \<^typ>\<open>natural => (bool * Code_Evaluation.term list) option\<close>
+-  in Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_not\<close>, pT --> T) $ t end
++  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_not\<close>, pT --> T) $ t end
+ 
+ fun mk_Enum _ = error "not implemented"
+ 
diff -urN ./Tools/Predicate_Compile/predicate_compile_core.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML
--- ./Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-30 11:49:58.043626700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-31 14:26:38.908985500 +0900
@@ -435,7 +435,7 @@
   compfuns = Random_Sequence_CompFuns.compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -472,7 +472,7 @@
   compfuns = New_Pos_Random_Sequence_CompFuns.depth_limited_compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -536,7 +536,7 @@
   compfuns = Pos_Bounded_CPS_Comp_Funs.compfuns,
   mk_random =
     (fn T => fn _ =>
-       Const (\<^const_name>\<open>Quickcheck_Exhaustive.exhaustive\<close>,
+       Const (\<^const_name>\<open>Random_Prep.exhaustive\<close>,
        (T --> \<^typ>\<open>(bool * term list) option\<close>) -->
          \<^typ>\<open>natural => (bool * term list) option\<close>)),
   modify_funT = I,
diff -urN ./Tools/Predicate_Compile/predicate_compile_core.ML.rej /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML.rej
--- ./Tools/Predicate_Compile/predicate_compile_core.ML.rej	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML.rej	2023-05-30 16:53:58.497585300 +0900
@@ -0,0 +1,29 @@
+--- /Applications/Isabelle2022.app/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-30 15:37:49.000000000 +0900
++++ ./Tools/Predicate_Compile/predicate_compile_core.ML	2022-10-25 03:37:32.000000000 +0900
+@@ -435,7 +435,7 @@
+   compfuns = Random_Sequence_CompFuns.compfuns,
+   mk_random = (fn T => fn _ =>
+   let
+-    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
++    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
+         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
+   in
+@@ -472,7 +472,7 @@
+   compfuns = New_Pos_Random_Sequence_CompFuns.depth_limited_compfuns,
+   mk_random = (fn T => fn _ =>
+   let
+-    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
++    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
+         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
+   in
+@@ -536,7 +536,7 @@
+   compfuns = Pos_Bounded_CPS_Comp_Funs.compfuns,
+   mk_random =
+     (fn T => fn _ =>
+-       Const (\<^const_name>\<open>Random_Prep.exhaustive\<close>,
++       Const (\<^const_name>\<open>Quickcheck_Exhaustive.exhaustive\<close>,
+        (T --> \<^typ>\<open>(bool * term list) option\<close>) -->
+          \<^typ>\<open>natural => (bool * term list) option\<close>)),
+   modify_funT = I,
diff -urN ./Tools/Quickcheck/random_generators.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML
--- ./Tools/Quickcheck/random_generators.ML	2023-05-30 11:50:41.406853100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML	2023-05-31 14:26:38.908985500 +0900
@@ -204,7 +204,7 @@
         val T = Type (tyco, Ts);
         fun mk_random_fun_lift [] t = t
           | mk_random_fun_lift (fT :: fTs) t =
-              mk_const \<^const_name>\<open>random_fun_lift\<close> [fTs ---> T, fT] $
+              mk_const \<^const_name>\<open>Random_Prep.random_fun_lift\<close> [fTs ---> T, fT] $
                 mk_random_fun_lift fTs t;
         val t = mk_random_fun_lift fTs (nth random_auxs k $ size_pred $ size');
         val size = Option.map snd (Old_Datatype_Aux.find_shortest_path descr k)
diff -urN ./Tools/Quickcheck/random_generators.ML.rej /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML.rej
--- ./Tools/Quickcheck/random_generators.ML.rej	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML.rej	2023-05-30 16:53:59.833577400 +0900
@@ -0,0 +1,11 @@
+--- /Applications/Isabelle2022.app/src/HOL/Tools/Quickcheck/random_generators.ML	2023-05-30 15:37:49.000000000 +0900
++++ ./Tools/Quickcheck/random_generators.ML	2022-10-25 03:37:32.000000000 +0900
+@@ -204,7 +204,7 @@
+         val T = Type (tyco, Ts);
+         fun mk_random_fun_lift [] t = t
+           | mk_random_fun_lift (fT :: fTs) t =
+-              mk_const \<^const_name>\<open>Random_Prep.random_fun_lift\<close> [fTs ---> T, fT] $
++              mk_const \<^const_name>\<open>random_fun_lift\<close> [fTs ---> T, fT] $
+                 mk_random_fun_lift fTs t;
+         val t = mk_random_fun_lift fTs (nth random_auxs k $ size_pred $ size');
+         val size = Option.map snd (Old_Datatype_Aux.find_shortest_path descr k)
diff -urN ./Transcendental.thy /cygdrive/c/Isabelle2022/src/HOL/Transcendental.thy
--- ./Transcendental.thy	2023-05-30 11:50:41.644512700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Transcendental.thy	2023-05-31 14:26:38.908985500 +0900
@@ -3422,12 +3422,14 @@
     have "(-1) ^ ((n - Suc 0) div 2) * (-1) ^ ((p - Suc n) div 2) = - ((-1 :: real) ^ (p div 2))"
       if np: "odd n" "even p"
     proof -
-      have "p > 0"
-        using \<open>n \<le> p\<close> neq0_conv that(1) by blast
+      have n1: "Suc 0 \<le>  n" using odd_pos[OF that(1)] by simp
+      have opn: "odd (p - n)" using np \<open>n \<le> p\<close> by simp
+      have snp: "Suc n \<le> p" using odd_pos[OF opn] by simp
+      then have p2: "2 \<le> p" using \<open>n \<le> p\<close> that(2) by (auto elim: oddE)
       then have \<section>: "(- 1::real) ^ (p div 2 - Suc 0) = - ((- 1) ^ (p div 2))"
-        using \<open>even p\<close> by (auto simp add: dvd_def power_eq_if)
-      from \<open>n \<le> p\<close> np have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" "Suc (Suc 0) \<le> p"
-        by arith+
+        by (simp add: power_eq_if)
+      from n1 p2 snp have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" 
+        by simp
       have "(p - Suc (Suc 0)) div 2 = p div 2 - Suc 0"
         by simp
       with \<open>n \<le> p\<close> np  \<section> * show ?thesis
