Seulement dans /home/blanqui/trash/isabelle/src/HOL/Algebra: README.html
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Auth/Guard: README.html
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Auth: README.html
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Bit_Operations.thy /home/blanqui/trash/isabelle/src/HOL/Bit_Operations.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Bit_Operations.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Bit_Operations.thy	2023-05-30 20:42:35.005975334 +0900
@@ -2048,7 +2048,8 @@
 lemma and_int_unfold:
   \<open>k AND l = (if k = 0 \<or> l = 0 then 0 else if k = - 1 then l else if l = - 1 then k
     else (k mod 2) * (l mod 2) + 2 * ((k div 2) AND (l div 2)))\<close> for k l :: int
-  by (auto simp add: and_int_rec [of k l] zmult_eq_1_iff elim: oddE)
+  apply (auto split: if_splits)
+  by (simp add: and_int_rec[of k l] odd_iff_mod_2_eq_one)
 
 lemma or_int_unfold:
   \<open>k OR l = (if k = - 1 \<or> l = - 1 then - 1 else if k = 0 then l else if l = 0 then k
@@ -2058,7 +2059,9 @@
 lemma xor_int_unfold:
   \<open>k XOR l = (if k = - 1 then NOT l else if l = - 1 then NOT k else if k = 0 then l else if l = 0 then k
     else \<bar>k mod 2 - l mod 2\<bar> + 2 * ((k div 2) XOR (l div 2)))\<close> for k l :: int
-  by (auto simp add: xor_int_rec [of k l] not_int_def elim!: oddE)
+  apply (auto split: if_splits)
+  apply (simp add: xor_int_rec[of k l] odd_iff_mod_2_eq_one)
+  by auto
 
 lemma bit_minus_int_iff:
   \<open>bit (- k) n \<longleftrightarrow> bit (NOT (k - 1)) n\<close>
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Enum.thy /home/blanqui/trash/isabelle/src/HOL/Enum.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Enum.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Enum.thy	2023-05-30 17:31:27.175282295 +0900
@@ -447,7 +447,7 @@
 
  
 instance
-  by standard
+  by intro_classes
     (simp_all add: enum_prod_def distinct_product
       enum_UNIV enum_distinct enum_all_prod_def enum_ex_prod_def)
 
@@ -489,6 +489,109 @@
 
 end
 
+class finite_lattice = finite +  lattice + Inf + Sup  + bot + top +
+  assumes Inf_finite_empty: "Inf {} = Sup UNIV"
+  assumes Inf_finite_insert: "Inf (insert a A) = a \<sqinter> Inf A"
+  assumes Sup_finite_empty: "Sup {} = Inf UNIV"
+  assumes Sup_finite_insert: "Sup (insert a A) = a \<squnion> Sup A"
+  assumes bot_finite_def: "bot = Inf UNIV"
+  assumes top_finite_def: "top = Sup UNIV"
+begin
+
+subclass complete_lattice
+proof
+  fix x A
+  show "x \<in> A \<Longrightarrow> \<Sqinter>A \<le> x"
+    by (metis Set.set_insert abel_semigroup.commute local.Inf_finite_insert local.inf.abel_semigroup_axioms local.inf.left_idem local.inf.orderI)
+  show "x \<in> A \<Longrightarrow> x \<le> \<Squnion>A"
+    by (metis Set.set_insert insert_absorb2 local.Sup_finite_insert local.sup.absorb_iff2)
+next
+  fix A z
+  have "\<Squnion> UNIV = z \<squnion> \<Squnion>UNIV"
+    by (subst Sup_finite_insert [symmetric], simp add: insert_UNIV)
+  from this have [simp]: "z \<le> \<Squnion>UNIV"
+    using local.le_iff_sup by auto
+  have "(\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"
+    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"])
+      (simp_all add: Inf_finite_empty Inf_finite_insert)
+  from this show "(\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow> z \<le> \<Sqinter>A"
+    by simp
+
+  have "\<Sqinter> UNIV = z \<sqinter> \<Sqinter>UNIV"
+    by (subst Inf_finite_insert [symmetric], simp add: insert_UNIV)
+  from this have [simp]: "\<Sqinter>UNIV \<le> z"
+    by (simp add: local.inf.absorb_iff2)
+  have "(\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z"
+    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z" ], simp_all add: Sup_finite_empty Sup_finite_insert)
+  from this show " (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow> \<Squnion>A \<le> z"
+    by blast
+next
+  show "\<Sqinter>{} = \<top>"
+    by (simp add: Inf_finite_empty top_finite_def)
+  show " \<Squnion>{} = \<bottom>"
+    by (simp add: Sup_finite_empty bot_finite_def)
+qed
+end
+
+class finite_distrib_lattice = finite_lattice + distrib_lattice 
+begin
+lemma finite_inf_Sup: "a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"
+proof (rule finite_induct [of A "\<lambda> A . a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"], simp_all)
+  fix x::"'a"
+  fix F
+  assume "x \<notin> F"
+  assume [simp]: "a \<sqinter> \<Squnion>F = \<Squnion>{a \<sqinter> b |b. b \<in> F}"
+  have [simp]: " insert (a \<sqinter> x) {a \<sqinter> b |b. b \<in> F} = {a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by blast
+  have "a \<sqinter> (x \<squnion> \<Squnion>F) = a \<sqinter> x \<squnion> a \<sqinter> \<Squnion>F"
+    by (simp add: inf_sup_distrib1)
+  also have "... = a \<sqinter> x \<squnion> \<Squnion>{a \<sqinter> b |b. b \<in> F}"
+    by simp
+  also have "... = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by (unfold Sup_insert[THEN sym], simp)
+  finally show "a \<sqinter> (x \<squnion> \<Squnion>F) = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by simp
+qed
+
+lemma finite_Inf_Sup: "\<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"
+proof (rule finite_induct [of A "\<lambda>A. \<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"], simp_all add: finite_UnionD)
+  fix x::"'a set"
+  fix F
+  assume "x \<notin> F"
+  have [simp]: "{\<Squnion>x \<sqinter> b |b . b \<in> Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y} } = {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  . (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by auto
+  define fa where "fa = (\<lambda> (b::'a) f Y . (if Y = x then b else f Y))"
+  have "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> insert b (f ` (F \<inter> {Y. Y \<noteq> x})) = insert (fa b f x) (fa b f ` F) \<and> fa b f x \<in> x \<and> (\<forall>Y\<in>F. fa b f Y \<in> Y)"
+    by (auto simp add: fa_def)
+  from this have B: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> fa b f ` ({x} \<union> F) \<in> {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by blast
+  have [simp]: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> b \<sqinter> (\<Sqinter>x\<in>F. f x)  \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    using B apply (rule SUP_upper2)
+    using \<open>x \<notin> F\<close> apply (simp_all add: fa_def Inf_union_distrib)
+    apply (simp add: image_mono Inf_superset_mono inf.coboundedI2)
+    done
+  assume "\<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
+
+  from this have "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>x \<sqinter> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
+    using inf.coboundedI2 by auto
+  also have "... = Sup {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by (simp add: finite_inf_Sup)
+
+  also have "... = Sup {Sup {Inf (f ` F) \<sqinter> b | b . b \<in> x} |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by (subst inf_commute) (simp add: finite_inf_Sup)
+
+  also have "... \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    apply (rule Sup_least, clarsimp)+
+    apply (subst inf_commute, simp)
+    done
+
+  finally show "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    by simp
+qed
+
+subclass complete_distrib_lattice
+  by (standard, rule finite_Inf_Sup)
+end
 
 subsection \<open>Small finite types\<close>
 
@@ -682,7 +785,7 @@
 
 instance finite_2 :: complete_distrib_lattice ..
 
-instantiation finite_2 :: "{field, idom_abs_sgn, idom_modulo}" begin
+instantiation finite_2 :: field begin
 definition [simp]: "0 = a\<^sub>1"
 definition [simp]: "1 = a\<^sub>2"
 definition "x + y = (case (x, y) of (a\<^sub>1, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>1 | _ \<Rightarrow> a\<^sub>2)"
@@ -691,17 +794,51 @@
 definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> a\<^sub>1)"
 definition "inverse = (\<lambda>x :: finite_2. x)"
 definition "divide = ((*) :: finite_2 \<Rightarrow> _)"
+
+instance
+proof(intro_classes)
+  fix a b c :: finite_2
+  show "a + b + c = a + (b + c)" 
+    by (cases a; cases b; cases c; simp add: plus_finite_2_def)
+  show "0 + a = a" by (cases a; simp add: plus_finite_2_def)
+  show "-a + a = 0" by (cases a; simp add: plus_finite_2_def uminus_finite_2_def)
+  show "a - b = a + -b" by (simp add: minus_finite_2_def uminus_finite_2_def)
+  show "a * b * c = a * (b * c)" by (cases a; cases b; cases c; simp add: times_finite_2_def)
+  show "a * b = b * a" by (cases a; cases b; simp add: times_finite_2_def)
+  show "1 * a = a" by (cases a; simp add: times_finite_2_def)
+  show "a + b = b + a" by (cases a; cases b; simp add: plus_finite_2_def)
+  show "(a + b) * c = a * c + b * c" 
+    by (cases a; cases b; cases c; simp add: plus_finite_2_def times_finite_2_def)
+  show "(0::finite_2) \<noteq> 1" by simp
+  show "a \<noteq> 0 \<Longrightarrow> inverse a * a = 1" 
+    by (cases a; simp add: times_finite_2_def inverse_finite_2_def)
+  show "a div b = a * inverse b" by (simp add: divide_finite_2_def inverse_finite_2_def)
+  show "inverse (0::finite_2) = 0" by (simp add: inverse_finite_2_def)
+qed
+  
+end
+
+instantiation finite_2 :: "{idom_abs_sgn, idom_modulo}" begin
 definition "x mod y = (case (x, y) of (a\<^sub>2, a\<^sub>1) \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x :: finite_2. x)"
 definition "sgn = (\<lambda>x :: finite_2. x)"
+
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_2_def uminus_finite_2_def minus_finite_2_def
-        times_finite_2_def
-        inverse_finite_2_def divide_finite_2_def modulo_finite_2_def
-        abs_finite_2_def sgn_finite_2_def
-        split: finite_2.splits\<close>)
+proof(intro_classes)
+  fix a b :: finite_2
+  show "sgn a * \<bar>a\<bar> = a" by (cases a; simp add: abs_finite_2_def sgn_finite_2_def)
+  show "sgn (sgn a) = sgn a" by (simp add: sgn_finite_2_def)
+  show "\<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>" by (cases a; simp add: abs_finite_2_def)
+  show "\<bar>(0::finite_2)\<bar> = 0" by (simp add: abs_finite_2_def)
+  show "sgn (0::finite_2) = 0" by (simp add: sgn_finite_2_def)
+  show "sgn (1::finite_2) = 1" by (simp add: sgn_finite_2_def)
+  show "sgn (- (1::finite_2)) = - 1" by (simp add: sgn_finite_2_def)
+  show "sgn (a * b) = sgn a * sgn b" by (simp add: sgn_finite_2_def)
+  show "a / b * b + a mod b = a" 
+    by (cases a; cases b; 
+        simp add: plus_finite_2_def times_finite_2_def modulo_finite_2_def 
+          divide_finite_2_def inverse_finite_2_def)
+qed
 end
 
 lemma two_finite_2 [simp]:
@@ -710,18 +847,46 @@
 
 lemma dvd_finite_2_unfold:
   "x dvd y \<longleftrightarrow> x = a\<^sub>2 \<or> y = a\<^sub>1"
-  by (auto simp add: dvd_def times_finite_2_def split: finite_2.splits)
+proof(unfold dvd_def)
+  fix x y :: finite_2
+  have "(\<exists>k. y = x * k) = (y = x * a\<^sub>1 \<or> y = x * a\<^sub>2)" 
+    using exists_code[of "\<lambda>k. y = x * k"] enum_ex_finite_2_def[of "\<lambda>k. y = x * k"] by auto
+  then show "(\<exists>k. y = x * k) = (x = a\<^sub>2 \<or> y = a\<^sub>1)"
+    by (cases x; cases y; simp add: enum_ex_finite_2_def times_finite_2_def)
+qed
 
 instantiation finite_2 :: "{normalization_semidom, unique_euclidean_semiring}" begin
 definition [simp]: "normalize = (id :: finite_2 \<Rightarrow> _)"
 definition [simp]: "unit_factor = (id :: finite_2 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | a\<^sub>2 \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_2) = 1"
+
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: divide_finite_2_def times_finite_2_def dvd_finite_2_unfold
-        split: finite_2.splits\<close>)
+proof(intro_classes)
+  fix a b r :: finite_2
+  show "euclidean_size (0::finite_2) = 0" by simp
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size (a mod b) < euclidean_size b" 
+    by (cases a; cases b; simp add:  modulo_finite_2_def)
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size a \<le> euclidean_size (a * b)"
+    by (cases a; cases b; simp add:  times_finite_2_def)
+  show "euclidean_size (a * b) =  euclidean_size a * euclidean_size b"
+    by (cases a; cases b; simp add:  times_finite_2_def)
+  show "is_unit (division_segment a)" by simp
+  show "a \<noteq> 0 \<Longrightarrow> b \<noteq> 0 \<Longrightarrow> division_segment (a * b) = division_segment a * division_segment b"
+    by (cases a; cases b; simp add:  times_finite_2_def)
+  show "b \<noteq> 0 \<Longrightarrow>  \<not> b dvd a \<Longrightarrow> division_segment (a mod b) = division_segment b"
+    by (simp add: dvd_finite_2_unfold)
+  show "b \<noteq> 0 \<Longrightarrow> division_segment r = division_segment b \<Longrightarrow> 
+          euclidean_size r < euclidean_size b \<Longrightarrow> (a * b + r) / b = a"
+    by (cases b; cases a; cases r; 
+        simp add: divide_finite_2_def inverse_finite_2_def times_finite_2_def plus_finite_2_def)
+  show "unit_factor (0::finite_2) = 0" by simp
+  show "is_unit a \<Longrightarrow> unit_factor a = a" by simp
+  show "a \<noteq> 0 \<Longrightarrow> is_unit (unit_factor a)" by (cases a; simp add: dvd_finite_2_unfold)
+  show "is_unit a \<Longrightarrow> unit_factor (a * b) =  a * unit_factor b" by simp
+  show "unit_factor a * normalize a = a" by (cases a; simp)
+  show "normalize (0::finite_2) = 0" by simp
+qed
 end
 
  
@@ -784,109 +949,7 @@
   from this[symmetric] show "wf \<dots>" by simp
 qed intro_classes
 
-class finite_lattice = finite +  lattice + Inf + Sup  + bot + top +
-  assumes Inf_finite_empty: "Inf {} = Sup UNIV"
-  assumes Inf_finite_insert: "Inf (insert a A) = a \<sqinter> Inf A"
-  assumes Sup_finite_empty: "Sup {} = Inf UNIV"
-  assumes Sup_finite_insert: "Sup (insert a A) = a \<squnion> Sup A"
-  assumes bot_finite_def: "bot = Inf UNIV"
-  assumes top_finite_def: "top = Sup UNIV"
-begin
-
-subclass complete_lattice
-proof
-  fix x A
-  show "x \<in> A \<Longrightarrow> \<Sqinter>A \<le> x"
-    by (metis Set.set_insert abel_semigroup.commute local.Inf_finite_insert local.inf.abel_semigroup_axioms local.inf.left_idem local.inf.orderI)
-  show "x \<in> A \<Longrightarrow> x \<le> \<Squnion>A"
-    by (metis Set.set_insert insert_absorb2 local.Sup_finite_insert local.sup.absorb_iff2)
-next
-  fix A z
-  have "\<Squnion> UNIV = z \<squnion> \<Squnion>UNIV"
-    by (subst Sup_finite_insert [symmetric], simp add: insert_UNIV)
-  from this have [simp]: "z \<le> \<Squnion>UNIV"
-    using local.le_iff_sup by auto
-  have "(\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"
-    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"])
-      (simp_all add: Inf_finite_empty Inf_finite_insert)
-  from this show "(\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow> z \<le> \<Sqinter>A"
-    by simp
-
-  have "\<Sqinter> UNIV = z \<sqinter> \<Sqinter>UNIV"
-    by (subst Inf_finite_insert [symmetric], simp add: insert_UNIV)
-  from this have [simp]: "\<Sqinter>UNIV \<le> z"
-    by (simp add: local.inf.absorb_iff2)
-  have "(\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z"
-    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z" ], simp_all add: Sup_finite_empty Sup_finite_insert)
-  from this show " (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow> \<Squnion>A \<le> z"
-    by blast
-next
-  show "\<Sqinter>{} = \<top>"
-    by (simp add: Inf_finite_empty top_finite_def)
-  show " \<Squnion>{} = \<bottom>"
-    by (simp add: Sup_finite_empty bot_finite_def)
-qed
-end
-
-class finite_distrib_lattice = finite_lattice + distrib_lattice 
-begin
-lemma finite_inf_Sup: "a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"
-proof (rule finite_induct [of A "\<lambda> A . a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"], simp_all)
-  fix x::"'a"
-  fix F
-  assume "x \<notin> F"
-  assume [simp]: "a \<sqinter> \<Squnion>F = \<Squnion>{a \<sqinter> b |b. b \<in> F}"
-  have [simp]: " insert (a \<sqinter> x) {a \<sqinter> b |b. b \<in> F} = {a \<sqinter> b |b. b = x \<or> b \<in> F}"
-    by blast
-  have "a \<sqinter> (x \<squnion> \<Squnion>F) = a \<sqinter> x \<squnion> a \<sqinter> \<Squnion>F"
-    by (simp add: inf_sup_distrib1)
-  also have "... = a \<sqinter> x \<squnion> \<Squnion>{a \<sqinter> b |b. b \<in> F}"
-    by simp
-  also have "... = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
-    by (unfold Sup_insert[THEN sym], simp)
-  finally show "a \<sqinter> (x \<squnion> \<Squnion>F) = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
-    by simp
-qed
-
-lemma finite_Inf_Sup: "\<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"
-proof (rule finite_induct [of A "\<lambda>A. \<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"], simp_all add: finite_UnionD)
-  fix x::"'a set"
-  fix F
-  assume "x \<notin> F"
-  have [simp]: "{\<Squnion>x \<sqinter> b |b . b \<in> Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y} } = {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  . (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by auto
-  define fa where "fa = (\<lambda> (b::'a) f Y . (if Y = x then b else f Y))"
-  have "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> insert b (f ` (F \<inter> {Y. Y \<noteq> x})) = insert (fa b f x) (fa b f ` F) \<and> fa b f x \<in> x \<and> (\<forall>Y\<in>F. fa b f Y \<in> Y)"
-    by (auto simp add: fa_def)
-  from this have B: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> fa b f ` ({x} \<union> F) \<in> {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by blast
-  have [simp]: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> b \<sqinter> (\<Sqinter>x\<in>F. f x)  \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
-    using B apply (rule SUP_upper2)
-    using \<open>x \<notin> F\<close> apply (simp_all add: fa_def Inf_union_distrib)
-    apply (simp add: image_mono Inf_superset_mono inf.coboundedI2)
-    done
-  assume "\<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
-
-  from this have "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>x \<sqinter> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
-    using inf.coboundedI2 by auto
-  also have "... = Sup {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by (simp add: finite_inf_Sup)
-
-  also have "... = Sup {Sup {Inf (f ` F) \<sqinter> b | b . b \<in> x} |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by (subst inf_commute) (simp add: finite_inf_Sup)
-
-  also have "... \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
-    apply (rule Sup_least, clarsimp)+
-    apply (subst inf_commute, simp)
-    done
 
-  finally show "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
-    by simp
-qed
-
-subclass complete_distrib_lattice
-  by (standard, rule finite_Inf_Sup)
-end
 
 instantiation finite_3 :: finite_lattice
 begin
@@ -913,9 +976,8 @@
 
 instance finite_3 :: complete_linorder ..
 
-instantiation finite_3 :: "{field, idom_abs_sgn, idom_modulo}" begin
+instantiation finite_3 :: field begin
 definition [simp]: "0 = a\<^sub>1"
-definition [simp]: "1 = a\<^sub>2"
 definition
   "x + y = (case (x, y) of
      (a\<^sub>1, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>1 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>1
@@ -923,21 +985,56 @@
    | _ \<Rightarrow> a\<^sub>3)"
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>1 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2)"
 definition "x - y = x + (- y :: finite_3)"
+definition [simp]: "1 = a\<^sub>2"
 definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | (a\<^sub>3, a\<^sub>3) \<Rightarrow> a\<^sub>2 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>3 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>3 | _ \<Rightarrow> a\<^sub>1)"
 definition "inverse = (\<lambda>x :: finite_3. x)" 
 definition "x div y = x * inverse (y :: finite_3)"
+
+
+instance
+proof(intro_classes)
+  fix a b c :: finite_3
+  show "a + b + c = a + (b + c)" 
+    by (cases a; cases b; cases c; simp add: plus_finite_3_def)
+  show "0 + a = a" by (cases a; simp add: plus_finite_3_def)
+  show "-a + a = 0" by (cases a; simp add: plus_finite_3_def uminus_finite_3_def)
+  show "a - b = a + -b" by (simp add: minus_finite_3_def)
+  show "a * b * c = a * (b * c)" by (cases a; cases b; cases c; simp add: times_finite_3_def)
+  show "a * b = b * a" by (cases a; cases b; simp add: times_finite_3_def)
+  show "1 * a = a" by (cases a; simp add: times_finite_3_def)
+  show "a + b = b + a" by (cases a; cases b; simp add: plus_finite_3_def)
+  show "(a + b) * c = a * c + b * c" 
+    by (cases a; cases b; cases c; simp add: plus_finite_3_def times_finite_3_def)
+  show "(0::finite_3) \<noteq> 1" by simp
+  show "a \<noteq> 0 \<Longrightarrow> inverse a * a = 1" 
+    by (cases a; simp add: times_finite_3_def inverse_finite_3_def)
+  show "a div b = a * inverse b" by (simp add: divide_finite_3_def)
+  show "inverse (0::finite_3) = 0" by (simp add: inverse_finite_3_def)
+qed
+  
+end
+
+instantiation finite_3 :: "{idom_abs_sgn, idom_modulo}" begin
 definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
-definition "sgn = (\<lambda>x :: finite_3. x)"
+definition "sgn  = (\<lambda>x :: finite_3. x)"
+
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
-        times_finite_3_def
-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
-        abs_finite_3_def sgn_finite_3_def
-        less_finite_3_def
-        split: finite_3.splits\<close>)
+proof(intro_classes)
+  fix a b :: finite_3
+  show "sgn a * \<bar>a\<bar> = a" by (cases a; simp add: abs_finite_3_def sgn_finite_3_def)
+  show "sgn (sgn a) = sgn a" by (simp add: sgn_finite_3_def)
+  show "\<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>" by (cases a; simp add: abs_finite_3_def)
+  show "\<bar>(0::finite_3)\<bar> = 0" by (simp add: abs_finite_3_def)
+  show "sgn (0::finite_3) = 0" by (simp add: sgn_finite_3_def)
+  show "sgn (1::finite_3) = 1" by (simp add: sgn_finite_3_def)
+  show "sgn (- (1::finite_3)) = - 1" by (simp add: sgn_finite_3_def)
+  show "sgn (a * b) = sgn a * sgn b" by (simp add: sgn_finite_3_def)
+  show "a / b * b + a mod b = a" 
+    by (cases a; cases b; 
+        simp add: plus_finite_3_def times_finite_3_def modulo_finite_3_def 
+          divide_finite_3_def inverse_finite_3_def)
+qed
 end
 
 lemma two_finite_3 [simp]:
@@ -946,24 +1043,46 @@
 
 lemma dvd_finite_3_unfold:
   "x dvd y \<longleftrightarrow> x = a\<^sub>2 \<or> x = a\<^sub>3 \<or> y = a\<^sub>1"
-  by (cases x) (auto simp add: dvd_def times_finite_3_def split: finite_3.splits)
+proof(unfold dvd_def)
+  fix x y :: finite_3
+  have "(\<exists>k. y = x * k) = (y = x * a\<^sub>1 \<or> y = x * a\<^sub>2 \<or> y = x * a\<^sub>3)" 
+    using exists_code[of "\<lambda>k. y = x * k"] enum_ex_finite_3_def[of "\<lambda>k. y = x * k"] by auto
+  then show "(\<exists>k. y = x * k) = (x = a\<^sub>2 \<or> x = a\<^sub>3 \<or> y = a\<^sub>1)"
+    by (cases x; cases y; simp add: enum_ex_finite_3_def times_finite_3_def)
+qed
 
 instantiation finite_3 :: "{normalization_semidom, unique_euclidean_semiring}" begin
 definition [simp]: "normalize x = (case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
 definition [simp]: "unit_factor = (id :: finite_3 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | _ \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_3) = 1"
+
 instance
-proof
-  fix x :: finite_3
-  assume "x \<noteq> 0"
-  then show "is_unit (unit_factor x)"
-    by (cases x) (simp_all add: dvd_finite_3_unfold)
-qed
-  (subproofs
-    \<open>auto simp add: divide_finite_3_def times_finite_3_def
-      dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
-      split: finite_3.splits\<close>)
+proof(intro_classes)
+  fix a b r :: finite_3
+  show "euclidean_size (0::finite_3) = 0" by simp
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size (a mod b) < euclidean_size b" 
+    by (cases a; cases b; simp add:  modulo_finite_3_def)
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size a \<le> euclidean_size (a * b)"
+    by (cases a; cases b; simp add:  times_finite_3_def)
+  show "euclidean_size (a * b) =  euclidean_size a * euclidean_size b"
+    by (cases a; cases b; simp add:  times_finite_3_def)
+  show "is_unit (division_segment a)" by simp
+  show "a \<noteq> 0 \<Longrightarrow> b \<noteq> 0 \<Longrightarrow> division_segment (a * b) = division_segment a * division_segment b"
+    by (cases a; cases b; simp add:  times_finite_3_def)
+  show "b \<noteq> 0 \<Longrightarrow>  \<not> b dvd a \<Longrightarrow> division_segment (a mod b) = division_segment b"
+    by (simp add: dvd_finite_3_unfold)
+  show "b \<noteq> 0 \<Longrightarrow> division_segment r = division_segment b \<Longrightarrow> 
+          euclidean_size r < euclidean_size b \<Longrightarrow> (a * b + r) / b = a"
+    by (cases b; cases a; cases r; 
+        simp add: divide_finite_3_def inverse_finite_3_def times_finite_3_def plus_finite_3_def)
+  show "unit_factor (0::finite_3) = 0" by simp
+  show "is_unit a \<Longrightarrow> unit_factor a = a" by simp
+  show "a \<noteq> 0 \<Longrightarrow> is_unit (unit_factor a)" by (cases a; simp add: dvd_finite_3_unfold)
+  show "is_unit a \<Longrightarrow> unit_factor (a * b) =  a * unit_factor b" by simp
+  show "unit_factor a * normalize a = a" by (cases a; simp)
+  show "normalize (0::finite_3) = 0" by simp
+qed
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3
@@ -1035,10 +1154,39 @@
   | _ \<Rightarrow> a\<^sub>1)"
 
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
-        inf_finite_4_def sup_finite_4_def split: finite_4.splits\<close>)
+proof(intro_classes)
+  fix x y z :: finite_4
+  fix A :: "finite_4 set"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)" 
+    by (cases x; cases y; simp add: less_eq_finite_4_def less_finite_4_def)
+  show "x \<le> x" by (cases x; simp add: less_eq_finite_4_def)
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z" 
+    by (cases x; cases y; cases z; simp add: less_eq_finite_4_def)
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y" 
+    by (cases x; cases y; simp add: less_eq_finite_4_def)
+  show "x \<sqinter> y \<le> x" 
+    by (cases x; cases y; simp add: inf_finite_4_def less_eq_finite_4_def)
+  show "x \<sqinter> y \<le> y" 
+    by (cases x; cases y; simp add: inf_finite_4_def less_eq_finite_4_def)
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> y \<sqinter> z"
+    by (cases x; cases y; cases z; simp add: inf_finite_4_def less_eq_finite_4_def)
+  show "x \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_4_def less_eq_finite_4_def)
+  show "y \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_4_def less_eq_finite_4_def)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> y \<squnion> z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_finite_4_def less_eq_finite_4_def)
+  show "\<Sqinter> ({}:: finite_4 set) = \<Squnion> UNIV" by (simp add: Sup_finite_4_def Inf_finite_4_def)
+  show "\<Sqinter> insert x A = x \<sqinter> \<Sqinter> A"
+    by (cases x; simp add: Inf_finite_4_def inf_finite_4_def)
+  show "\<Squnion> ({}:: finite_4 set) = \<Sqinter> UNIV" by (simp add: Sup_finite_4_def Inf_finite_4_def)
+  show "\<Squnion> insert x A = x \<squnion> \<Squnion> A" 
+    by (cases x; simp add: Sup_finite_4_def sup_finite_4_def)
+  show "(\<bottom>:: finite_4) = \<Sqinter> UNIV" by (simp add: Inf_finite_4_def)
+  show "(\<top>:: finite_4)  = \<Squnion> UNIV" by (simp add: Sup_finite_4_def)
+  show "x \<squnion> y \<sqinter> z = (x \<squnion> y) \<sqinter> (x \<squnion> z)"
+    by (cases x; cases y; cases z; simp add: sup_finite_4_def inf_finite_4_def)
+qed
 end
 
 instance finite_4 :: complete_lattice ..
@@ -1049,14 +1197,17 @@
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>4 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2 | a\<^sub>4 \<Rightarrow> a\<^sub>1)"
 definition "x - y = x \<sqinter> - (y :: finite_4)"
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def 
-        split: finite_4.splits\<close>)
+proof(intro_classes)
+  fix x y :: finite_4
+  show "x \<sqinter> - x = \<bottom>" by (cases x; simp add: uminus_finite_4_def inf_finite_4_def)
+  show "x \<squnion> - x = \<top>" by (cases x; simp add: uminus_finite_4_def sup_finite_4_def)
+  show "x - y = x \<sqinter> - y" by (simp add: minus_finite_4_def)
+qed
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4
 
+
 datatype (plugins only: code "quickcheck" extraction) finite_5 =
   a\<^sub>1 | a\<^sub>2 | a\<^sub>3 | a\<^sub>4 | a\<^sub>5
 
@@ -1139,10 +1290,37 @@
    | _ \<Rightarrow> a\<^sub>1)"
 
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
-        Inf_finite_5_def Sup_finite_5_def split: finite_5.splits if_split_asm\<close>)
+proof(intro_classes)
+  fix x y z :: finite_5
+  fix A :: "finite_5 set"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)" 
+    by (cases x; cases y; simp add: less_eq_finite_5_def less_finite_5_def)
+  show "x \<le> x" by (cases x; simp add: less_eq_finite_5_def)
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z" 
+    by (cases x; cases y; cases z; simp add: less_eq_finite_5_def)
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y" 
+    by (cases x; cases y; simp add: less_eq_finite_5_def)
+  show "x \<sqinter> y \<le> x" 
+    by (cases x; cases y; simp add: inf_finite_5_def less_eq_finite_5_def)
+  show "x \<sqinter> y \<le> y" 
+    by (cases x; cases y; simp add: inf_finite_5_def less_eq_finite_5_def)
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> y \<sqinter> z"
+    by (cases x; cases y; cases z; simp add: inf_finite_5_def less_eq_finite_5_def)
+  show "x \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_5_def less_eq_finite_5_def)
+  show "y \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_5_def less_eq_finite_5_def)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> y \<squnion> z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_finite_5_def less_eq_finite_5_def)
+  show "\<Sqinter> ({}:: finite_5 set) = \<Squnion> UNIV" by (simp add: Sup_finite_5_def Inf_finite_5_def)
+  show "\<Sqinter> insert x A = x \<sqinter> \<Sqinter> A"
+    by (cases x; simp add: Inf_finite_5_def inf_finite_5_def)
+  show "\<Squnion> ({}:: finite_5 set) = \<Sqinter> UNIV" by (simp add: Sup_finite_5_def Inf_finite_5_def)
+  show "\<Squnion> insert x A = x \<squnion> \<Squnion> A" 
+    by (cases x; simp add: Sup_finite_5_def sup_finite_5_def)
+  show "(\<bottom>:: finite_5) = \<Sqinter> UNIV" by (simp add: Inf_finite_5_def)
+  show "(\<top>:: finite_5)  = \<Squnion> UNIV" by (simp add: Sup_finite_5_def)
+qed
 end
 
 
Seulement dans /home/blanqui/trash/isabelle/src/HOL/ex: Dedekind_Real.thy
Seulement dans /home/blanqui/trash/isabelle/src/HOL/ex: Primrec.thy
Seulement dans /home/blanqui/trash/isabelle/src/HOL/ex: Rewrite_Examples.thy
Seulement dans /home/blanqui/trash/isabelle/src/HOL/ex: Sum_of_Powers.thy
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Factorial.thy /home/blanqui/trash/isabelle/src/HOL/Factorial.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Factorial.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Factorial.thy	2023-05-30 17:07:44.278279790 +0900
@@ -28,7 +28,7 @@
   have "prod Suc {0..<n} = \<Prod>{1..n}"
     by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
   then have "prod Suc {0..<n} = prod ((-) (n + 1)) {1..n}"
-    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by presburger
+    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by auto
   then show ?thesis
     unfolding fact_prod_Suc by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
 qed
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Hoare: README.html
Seulement dans /home/blanqui/trash/isabelle/src/HOL/HOLCF: README.html
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Library: README.html
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/List.thy /home/blanqui/trash/isabelle/src/HOL/List.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/List.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/List.thy	2023-05-30 17:38:01.574256677 +0900
@@ -5,7 +5,7 @@
 section \<open>The datatype of finite lists\<close>
 
 theory List
-imports Sledgehammer Lifting_Set
+imports Lifting_Set Set_Interval Numeral_Simprocs
 begin
 
 datatype (set: 'a) list =
@@ -962,13 +962,13 @@
 by (induct xs) auto
 
 lemma hd_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> hd (xs @ ys) = hd xs"
-by (simp add: hd_append split: list.split)
+by (simp add: hd_append)
 
 lemma tl_append: "tl (xs @ ys) = (case xs of [] \<Rightarrow> tl ys | z#zs \<Rightarrow> zs @ ys)"
-by (simp split: list.split)
+by (cases xs; simp)
 
 lemma tl_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> tl (xs @ ys) = tl xs @ ys"
-by (simp add: tl_append split: list.split)
+by (cases xs;simp add: tl_append)
 
 lemma tl_append_if: "tl (xs @ ys) = (if xs = [] then tl ys else tl xs @ ys)"
 by (simp)
@@ -1520,6 +1520,7 @@
 in K list_neq end
 \<close>
 
+
 subsubsection \<open>\<^const>\<open>filter\<close>\<close>
 
 lemma filter_append [simp]: "filter P (xs @ ys) = filter P xs @ filter P ys"
@@ -1591,7 +1592,7 @@
   proof (cases)
     assume "p x"
     hence eq: "?S' = insert 0 (Suc ` ?S)"
-      by(auto simp: image_def split:nat.split dest:gr0_implies_Suc)
+      by (auto simp: image_def dest:gr0_implies_Suc)
     have "length (filter p (x # xs)) = Suc(card ?S)"
       using Cons \<open>p x\<close> by simp
     also have "\<dots> = Suc(card(Suc ` ?S))" using fin
@@ -1854,7 +1855,6 @@
   qed
 qed
 
-
 subsubsection \<open>\<^const>\<open>list_update\<close>\<close>
 
 lemma length_list_update [simp]: "length(xs[i:=x]) = length xs"
@@ -2376,7 +2376,6 @@
 lemma nth_image: "l \<le> size xs \<Longrightarrow> nth xs ` {0..<l} = set(take l xs)"
   by (simp add: set_conv_nth) force
 
-
 subsubsection \<open>\<^const>\<open>takeWhile\<close> and \<^const>\<open>dropWhile\<close>\<close>
 
 lemma length_takeWhile_le: "length (takeWhile P xs) \<le> length xs"
@@ -2440,7 +2439,7 @@
   by (induct xs) (auto split: if_split_asm)
 
 lemma set_takeWhileD: "x \<in> set (takeWhile P xs) \<Longrightarrow> x \<in> set xs \<and> P x"
-  by (induct xs) (auto split: if_split_asm)
+  by (induct xs;auto) 
 
 lemma takeWhile_eq_all_conv[simp]:
   "(takeWhile P xs = xs) = (\<forall>x \<in> set xs. P x)"
@@ -2596,7 +2595,7 @@
 
 lemma zip_Cons1:
   "zip (x#xs) ys = (case ys of [] \<Rightarrow> [] | y#ys \<Rightarrow> (x,y)#zip xs ys)"
-  by(auto split:list.split)
+  by (cases xs; cases ys; simp)
 
 lemma length_zip [simp]:
   "length (zip xs ys) = min (length xs) (length ys)"
@@ -3072,7 +3071,6 @@
   then show "xs \<in> ?L" by induct auto
 qed
 
-
 subsubsection \<open>\<^const>\<open>fold\<close> with natural argument order\<close>
 
 lemma fold_simps [code]: \<comment> \<open>eta-expanded variant for generated code -- enables tail-recursion optimisation in Scala\<close>
@@ -3421,7 +3419,6 @@
     by simp
 qed
 
-
 subsubsection \<open>\<open>upto\<close>: interval-list on \<^typ>\<open>int\<close>\<close>
 
 function upto :: "int \<Rightarrow> int \<Rightarrow> int list" ("(1[_../_])") where
@@ -4159,7 +4156,7 @@
 
 lemma remdups_adj_append'': "xs \<noteq> []
   \<Longrightarrow> remdups_adj (xs @ ys) = remdups_adj xs @ remdups_adj (dropWhile (\<lambda>y. y = last xs) ys)"
-by (induction xs rule: remdups_adj.induct) (auto simp: remdups_adj_Cons')
+  by (induction xs rule: remdups_adj.induct) (auto simp: remdups_adj_Cons')
 
 
 subsection \<open>@{const distinct_adj}\<close>
@@ -4462,9 +4459,14 @@
   distinct (removeAll [] xs) \<and>
   (\<forall>ys. ys \<in> set xs \<longrightarrow> distinct ys) \<and>
   (\<forall>ys zs. ys \<in> set xs \<and> zs \<in> set xs \<and> ys \<noteq> zs \<longrightarrow> set ys \<inter> set zs = {})"
-apply (induct xs)
- apply(simp_all, safe, auto)
-by (metis Int_iff UN_I empty_iff equals0I set_empty)
+  apply (fold disjnt_def)
+proof(induct xs)
+  case Nil
+  then show ?case by simp
+next
+  case (Cons a xs)
+  show ?case by (auto simp: Cons Ball_def disjnt_def[symmetric] disjnt_sym)
+qed
 
 
 subsubsection \<open>\<^const>\<open>replicate\<close>\<close>
@@ -4946,7 +4948,6 @@
   with Cons show ?case by(simp add: nths_Cons cong:filter_cong)
 qed
 
-
 subsubsection \<open>\<^const>\<open>subseqs\<close> and \<^const>\<open>List.n_lists\<close>\<close>
 
 lemma length_subseqs: "length (subseqs xs) = 2 ^ length xs"
@@ -5050,7 +5051,16 @@
   "z # zs \<in> shuffles xs ys \<longleftrightarrow>
     (xs \<noteq> [] \<and> hd xs = z \<and> zs \<in> shuffles (tl xs) ys \<or>
      ys \<noteq> [] \<and> hd ys = z \<and> zs \<in> shuffles xs (tl ys))"
-  by (induct xs ys rule: shuffles.induct) auto
+proof(induct xs ys rule: shuffles.induct)
+  case (1 ys)
+  then show ?case by auto
+next
+  case (2 xs)
+  then show ?case by auto
+next
+  case (3 x xs y ys)
+  show ?case by (auto simp add: 3)
+qed
 
 lemma splice_in_shuffles [simp, intro]: "splice xs ys \<in> shuffles xs ys"
   by (induction xs ys rule: splice.induct) (simp_all add: Cons_in_shuffles_iff shuffles_commutes)
@@ -5197,20 +5207,29 @@
   (is "max _ ?foldB = Suc (max _ ?foldA)")
 proof (cases "(filter (\<lambda>ys. ys \<noteq> []) xss) = []")
   case True
-  hence "foldr (\<lambda>xs. max (length xs)) xss 0 = 0"
+  then show ?thesis 
   proof (induct xss)
-    case (Cons x xs)
-    then have "x = []" by (cases x) auto
-    with Cons show ?case by auto
-  qed simp
-  thus ?thesis using True by simp
+    case Nil
+    then show ?case by simp
+  next
+    case (Cons a xsss)
+    then show ?case 
+      by (cases a; simp add: filter_def)
+  qed
 next
   case False
 
   have foldA: "?foldA = foldr (\<lambda>x. max (length x)) (filter (\<lambda>ys. ys \<noteq> []) xss) 0 - 1"
-    by (induct xss) auto
+  proof(induct xss)
+    case Nil
+    then show ?case by simp
+  next
+    case IH: (Cons a xss)
+    then show ?case by (cases a; simp add: filter_def)
+  qed
+
   have foldB: "?foldB = foldr (\<lambda>x. max (length x)) (filter (\<lambda>ys. ys \<noteq> []) xss) 0"
-    by (induct xss) auto
+    by (induct xss; simp) 
 
   have "0 < ?foldB"
   proof -
@@ -6363,7 +6382,7 @@
 
 lemma sorted_list_of_set_lessThan_Suc [simp]:
   "sorted_list_of_set {..<Suc k} = sorted_list_of_set {..<k} @ [k]"
-  using le0 lessThan_atLeast0 sorted_list_of_set_range upt_Suc_append by presburger
+  using lessThan_atLeast0 by auto
 
 lemma sorted_list_of_set_atMost_Suc [simp]:
   "sorted_list_of_set {..Suc k} = sorted_list_of_set {..k} @ [Suc k]"
@@ -6835,7 +6854,7 @@
     by blast
   hence "((u@v)!i, (w@z)!i) \<in> r"
     unfolding nth_append using less_le_trans[OF \<open>i < length w\<close> assms(2)] \<open>(u!i,w!i) \<in> r\<close>
-    by presburger
+    by auto
   moreover have "i < min (length (u@v)) (length (w@z))"
     using assms(2) \<open>i < length w\<close> by simp
   moreover have "take i (u@v) = take i (w@z)"
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/MacLaurin.thy /home/blanqui/trash/isabelle/src/HOL/MacLaurin.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/MacLaurin.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/MacLaurin.thy	2023-05-30 17:07:25.262895275 +0900
@@ -22,7 +22,7 @@
 
 lemma eq_diff_eq': "x = y - z \<longleftrightarrow> y = x + z"
   for x y z :: real
-  by arith
+  by (auto elim: iffE)
 
 lemma fact_diff_Suc: "n < Suc m \<Longrightarrow> fact (Suc m - n) = (Suc m - n) * fact (m - n)"
   by (subst fact_reduce) auto
@@ -343,25 +343,37 @@
 lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
 
+lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "even m")
+  case t: True
+    then show ?thesis by (simp add: sin_coeff_def sin_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: sin_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_sin_expansion2:
   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
 proof (cases "n = 0 \<or> x = 0")
+  case True
+  then show ?thesis by auto
+next
   case False
-  let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
-  have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
+    let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
+    have tex: "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
       (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
-  proof (rule Maclaurin_all_lt)
-    show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
+    proof (rule Maclaurin_all_lt)
+      show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
            sin (x + 1/2 * real (Suc m) * pi)) (at x)"
-      by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
-  qed (use False in auto)
-  then show ?thesis
-    apply (rule ex_forward, simp)
-    apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
-qed auto
+        by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
+    qed (use False in auto)
+    from tex show ?thesis
+      apply (rule ex_forward, simp)
+      apply (rule sum.cong[OF refl])
+      by (simp add: sin_coeff_lemma)
+  qed
 
 lemma Maclaurin_sin_expansion:
   "\<exists>t. sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -385,8 +397,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 lemma Maclaurin_sin_expansion4:
@@ -406,8 +417,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 
@@ -419,6 +429,16 @@
 lemma cos_expansion_lemma: "cos (x + real (Suc m) * pi / 2) = - sin (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add distrib_right add_divide_distrib)
 
+lemma cos_coeff_lemma: "cos_coeff m * x ^ m  = cos (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "odd m")
+  case t: True
+    then show ?thesis by (simp add: cos_coeff_def cos_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: cos_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_cos_expansion:
   "\<exists>t::real. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     cos x = (\<Sum>m<n. cos_coeff m * x ^ m) + (cos(t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -436,8 +456,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE simp del: of_nat_Suc)
-    done
+    by (simp add: cos_coeff_lemma)
 qed auto
 
 lemma Maclaurin_cos_expansion2:
@@ -456,8 +475,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 lemma Maclaurin_minus_cos_expansion:
@@ -476,8 +494,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 
@@ -537,7 +554,7 @@
   shows "\<exists>t::real. c < t \<and> t < b \<and>
     f b = (\<Sum>m<n. (diff m c / fact m) * (b - c)^m) + (diff n t / fact n) * (b - c)^n"
 proof -
-  from INTERV have "0 < b - c" by arith
+  from INTERV have "0 < b - c" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -573,7 +590,7 @@
   shows "\<exists>t. a < t \<and> t < c \<and>
     f a = (\<Sum>m<n. (diff m c / fact m) * (a - c)^m) + (diff n t / fact n) * (a - c)^n"
 proof -
-  from INTERV have "a-c < 0" by arith
+  from INTERV have "a-c < 0" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -627,9 +644,9 @@
   moreover have "\<forall>m t. m < n \<and> a \<le> t \<and> t \<le> x \<longrightarrow> DERIV (diff m) t :> diff (Suc m) t"
     using DERIV and INTERV by fastforce
   moreover from INTERV have "a \<le> c"
-    by arith
+    by simp
   moreover from False and INTERV have "c < x"
-    by arith
+    by simp
   ultimately have "\<exists>t>c. t < x \<and> f x =
     (\<Sum>m<n. diff m c / (fact m) * (x - c) ^ m) + diff n t / (fact n) * (x - c) ^ n"
     by (rule Taylor_up)
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Main.thy /home/blanqui/trash/isabelle/src/HOL/Main.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Main.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Main.thy	2023-05-30 17:07:44.290281217 +0900
@@ -8,10 +8,10 @@
 theory Main
   imports
     Predicate_Compile
-    Quickcheck_Narrowing
+    (*Quickcheck_Narrowing*)
     Mirabelle
     Extraction
-    Nunchaku
+    (*Nunchaku*)
     BNF_Greatest_Fixpoint
     Filter
     Conditionally_Complete_Lattices
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Nitpick.thy /home/blanqui/trash/isabelle/src/HOL/Nitpick.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Nitpick.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Nitpick.thy	2023-05-30 17:07:25.262895275 +0900
@@ -8,7 +8,7 @@
 section \<open>Nitpick: Yet Another Counterexample Generator for Isabelle/HOL\<close>
 
 theory Nitpick
-imports Record GCD
+imports Record GCD Sledgehammer
 keywords
   "nitpick" :: diag and
   "nitpick_params" :: thy_decl
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Predicate_Compile.thy /home/blanqui/trash/isabelle/src/HOL/Predicate_Compile.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Predicate_Compile.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Predicate_Compile.thy	2023-05-30 17:07:25.266895971 +0900
@@ -1,11 +1,7 @@
-(*  Title:      HOL/Predicate_Compile.thy
-    Author:     Stefan Berghofer, Lukas Bulwahn, Florian Haftmann, TU Muenchen
-*)
-
 section \<open>A compiler for predicates defined by introduction rules\<close>
 
 theory Predicate_Compile
-imports Random_Sequence Quickcheck_Exhaustive
+imports Random_Sequence Random_Prep (*Quickcheck_Exhaustive*)
 keywords
   "code_pred" :: thy_goal and
   "values" :: diag
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Quickcheck_Exhaustive.thy /home/blanqui/trash/isabelle/src/HOL/Quickcheck_Exhaustive.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Quickcheck_Exhaustive.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Quickcheck_Exhaustive.thy	2023-05-30 17:07:25.266895971 +0900
@@ -15,14 +15,14 @@
   where [code_unfold]: "x orelse y = (case x of Some x' \<Rightarrow> Some x' | None \<Rightarrow> y)"
 
 
-subsection \<open>Exhaustive generator type classes\<close>
+(*subsection \<open>Exhaustive generator type classes\<close>
 
 class exhaustive = term_of +
   fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
 
 class full_exhaustive = term_of +
   fixes full_exhaustive ::
-    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"*)
 
 instantiation natural :: full_exhaustive
 begin
@@ -226,7 +226,7 @@
      else
       f valterm_emptyset orelse
       full_exhaustive_set
-        (\<lambda>A. f A orelse Quickcheck_Exhaustive.full_exhaustive
+        (\<lambda>A. f A orelse Random_Prep.full_exhaustive
           (\<lambda>x. if fst x \<in> fst A then None else f (valtermify_insert x A)) (i - 1)) (i - 1))"
 
 instance ..
@@ -649,7 +649,7 @@
     (Quickcheck) "(((_); NONE) handle Exhaustive'_Generators.Counterexample ts \<Rightarrow> SOME ts)"
 
 
-subsection \<open>Continuation passing style functions as plus monad\<close>
+(*subsection \<open>Continuation passing style functions as plus monad\<close>
 
 type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
 
@@ -731,7 +731,7 @@
 
 definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
   where "pos_bound_cps_not n =
-    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"*)
 
 
 subsection \<open>Defining generators for any first-order data type\<close>
@@ -766,13 +766,13 @@
   check_all enum_term_of
   orelse unknown mk_map_term check_all_n_lists check_all_subsets
 
-hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+(*hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
 
 hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
   pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
   pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
   neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
   neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
-  Unknown Known Unknown_value Value No_value
+  Unknown Known Unknown_value Value No_value*)
 
 end
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Quickcheck_Random.thy /home/blanqui/trash/isabelle/src/HOL/Quickcheck_Random.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Quickcheck_Random.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Quickcheck_Random.thy	2023-05-30 17:52:51.730260928 +0900
@@ -5,7 +5,7 @@
 section \<open>A simple counterexample generator performing random testing\<close>
 
 theory Quickcheck_Random
-imports Random Code_Evaluation Enum
+  imports Random_Prep
 begin
 
 setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>
@@ -19,7 +19,7 @@
 
 code_reserved Quickcheck Match
 
-subsection \<open>The \<open>random\<close> class\<close>
+(*subsection \<open>The \<open>random\<close> class\<close>
 
 class random = typerep +
   fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
@@ -182,7 +182,7 @@
 
 instance ..
 
-end
+end*)
 
 text \<open>Towards type copies and datatypes\<close>
 
@@ -213,7 +213,7 @@
 
 end
 
-instantiation set :: (random) random
+instantiation set :: (Random_Prep.random) Random_Prep.random
 begin
 
 context
@@ -227,12 +227,13 @@
     collapse (Random.select_weight
       [(1, Pair valterm_emptyset),
        (Code_Numeral.Suc i,
-        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+        Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
 
 lemma [code]:
   "random_aux_set i j =
     collapse (Random.select_weight [(1, Pair valterm_emptyset),
-      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+      (i, Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
 proof (induct i rule: natural.induct)
   case zero
   show ?case by (subst select_weight_drop_zero [symmetric])
@@ -259,6 +260,10 @@
 
 subsection \<open>Deriving random generators for datatypes\<close>
 
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
 ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
 ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
 
@@ -266,15 +271,15 @@
 subsection \<open>Code setup\<close>
 
 code_printing
-  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  constant Random_Prep.random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
   \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
   for this reason we use a distinguished target \<open>Quickcheck\<close>
   not spoiling the regular trusted code generation\<close>
 
 code_reserved Quickcheck Random_Generators
 
-hide_const (open) catch_match random collapse beyond random_fun_aux random_fun_lift
+hide_const (open) catch_match random collapse beyond (*random_fun_aux random_fun_lift*)
 
-hide_fact (open) collapse_def beyond_def random_fun_lift_def
+hide_fact (open) collapse_def beyond_def (*random_fun_lift_def*)
 
 end
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Random_Pred.thy /home/blanqui/trash/isabelle/src/HOL/Random_Pred.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Random_Pred.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Random_Pred.thy	2023-05-30 17:07:25.266895971 +0900
@@ -4,13 +4,13 @@
 section \<open>The Random-Predicate Monad\<close>
 
 theory Random_Pred
-imports Quickcheck_Random
+imports Random_Prep
 begin
 
 fun iter' :: "'a itself \<Rightarrow> natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
 where
   "iter' T nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter' T (nrandom - 1) sz seed')))"
 
 definition iter :: "natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
@@ -19,7 +19,7 @@
 
 lemma [code]:
   "iter nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter (nrandom - 1) sz seed')))"
    unfolding iter_def iter'.simps [of _ nrandom] ..
 
Seulement dans /home/blanqui/trash/isabelle/src/HOL: Random_Prep.thy
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Rat.thy /home/blanqui/trash/isabelle/src/HOL/Rat.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Rat.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Rat.thy	2023-05-30 17:07:25.266895971 +0900
@@ -1010,7 +1010,7 @@
   by (cases p) (simp add: quotient_of_Fract of_rat_rat)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1129,7 +1129,7 @@
   inverse_rat_inst.inverse_rat
   one_rat_inst.one_rat ord_rat_inst.less_rat
   ord_rat_inst.less_eq_rat plus_rat_inst.plus_rat times_rat_inst.times_rat
-  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat
+  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat*)
 
 
 subsection \<open>Float syntax\<close>
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Real.thy /home/blanqui/trash/isabelle/src/HOL/Real.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Real.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Real.thy	2023-05-30 17:07:44.298282169 +0900
@@ -1655,7 +1655,7 @@
       of_int_floor_le of_rat_of_int_eq real_less_eq_code)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1731,7 +1731,7 @@
 lemmas [nitpick_unfold] = inverse_real_inst.inverse_real one_real_inst.one_real
   ord_real_inst.less_real ord_real_inst.less_eq_real plus_real_inst.plus_real
   times_real_inst.times_real uminus_real_inst.uminus_real
-  zero_real_inst.zero_real
+  zero_real_inst.zero_real*)
 
 
 subsection \<open>Setup for SMT\<close>
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/String.thy /home/blanqui/trash/isabelle/src/HOL/String.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/String.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/String.thy	2023-05-30 17:07:44.306283121 +0900
@@ -698,9 +698,9 @@
 
 lemma [code]:
   \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
-    [foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
+    [foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
 proof -
-  have \<open>foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
+  have \<open>foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
     by simp
   moreover have \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
     [of_char (Char b0 b1 b2 b3 b4 b5 b6 False)] + s\<close>
Seulement dans /home/blanqui/trash/isabelle/src/HOL/TLA: README.html
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML /home/blanqui/trash/isabelle/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-30 17:07:25.278898061 +0900
@@ -76,21 +76,21 @@
       (Type ("fun", [Type ("fun", [T, \<^typ>\<open>term list option\<close>]), \<^typ>\<open>term list option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
@@ -98,7 +98,7 @@
 fun mk_not t =
   let
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_not\<close>, T --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.cps_not\<close>, T --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -127,33 +127,33 @@
   \<^typ>\<open>natural => (bool * term list) option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], [])
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.pos_bound_cps_plus\<close>
 
 fun mk_if cond =
-  Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_if\<close>,
+  Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_if\<close>,
     HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
 
 fun mk_not t =
   let
-    val nT = \<^typ>\<open>(unit Quickcheck_Exhaustive.unknown =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued) => natural =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+    val nT = \<^typ>\<open>(unit Random_Prep.unknown =>
+      Code_Evaluation.term list Random_Prep.three_valued) => natural =>
+      Code_Evaluation.term list Random_Prep.three_valued\<close>
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_not\<close>, nT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_not\<close>, nT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -176,31 +176,31 @@
 struct
 
 fun mk_monadT T =
-  (Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T])
-    --> \<^typ>\<open>Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>)
-    --> \<^typ>\<open>natural => Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+  (Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T])
+    --> \<^typ>\<open>Code_Evaluation.term list Random_Prep.three_valued\<close>)
+    --> \<^typ>\<open>natural => Code_Evaluation.term list Random_Prep.three_valued\<close>
 
 fun dest_monadT
-    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T]),
-      \<^typ>\<open>term list Quickcheck_Exhaustive.three_valued\<close>]),
-      \<^typ>\<open>natural => term list Quickcheck_Exhaustive.three_valued\<close>])) = T
+    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T]),
+      \<^typ>\<open>term list Random_Prep.three_valued\<close>]),
+      \<^typ>\<open>natural => term list Random_Prep.three_valued\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.neg_bound_cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented"
@@ -210,7 +210,7 @@
     val T = mk_monadT HOLogic.unitT
     val pT = \<^typ>\<open>(unit => (bool * Code_Evaluation.term list) option)\<close>
       --> \<^typ>\<open>natural => (bool * Code_Evaluation.term list) option\<close>
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_not\<close>, pT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_not\<close>, pT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML /home/blanqui/trash/isabelle/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-30 17:07:25.278898061 +0900
@@ -435,7 +435,7 @@
   compfuns = Random_Sequence_CompFuns.compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -472,7 +472,7 @@
   compfuns = New_Pos_Random_Sequence_CompFuns.depth_limited_compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -536,7 +536,7 @@
   compfuns = Pos_Bounded_CPS_Comp_Funs.compfuns,
   mk_random =
     (fn T => fn _ =>
-       Const (\<^const_name>\<open>Quickcheck_Exhaustive.exhaustive\<close>,
+       Const (\<^const_name>\<open>Random_Prep.exhaustive\<close>,
        (T --> \<^typ>\<open>(bool * term list) option\<close>) -->
          \<^typ>\<open>natural => (bool * term list) option\<close>)),
   modify_funT = I,
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Tools/Quickcheck/random_generators.ML /home/blanqui/trash/isabelle/src/HOL/Tools/Quickcheck/random_generators.ML
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Tools/Quickcheck/random_generators.ML	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Tools/Quickcheck/random_generators.ML	2023-05-30 17:07:25.278898061 +0900
@@ -204,7 +204,7 @@
         val T = Type (tyco, Ts);
         fun mk_random_fun_lift [] t = t
           | mk_random_fun_lift (fT :: fTs) t =
-              mk_const \<^const_name>\<open>random_fun_lift\<close> [fTs ---> T, fT] $
+              mk_const \<^const_name>\<open>Random_Prep.random_fun_lift\<close> [fTs ---> T, fT] $
                 mk_random_fun_lift fTs t;
         val t = mk_random_fun_lift fTs (nth random_auxs k $ size_pred $ size');
         val size = Option.map snd (Old_Datatype_Aux.find_shortest_path descr k)
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Tools/SMT: cvc4_interface.ML
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Tools/SMT: cvc4_proof_parse.ML
Seulement dans /home/blanqui/trash/isabelle/src/HOL/Tools/SMT: verit_proof.ML
Seulement dans /home/blanqui/trash/isabelle/src/HOL: Transcendental_fol.thy
diff -ru /home/blanqui/src/Isabelle2022-origin/src/HOL/Transcendental.thy /home/blanqui/trash/isabelle/src/HOL/Transcendental.thy
--- /home/blanqui/src/Isabelle2022-origin/src/HOL/Transcendental.thy	2022-10-25 03:37:32.000000000 +0900
+++ /home/blanqui/trash/isabelle/src/HOL/Transcendental.thy	2023-05-30 17:07:25.286899453 +0900
@@ -3422,12 +3422,14 @@
     have "(-1) ^ ((n - Suc 0) div 2) * (-1) ^ ((p - Suc n) div 2) = - ((-1 :: real) ^ (p div 2))"
       if np: "odd n" "even p"
     proof -
-      have "p > 0"
-        using \<open>n \<le> p\<close> neq0_conv that(1) by blast
+      have n1: "Suc 0 \<le>  n" using odd_pos[OF that(1)] by simp
+      have opn: "odd (p - n)" using np \<open>n \<le> p\<close> by simp
+      have snp: "Suc n \<le> p" using odd_pos[OF opn] by simp
+      then have p2: "2 \<le> p" using \<open>n \<le> p\<close> that(2) by (auto elim: oddE)
       then have \<section>: "(- 1::real) ^ (p div 2 - Suc 0) = - ((- 1) ^ (p div 2))"
-        using \<open>even p\<close> by (auto simp add: dvd_def power_eq_if)
-      from \<open>n \<le> p\<close> np have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" "Suc (Suc 0) \<le> p"
-        by arith+
+        by (simp add: power_eq_if)
+      from n1 p2 snp have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" 
+        by simp
       have "(p - Suc (Suc 0)) div 2 = p div 2 - Suc 0"
         by simp
       with \<open>n \<le> p\<close> np  \<section> * show ?thesis
Seulement dans /home/blanqui/trash/isabelle/src/HOL/UNITY/Comp: README.html
Seulement dans /home/blanqui/trash/isabelle/src/HOL/UNITY: README.html
Seulement dans /home/blanqui/trash/isabelle/src/HOL/UNITY/Simple: README.html
