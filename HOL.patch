diff -urN ./Bit_Operations.thy /cygdrive/c/Isabelle2022/src/HOL/Bit_Operations.thy
--- ./Bit_Operations.thy	2023-05-30 11:49:54.099652200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Bit_Operations.thy	2023-05-31 14:26:38.861397700 +0900
@@ -2048,7 +2048,8 @@
 lemma and_int_unfold:
   \<open>k AND l = (if k = 0 \<or> l = 0 then 0 else if k = - 1 then l else if l = - 1 then k
     else (k mod 2) * (l mod 2) + 2 * ((k div 2) AND (l div 2)))\<close> for k l :: int
-  by (auto simp add: and_int_rec [of k l] zmult_eq_1_iff elim: oddE)
+  apply (auto split: if_splits)
+  by (simp add: and_int_rec[of k l] odd_iff_mod_2_eq_one)
 
 lemma or_int_unfold:
   \<open>k OR l = (if k = - 1 \<or> l = - 1 then - 1 else if k = 0 then l else if l = 0 then k
@@ -2058,7 +2059,9 @@
 lemma xor_int_unfold:
   \<open>k XOR l = (if k = - 1 then NOT l else if l = - 1 then NOT k else if k = 0 then l else if l = 0 then k
     else \<bar>k mod 2 - l mod 2\<bar> + 2 * ((k div 2) XOR (l div 2)))\<close> for k l :: int
-  by (auto simp add: xor_int_rec [of k l] not_int_def elim!: oddE)
+  apply (auto split: if_splits)
+  apply (simp add: xor_int_rec[of k l] odd_iff_mod_2_eq_one)
+  by auto
 
 lemma bit_minus_int_iff:
   \<open>bit (- k) n \<longleftrightarrow> bit (NOT (k - 1)) n\<close>
diff -urN ./Enum.thy /cygdrive/c/Isabelle2022/src/HOL/Enum.thy
--- ./Enum.thy	2023-05-30 11:50:42.024180400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Enum.thy	2023-05-31 14:26:38.861397700 +0900
@@ -447,7 +447,7 @@
 
  
 instance
-  by standard
+  by intro_classes
     (simp_all add: enum_prod_def distinct_product
       enum_UNIV enum_distinct enum_all_prod_def enum_ex_prod_def)
 
@@ -489,6 +489,109 @@
 
 end
 
+class finite_lattice = finite +  lattice + Inf + Sup  + bot + top +
+  assumes Inf_finite_empty: "Inf {} = Sup UNIV"
+  assumes Inf_finite_insert: "Inf (insert a A) = a \<sqinter> Inf A"
+  assumes Sup_finite_empty: "Sup {} = Inf UNIV"
+  assumes Sup_finite_insert: "Sup (insert a A) = a \<squnion> Sup A"
+  assumes bot_finite_def: "bot = Inf UNIV"
+  assumes top_finite_def: "top = Sup UNIV"
+begin
+
+subclass complete_lattice
+proof
+  fix x A
+  show "x \<in> A \<Longrightarrow> \<Sqinter>A \<le> x"
+    by (metis Set.set_insert abel_semigroup.commute local.Inf_finite_insert local.inf.abel_semigroup_axioms local.inf.left_idem local.inf.orderI)
+  show "x \<in> A \<Longrightarrow> x \<le> \<Squnion>A"
+    by (metis Set.set_insert insert_absorb2 local.Sup_finite_insert local.sup.absorb_iff2)
+next
+  fix A z
+  have "\<Squnion> UNIV = z \<squnion> \<Squnion>UNIV"
+    by (subst Sup_finite_insert [symmetric], simp add: insert_UNIV)
+  from this have [simp]: "z \<le> \<Squnion>UNIV"
+    using local.le_iff_sup by auto
+  have "(\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"
+    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"])
+      (simp_all add: Inf_finite_empty Inf_finite_insert)
+  from this show "(\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow> z \<le> \<Sqinter>A"
+    by simp
+
+  have "\<Sqinter> UNIV = z \<sqinter> \<Sqinter>UNIV"
+    by (subst Inf_finite_insert [symmetric], simp add: insert_UNIV)
+  from this have [simp]: "\<Sqinter>UNIV \<le> z"
+    by (simp add: local.inf.absorb_iff2)
+  have "(\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z"
+    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z" ], simp_all add: Sup_finite_empty Sup_finite_insert)
+  from this show " (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow> \<Squnion>A \<le> z"
+    by blast
+next
+  show "\<Sqinter>{} = \<top>"
+    by (simp add: Inf_finite_empty top_finite_def)
+  show " \<Squnion>{} = \<bottom>"
+    by (simp add: Sup_finite_empty bot_finite_def)
+qed
+end
+
+class finite_distrib_lattice = finite_lattice + distrib_lattice 
+begin
+lemma finite_inf_Sup: "a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"
+proof (rule finite_induct [of A "\<lambda> A . a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"], simp_all)
+  fix x::"'a"
+  fix F
+  assume "x \<notin> F"
+  assume [simp]: "a \<sqinter> \<Squnion>F = \<Squnion>{a \<sqinter> b |b. b \<in> F}"
+  have [simp]: " insert (a \<sqinter> x) {a \<sqinter> b |b. b \<in> F} = {a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by blast
+  have "a \<sqinter> (x \<squnion> \<Squnion>F) = a \<sqinter> x \<squnion> a \<sqinter> \<Squnion>F"
+    by (simp add: inf_sup_distrib1)
+  also have "... = a \<sqinter> x \<squnion> \<Squnion>{a \<sqinter> b |b. b \<in> F}"
+    by simp
+  also have "... = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by (unfold Sup_insert[THEN sym], simp)
+  finally show "a \<sqinter> (x \<squnion> \<Squnion>F) = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
+    by simp
+qed
+
+lemma finite_Inf_Sup: "\<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"
+proof (rule finite_induct [of A "\<lambda>A. \<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"], simp_all add: finite_UnionD)
+  fix x::"'a set"
+  fix F
+  assume "x \<notin> F"
+  have [simp]: "{\<Squnion>x \<sqinter> b |b . b \<in> Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y} } = {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  . (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by auto
+  define fa where "fa = (\<lambda> (b::'a) f Y . (if Y = x then b else f Y))"
+  have "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> insert b (f ` (F \<inter> {Y. Y \<noteq> x})) = insert (fa b f x) (fa b f ` F) \<and> fa b f x \<in> x \<and> (\<forall>Y\<in>F. fa b f Y \<in> Y)"
+    by (auto simp add: fa_def)
+  from this have B: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> fa b f ` ({x} \<union> F) \<in> {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by blast
+  have [simp]: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> b \<sqinter> (\<Sqinter>x\<in>F. f x)  \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    using B apply (rule SUP_upper2)
+    using \<open>x \<notin> F\<close> apply (simp_all add: fa_def Inf_union_distrib)
+    apply (simp add: image_mono Inf_superset_mono inf.coboundedI2)
+    done
+  assume "\<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
+
+  from this have "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>x \<sqinter> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
+    using inf.coboundedI2 by auto
+  also have "... = Sup {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by (simp add: finite_inf_Sup)
+
+  also have "... = Sup {Sup {Inf (f ` F) \<sqinter> b | b . b \<in> x} |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
+    by (subst inf_commute) (simp add: finite_inf_Sup)
+
+  also have "... \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    apply (rule Sup_least, clarsimp)+
+    apply (subst inf_commute, simp)
+    done
+
+  finally show "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
+    by simp
+qed
+
+subclass complete_distrib_lattice
+  by (standard, rule finite_Inf_Sup)
+end
 
 subsection \<open>Small finite types\<close>
 
@@ -682,7 +785,7 @@
 
 instance finite_2 :: complete_distrib_lattice ..
 
-instantiation finite_2 :: "{field, idom_abs_sgn, idom_modulo}" begin
+instantiation finite_2 :: field begin
 definition [simp]: "0 = a\<^sub>1"
 definition [simp]: "1 = a\<^sub>2"
 definition "x + y = (case (x, y) of (a\<^sub>1, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>1 | _ \<Rightarrow> a\<^sub>2)"
@@ -691,17 +794,51 @@
 definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> a\<^sub>1)"
 definition "inverse = (\<lambda>x :: finite_2. x)"
 definition "divide = ((*) :: finite_2 \<Rightarrow> _)"
+
+instance
+proof(intro_classes)
+  fix a b c :: finite_2
+  show "a + b + c = a + (b + c)" 
+    by (cases a; cases b; cases c; simp add: plus_finite_2_def)
+  show "0 + a = a" by (cases a; simp add: plus_finite_2_def)
+  show "-a + a = 0" by (cases a; simp add: plus_finite_2_def uminus_finite_2_def)
+  show "a - b = a + -b" by (simp add: minus_finite_2_def uminus_finite_2_def)
+  show "a * b * c = a * (b * c)" by (cases a; cases b; cases c; simp add: times_finite_2_def)
+  show "a * b = b * a" by (cases a; cases b; simp add: times_finite_2_def)
+  show "1 * a = a" by (cases a; simp add: times_finite_2_def)
+  show "a + b = b + a" by (cases a; cases b; simp add: plus_finite_2_def)
+  show "(a + b) * c = a * c + b * c" 
+    by (cases a; cases b; cases c; simp add: plus_finite_2_def times_finite_2_def)
+  show "(0::finite_2) \<noteq> 1" by simp
+  show "a \<noteq> 0 \<Longrightarrow> inverse a * a = 1" 
+    by (cases a; simp add: times_finite_2_def inverse_finite_2_def)
+  show "a div b = a * inverse b" by (simp add: divide_finite_2_def inverse_finite_2_def)
+  show "inverse (0::finite_2) = 0" by (simp add: inverse_finite_2_def)
+qed
+  
+end
+
+instantiation finite_2 :: "{idom_abs_sgn, idom_modulo}" begin
 definition "x mod y = (case (x, y) of (a\<^sub>2, a\<^sub>1) \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x :: finite_2. x)"
 definition "sgn = (\<lambda>x :: finite_2. x)"
+
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_2_def uminus_finite_2_def minus_finite_2_def
-        times_finite_2_def
-        inverse_finite_2_def divide_finite_2_def modulo_finite_2_def
-        abs_finite_2_def sgn_finite_2_def
-        split: finite_2.splits\<close>)
+proof(intro_classes)
+  fix a b :: finite_2
+  show "sgn a * \<bar>a\<bar> = a" by (cases a; simp add: abs_finite_2_def sgn_finite_2_def)
+  show "sgn (sgn a) = sgn a" by (simp add: sgn_finite_2_def)
+  show "\<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>" by (cases a; simp add: abs_finite_2_def)
+  show "\<bar>(0::finite_2)\<bar> = 0" by (simp add: abs_finite_2_def)
+  show "sgn (0::finite_2) = 0" by (simp add: sgn_finite_2_def)
+  show "sgn (1::finite_2) = 1" by (simp add: sgn_finite_2_def)
+  show "sgn (- (1::finite_2)) = - 1" by (simp add: sgn_finite_2_def)
+  show "sgn (a * b) = sgn a * sgn b" by (simp add: sgn_finite_2_def)
+  show "a / b * b + a mod b = a" 
+    by (cases a; cases b; 
+        simp add: plus_finite_2_def times_finite_2_def modulo_finite_2_def 
+          divide_finite_2_def inverse_finite_2_def)
+qed
 end
 
 lemma two_finite_2 [simp]:
@@ -710,18 +847,46 @@
 
 lemma dvd_finite_2_unfold:
   "x dvd y \<longleftrightarrow> x = a\<^sub>2 \<or> y = a\<^sub>1"
-  by (auto simp add: dvd_def times_finite_2_def split: finite_2.splits)
+proof(unfold dvd_def)
+  fix x y :: finite_2
+  have "(\<exists>k. y = x * k) = (y = x * a\<^sub>1 \<or> y = x * a\<^sub>2)" 
+    using exists_code[of "\<lambda>k. y = x * k"] enum_ex_finite_2_def[of "\<lambda>k. y = x * k"] by auto
+  then show "(\<exists>k. y = x * k) = (x = a\<^sub>2 \<or> y = a\<^sub>1)"
+    by (cases x; cases y; simp add: enum_ex_finite_2_def times_finite_2_def)
+qed
 
 instantiation finite_2 :: "{normalization_semidom, unique_euclidean_semiring}" begin
 definition [simp]: "normalize = (id :: finite_2 \<Rightarrow> _)"
 definition [simp]: "unit_factor = (id :: finite_2 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | a\<^sub>2 \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_2) = 1"
+
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: divide_finite_2_def times_finite_2_def dvd_finite_2_unfold
-        split: finite_2.splits\<close>)
+proof(intro_classes)
+  fix a b r :: finite_2
+  show "euclidean_size (0::finite_2) = 0" by simp
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size (a mod b) < euclidean_size b" 
+    by (cases a; cases b; simp add:  modulo_finite_2_def)
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size a \<le> euclidean_size (a * b)"
+    by (cases a; cases b; simp add:  times_finite_2_def)
+  show "euclidean_size (a * b) =  euclidean_size a * euclidean_size b"
+    by (cases a; cases b; simp add:  times_finite_2_def)
+  show "is_unit (division_segment a)" by simp
+  show "a \<noteq> 0 \<Longrightarrow> b \<noteq> 0 \<Longrightarrow> division_segment (a * b) = division_segment a * division_segment b"
+    by (cases a; cases b; simp add:  times_finite_2_def)
+  show "b \<noteq> 0 \<Longrightarrow>  \<not> b dvd a \<Longrightarrow> division_segment (a mod b) = division_segment b"
+    by (simp add: dvd_finite_2_unfold)
+  show "b \<noteq> 0 \<Longrightarrow> division_segment r = division_segment b \<Longrightarrow> 
+          euclidean_size r < euclidean_size b \<Longrightarrow> (a * b + r) / b = a"
+    by (cases b; cases a; cases r; 
+        simp add: divide_finite_2_def inverse_finite_2_def times_finite_2_def plus_finite_2_def)
+  show "unit_factor (0::finite_2) = 0" by simp
+  show "is_unit a \<Longrightarrow> unit_factor a = a" by simp
+  show "a \<noteq> 0 \<Longrightarrow> is_unit (unit_factor a)" by (cases a; simp add: dvd_finite_2_unfold)
+  show "is_unit a \<Longrightarrow> unit_factor (a * b) =  a * unit_factor b" by simp
+  show "unit_factor a * normalize a = a" by (cases a; simp)
+  show "normalize (0::finite_2) = 0" by simp
+qed
 end
 
  
@@ -784,109 +949,7 @@
   from this[symmetric] show "wf \<dots>" by simp
 qed intro_classes
 
-class finite_lattice = finite +  lattice + Inf + Sup  + bot + top +
-  assumes Inf_finite_empty: "Inf {} = Sup UNIV"
-  assumes Inf_finite_insert: "Inf (insert a A) = a \<sqinter> Inf A"
-  assumes Sup_finite_empty: "Sup {} = Inf UNIV"
-  assumes Sup_finite_insert: "Sup (insert a A) = a \<squnion> Sup A"
-  assumes bot_finite_def: "bot = Inf UNIV"
-  assumes top_finite_def: "top = Sup UNIV"
-begin
-
-subclass complete_lattice
-proof
-  fix x A
-  show "x \<in> A \<Longrightarrow> \<Sqinter>A \<le> x"
-    by (metis Set.set_insert abel_semigroup.commute local.Inf_finite_insert local.inf.abel_semigroup_axioms local.inf.left_idem local.inf.orderI)
-  show "x \<in> A \<Longrightarrow> x \<le> \<Squnion>A"
-    by (metis Set.set_insert insert_absorb2 local.Sup_finite_insert local.sup.absorb_iff2)
-next
-  fix A z
-  have "\<Squnion> UNIV = z \<squnion> \<Squnion>UNIV"
-    by (subst Sup_finite_insert [symmetric], simp add: insert_UNIV)
-  from this have [simp]: "z \<le> \<Squnion>UNIV"
-    using local.le_iff_sup by auto
-  have "(\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"
-    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> z \<le> x) \<longrightarrow> z \<le> \<Sqinter>A"])
-      (simp_all add: Inf_finite_empty Inf_finite_insert)
-  from this show "(\<And>x. x \<in> A \<Longrightarrow> z \<le> x) \<Longrightarrow> z \<le> \<Sqinter>A"
-    by simp
-
-  have "\<Sqinter> UNIV = z \<sqinter> \<Sqinter>UNIV"
-    by (subst Inf_finite_insert [symmetric], simp add: insert_UNIV)
-  from this have [simp]: "\<Sqinter>UNIV \<le> z"
-    by (simp add: local.inf.absorb_iff2)
-  have "(\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z"
-    by (rule finite_induct [of A "\<lambda> A . (\<forall> x. x \<in> A \<longrightarrow> x \<le> z) \<longrightarrow> \<Squnion>A \<le> z" ], simp_all add: Sup_finite_empty Sup_finite_insert)
-  from this show " (\<And>x. x \<in> A \<Longrightarrow> x \<le> z) \<Longrightarrow> \<Squnion>A \<le> z"
-    by blast
-next
-  show "\<Sqinter>{} = \<top>"
-    by (simp add: Inf_finite_empty top_finite_def)
-  show " \<Squnion>{} = \<bottom>"
-    by (simp add: Sup_finite_empty bot_finite_def)
-qed
-end
-
-class finite_distrib_lattice = finite_lattice + distrib_lattice 
-begin
-lemma finite_inf_Sup: "a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"
-proof (rule finite_induct [of A "\<lambda> A . a \<sqinter> (Sup A) = Sup {a \<sqinter> b | b . b \<in> A}"], simp_all)
-  fix x::"'a"
-  fix F
-  assume "x \<notin> F"
-  assume [simp]: "a \<sqinter> \<Squnion>F = \<Squnion>{a \<sqinter> b |b. b \<in> F}"
-  have [simp]: " insert (a \<sqinter> x) {a \<sqinter> b |b. b \<in> F} = {a \<sqinter> b |b. b = x \<or> b \<in> F}"
-    by blast
-  have "a \<sqinter> (x \<squnion> \<Squnion>F) = a \<sqinter> x \<squnion> a \<sqinter> \<Squnion>F"
-    by (simp add: inf_sup_distrib1)
-  also have "... = a \<sqinter> x \<squnion> \<Squnion>{a \<sqinter> b |b. b \<in> F}"
-    by simp
-  also have "... = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
-    by (unfold Sup_insert[THEN sym], simp)
-  finally show "a \<sqinter> (x \<squnion> \<Squnion>F) = \<Squnion>{a \<sqinter> b |b. b = x \<or> b \<in> F}"
-    by simp
-qed
-
-lemma finite_Inf_Sup: "\<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"
-proof (rule finite_induct [of A "\<lambda>A. \<Sqinter>(Sup ` A) \<le> \<Squnion>(Inf ` {f ` A |f. \<forall>Y\<in>A. f Y \<in> Y})"], simp_all add: finite_UnionD)
-  fix x::"'a set"
-  fix F
-  assume "x \<notin> F"
-  have [simp]: "{\<Squnion>x \<sqinter> b |b . b \<in> Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y} } = {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  . (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by auto
-  define fa where "fa = (\<lambda> (b::'a) f Y . (if Y = x then b else f Y))"
-  have "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> insert b (f ` (F \<inter> {Y. Y \<noteq> x})) = insert (fa b f x) (fa b f ` F) \<and> fa b f x \<in> x \<and> (\<forall>Y\<in>F. fa b f Y \<in> Y)"
-    by (auto simp add: fa_def)
-  from this have B: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> fa b f ` ({x} \<union> F) \<in> {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by blast
-  have [simp]: "\<And>f b. \<forall>Y\<in>F. f Y \<in> Y \<Longrightarrow> b \<in> x \<Longrightarrow> b \<sqinter> (\<Sqinter>x\<in>F. f x)  \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
-    using B apply (rule SUP_upper2)
-    using \<open>x \<notin> F\<close> apply (simp_all add: fa_def Inf_union_distrib)
-    apply (simp add: image_mono Inf_superset_mono inf.coboundedI2)
-    done
-  assume "\<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
-
-  from this have "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>x \<sqinter> \<Squnion>(Inf ` {f ` F |f. \<forall>Y\<in>F. f Y \<in> Y})"
-    using inf.coboundedI2 by auto
-  also have "... = Sup {\<Squnion>x \<sqinter> (Inf (f ` F)) |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by (simp add: finite_inf_Sup)
-
-  also have "... = Sup {Sup {Inf (f ` F) \<sqinter> b | b . b \<in> x} |f  .  (\<forall>Y\<in>F. f Y \<in> Y)}"
-    by (subst inf_commute) (simp add: finite_inf_Sup)
-
-  also have "... \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
-    apply (rule Sup_least, clarsimp)+
-    apply (subst inf_commute, simp)
-    done
 
-  finally show "\<Squnion>x \<sqinter> \<Sqinter>(Sup ` F) \<le> \<Squnion>(Inf ` {insert (f x) (f ` F) |f. f x \<in> x \<and> (\<forall>Y\<in>F. f Y \<in> Y)})"
-    by simp
-qed
-
-subclass complete_distrib_lattice
-  by (standard, rule finite_Inf_Sup)
-end
 
 instantiation finite_3 :: finite_lattice
 begin
@@ -913,9 +976,8 @@
 
 instance finite_3 :: complete_linorder ..
 
-instantiation finite_3 :: "{field, idom_abs_sgn, idom_modulo}" begin
+instantiation finite_3 :: field begin
 definition [simp]: "0 = a\<^sub>1"
-definition [simp]: "1 = a\<^sub>2"
 definition
   "x + y = (case (x, y) of
      (a\<^sub>1, a\<^sub>1) \<Rightarrow> a\<^sub>1 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>1 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>1
@@ -923,21 +985,56 @@
    | _ \<Rightarrow> a\<^sub>3)"
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>1 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2)"
 definition "x - y = x + (- y :: finite_3)"
+definition [simp]: "1 = a\<^sub>2"
 definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | (a\<^sub>3, a\<^sub>3) \<Rightarrow> a\<^sub>2 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>3 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>3 | _ \<Rightarrow> a\<^sub>1)"
 definition "inverse = (\<lambda>x :: finite_3. x)" 
 definition "x div y = x * inverse (y :: finite_3)"
+
+
+instance
+proof(intro_classes)
+  fix a b c :: finite_3
+  show "a + b + c = a + (b + c)" 
+    by (cases a; cases b; cases c; simp add: plus_finite_3_def)
+  show "0 + a = a" by (cases a; simp add: plus_finite_3_def)
+  show "-a + a = 0" by (cases a; simp add: plus_finite_3_def uminus_finite_3_def)
+  show "a - b = a + -b" by (simp add: minus_finite_3_def)
+  show "a * b * c = a * (b * c)" by (cases a; cases b; cases c; simp add: times_finite_3_def)
+  show "a * b = b * a" by (cases a; cases b; simp add: times_finite_3_def)
+  show "1 * a = a" by (cases a; simp add: times_finite_3_def)
+  show "a + b = b + a" by (cases a; cases b; simp add: plus_finite_3_def)
+  show "(a + b) * c = a * c + b * c" 
+    by (cases a; cases b; cases c; simp add: plus_finite_3_def times_finite_3_def)
+  show "(0::finite_3) \<noteq> 1" by simp
+  show "a \<noteq> 0 \<Longrightarrow> inverse a * a = 1" 
+    by (cases a; simp add: times_finite_3_def inverse_finite_3_def)
+  show "a div b = a * inverse b" by (simp add: divide_finite_3_def)
+  show "inverse (0::finite_3) = 0" by (simp add: inverse_finite_3_def)
+qed
+  
+end
+
+instantiation finite_3 :: "{idom_abs_sgn, idom_modulo}" begin
 definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
-definition "sgn = (\<lambda>x :: finite_3. x)"
+definition "sgn  = (\<lambda>x :: finite_3. x)"
+
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
-        times_finite_3_def
-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
-        abs_finite_3_def sgn_finite_3_def
-        less_finite_3_def
-        split: finite_3.splits\<close>)
+proof(intro_classes)
+  fix a b :: finite_3
+  show "sgn a * \<bar>a\<bar> = a" by (cases a; simp add: abs_finite_3_def sgn_finite_3_def)
+  show "sgn (sgn a) = sgn a" by (simp add: sgn_finite_3_def)
+  show "\<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>" by (cases a; simp add: abs_finite_3_def)
+  show "\<bar>(0::finite_3)\<bar> = 0" by (simp add: abs_finite_3_def)
+  show "sgn (0::finite_3) = 0" by (simp add: sgn_finite_3_def)
+  show "sgn (1::finite_3) = 1" by (simp add: sgn_finite_3_def)
+  show "sgn (- (1::finite_3)) = - 1" by (simp add: sgn_finite_3_def)
+  show "sgn (a * b) = sgn a * sgn b" by (simp add: sgn_finite_3_def)
+  show "a / b * b + a mod b = a" 
+    by (cases a; cases b; 
+        simp add: plus_finite_3_def times_finite_3_def modulo_finite_3_def 
+          divide_finite_3_def inverse_finite_3_def)
+qed
 end
 
 lemma two_finite_3 [simp]:
@@ -946,24 +1043,46 @@
 
 lemma dvd_finite_3_unfold:
   "x dvd y \<longleftrightarrow> x = a\<^sub>2 \<or> x = a\<^sub>3 \<or> y = a\<^sub>1"
-  by (cases x) (auto simp add: dvd_def times_finite_3_def split: finite_3.splits)
+proof(unfold dvd_def)
+  fix x y :: finite_3
+  have "(\<exists>k. y = x * k) = (y = x * a\<^sub>1 \<or> y = x * a\<^sub>2 \<or> y = x * a\<^sub>3)" 
+    using exists_code[of "\<lambda>k. y = x * k"] enum_ex_finite_3_def[of "\<lambda>k. y = x * k"] by auto
+  then show "(\<exists>k. y = x * k) = (x = a\<^sub>2 \<or> x = a\<^sub>3 \<or> y = a\<^sub>1)"
+    by (cases x; cases y; simp add: enum_ex_finite_3_def times_finite_3_def)
+qed
 
 instantiation finite_3 :: "{normalization_semidom, unique_euclidean_semiring}" begin
 definition [simp]: "normalize x = (case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
 definition [simp]: "unit_factor = (id :: finite_3 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | _ \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_3) = 1"
+
 instance
-proof
-  fix x :: finite_3
-  assume "x \<noteq> 0"
-  then show "is_unit (unit_factor x)"
-    by (cases x) (simp_all add: dvd_finite_3_unfold)
-qed
-  (subproofs
-    \<open>auto simp add: divide_finite_3_def times_finite_3_def
-      dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
-      split: finite_3.splits\<close>)
+proof(intro_classes)
+  fix a b r :: finite_3
+  show "euclidean_size (0::finite_3) = 0" by simp
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size (a mod b) < euclidean_size b" 
+    by (cases a; cases b; simp add:  modulo_finite_3_def)
+  show "b \<noteq> 0 \<Longrightarrow> euclidean_size a \<le> euclidean_size (a * b)"
+    by (cases a; cases b; simp add:  times_finite_3_def)
+  show "euclidean_size (a * b) =  euclidean_size a * euclidean_size b"
+    by (cases a; cases b; simp add:  times_finite_3_def)
+  show "is_unit (division_segment a)" by simp
+  show "a \<noteq> 0 \<Longrightarrow> b \<noteq> 0 \<Longrightarrow> division_segment (a * b) = division_segment a * division_segment b"
+    by (cases a; cases b; simp add:  times_finite_3_def)
+  show "b \<noteq> 0 \<Longrightarrow>  \<not> b dvd a \<Longrightarrow> division_segment (a mod b) = division_segment b"
+    by (simp add: dvd_finite_3_unfold)
+  show "b \<noteq> 0 \<Longrightarrow> division_segment r = division_segment b \<Longrightarrow> 
+          euclidean_size r < euclidean_size b \<Longrightarrow> (a * b + r) / b = a"
+    by (cases b; cases a; cases r; 
+        simp add: divide_finite_3_def inverse_finite_3_def times_finite_3_def plus_finite_3_def)
+  show "unit_factor (0::finite_3) = 0" by simp
+  show "is_unit a \<Longrightarrow> unit_factor a = a" by simp
+  show "a \<noteq> 0 \<Longrightarrow> is_unit (unit_factor a)" by (cases a; simp add: dvd_finite_3_unfold)
+  show "is_unit a \<Longrightarrow> unit_factor (a * b) =  a * unit_factor b" by simp
+  show "unit_factor a * normalize a = a" by (cases a; simp)
+  show "normalize (0::finite_3) = 0" by simp
+qed
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3
@@ -1035,10 +1154,39 @@
   | _ \<Rightarrow> a\<^sub>1)"
 
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
-        inf_finite_4_def sup_finite_4_def split: finite_4.splits\<close>)
+proof(intro_classes)
+  fix x y z :: finite_4
+  fix A :: "finite_4 set"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)" 
+    by (cases x; cases y; simp add: less_eq_finite_4_def less_finite_4_def)
+  show "x \<le> x" by (cases x; simp add: less_eq_finite_4_def)
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z" 
+    by (cases x; cases y; cases z; simp add: less_eq_finite_4_def)
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y" 
+    by (cases x; cases y; simp add: less_eq_finite_4_def)
+  show "x \<sqinter> y \<le> x" 
+    by (cases x; cases y; simp add: inf_finite_4_def less_eq_finite_4_def)
+  show "x \<sqinter> y \<le> y" 
+    by (cases x; cases y; simp add: inf_finite_4_def less_eq_finite_4_def)
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> y \<sqinter> z"
+    by (cases x; cases y; cases z; simp add: inf_finite_4_def less_eq_finite_4_def)
+  show "x \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_4_def less_eq_finite_4_def)
+  show "y \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_4_def less_eq_finite_4_def)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> y \<squnion> z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_finite_4_def less_eq_finite_4_def)
+  show "\<Sqinter> ({}:: finite_4 set) = \<Squnion> UNIV" by (simp add: Sup_finite_4_def Inf_finite_4_def)
+  show "\<Sqinter> insert x A = x \<sqinter> \<Sqinter> A"
+    by (cases x; simp add: Inf_finite_4_def inf_finite_4_def)
+  show "\<Squnion> ({}:: finite_4 set) = \<Sqinter> UNIV" by (simp add: Sup_finite_4_def Inf_finite_4_def)
+  show "\<Squnion> insert x A = x \<squnion> \<Squnion> A" 
+    by (cases x; simp add: Sup_finite_4_def sup_finite_4_def)
+  show "(\<bottom>:: finite_4) = \<Sqinter> UNIV" by (simp add: Inf_finite_4_def)
+  show "(\<top>:: finite_4)  = \<Squnion> UNIV" by (simp add: Sup_finite_4_def)
+  show "x \<squnion> y \<sqinter> z = (x \<squnion> y) \<sqinter> (x \<squnion> z)"
+    by (cases x; cases y; cases z; simp add: sup_finite_4_def inf_finite_4_def)
+qed
 end
 
 instance finite_4 :: complete_lattice ..
@@ -1049,14 +1197,17 @@
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>4 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2 | a\<^sub>4 \<Rightarrow> a\<^sub>1)"
 definition "x - y = x \<sqinter> - (y :: finite_4)"
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def 
-        split: finite_4.splits\<close>)
+proof(intro_classes)
+  fix x y :: finite_4
+  show "x \<sqinter> - x = \<bottom>" by (cases x; simp add: uminus_finite_4_def inf_finite_4_def)
+  show "x \<squnion> - x = \<top>" by (cases x; simp add: uminus_finite_4_def sup_finite_4_def)
+  show "x - y = x \<sqinter> - y" by (simp add: minus_finite_4_def)
+qed
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4
 
+
 datatype (plugins only: code "quickcheck" extraction) finite_5 =
   a\<^sub>1 | a\<^sub>2 | a\<^sub>3 | a\<^sub>4 | a\<^sub>5
 
@@ -1139,10 +1290,37 @@
    | _ \<Rightarrow> a\<^sub>1)"
 
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
-        Inf_finite_5_def Sup_finite_5_def split: finite_5.splits if_split_asm\<close>)
+proof(intro_classes)
+  fix x y z :: finite_5
+  fix A :: "finite_5 set"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)" 
+    by (cases x; cases y; simp add: less_eq_finite_5_def less_finite_5_def)
+  show "x \<le> x" by (cases x; simp add: less_eq_finite_5_def)
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z" 
+    by (cases x; cases y; cases z; simp add: less_eq_finite_5_def)
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y" 
+    by (cases x; cases y; simp add: less_eq_finite_5_def)
+  show "x \<sqinter> y \<le> x" 
+    by (cases x; cases y; simp add: inf_finite_5_def less_eq_finite_5_def)
+  show "x \<sqinter> y \<le> y" 
+    by (cases x; cases y; simp add: inf_finite_5_def less_eq_finite_5_def)
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> y \<sqinter> z"
+    by (cases x; cases y; cases z; simp add: inf_finite_5_def less_eq_finite_5_def)
+  show "x \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_5_def less_eq_finite_5_def)
+  show "y \<le> x \<squnion> y"
+    by (cases x; cases y; simp add: sup_finite_5_def less_eq_finite_5_def)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> y \<squnion> z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_finite_5_def less_eq_finite_5_def)
+  show "\<Sqinter> ({}:: finite_5 set) = \<Squnion> UNIV" by (simp add: Sup_finite_5_def Inf_finite_5_def)
+  show "\<Sqinter> insert x A = x \<sqinter> \<Sqinter> A"
+    by (cases x; simp add: Inf_finite_5_def inf_finite_5_def)
+  show "\<Squnion> ({}:: finite_5 set) = \<Sqinter> UNIV" by (simp add: Sup_finite_5_def Inf_finite_5_def)
+  show "\<Squnion> insert x A = x \<squnion> \<Squnion> A" 
+    by (cases x; simp add: Sup_finite_5_def sup_finite_5_def)
+  show "(\<bottom>:: finite_5) = \<Sqinter> UNIV" by (simp add: Inf_finite_5_def)
+  show "(\<top>:: finite_5)  = \<Squnion> UNIV" by (simp add: Sup_finite_5_def)
+qed
 end
 
 
diff -urN ./Euclidean_Division.thy /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy
--- ./Euclidean_Division.thy	2023-05-30 11:50:42.373685700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy	2023-05-31 15:33:10.919027800 +0900
@@ -2795,8 +2795,8 @@
   finally have *: \<open>\<bar>k\<bar> div \<bar>l\<bar> \<noteq> 0 \<longleftrightarrow> \<bar>l\<bar> \<le> \<bar>k\<bar>\<close> .
   show ?thesis
     using \<open>0 \<le> \<bar>k\<bar> div \<bar>l\<bar>\<close> False
-  by (auto simp add: div_eq_div_abs [of k l] div_eq_sgn_abs [of k l]
-    sgn_mult sgn_1_pos sgn_1_neg sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest: sgn_not_eq_imp)
+  by (auto simp add: div_eq_div_abs [of k l] (* redundant and looping! div_eq_sgn_abs [of k l] *)
+    sgn_mult sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest!: sgn_not_eq_imp)
 qed
 
 
diff -urN ./Euclidean_Division.thy~ /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy~
--- ./Euclidean_Division.thy~	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy~	2023-05-31 15:09:00.451970800 +0900
@@ -0,0 +1,3376 @@
+(*  Title:      HOL/Euclidean_Division.thy
+    Author:     Manuel Eberl, TU Muenchen
+    Author:     Florian Haftmann, TU Muenchen
+*)
+
+section \<open>Division in euclidean (semi)rings\<close>
+
+theory Euclidean_Division
+  imports Int Lattices_Big
+begin
+
+subsection \<open>Euclidean (semi)rings with explicit division and remainder\<close>
+
+class euclidean_semiring = semidom_modulo +
+  fixes euclidean_size :: "'a \<Rightarrow> nat"
+  assumes size_0 [simp]: "euclidean_size 0 = 0"
+  assumes mod_size_less:
+    "b \<noteq> 0 \<Longrightarrow> euclidean_size (a mod b) < euclidean_size b"
+  assumes size_mult_mono:
+    "b \<noteq> 0 \<Longrightarrow> euclidean_size a \<le> euclidean_size (a * b)"
+begin
+
+lemma euclidean_size_eq_0_iff [simp]:
+  "euclidean_size b = 0 \<longleftrightarrow> b = 0"
+proof
+  assume "b = 0"
+  then show "euclidean_size b = 0"
+    by simp
+next
+  assume "euclidean_size b = 0"
+  show "b = 0"
+  proof (rule ccontr)
+    assume "b \<noteq> 0"
+    with mod_size_less have "euclidean_size (b mod b) < euclidean_size b" .
+    with \<open>euclidean_size b = 0\<close> show False
+      by simp
+  qed
+qed
+
+lemma euclidean_size_greater_0_iff [simp]:
+  "euclidean_size b > 0 \<longleftrightarrow> b \<noteq> 0"
+  using euclidean_size_eq_0_iff [symmetric, of b] by safe simp
+
+lemma size_mult_mono': "b \<noteq> 0 \<Longrightarrow> euclidean_size a \<le> euclidean_size (b * a)"
+  by (subst mult.commute) (rule size_mult_mono)
+
+lemma dvd_euclidean_size_eq_imp_dvd:
+  assumes "a \<noteq> 0" and "euclidean_size a = euclidean_size b"
+    and "b dvd a"
+  shows "a dvd b"
+proof (rule ccontr)
+  assume "\<not> a dvd b"
+  hence "b mod a \<noteq> 0" using mod_0_imp_dvd [of b a] by blast
+  then have "b mod a \<noteq> 0" by (simp add: mod_eq_0_iff_dvd)
+  from \<open>b dvd a\<close> have "b dvd b mod a" by (simp add: dvd_mod_iff)
+  then obtain c where "b mod a = b * c" unfolding dvd_def by blast
+    with \<open>b mod a \<noteq> 0\<close> have "c \<noteq> 0" by auto
+  with \<open>b mod a = b * c\<close> have "euclidean_size (b mod a) \<ge> euclidean_size b"
+    using size_mult_mono by force
+  moreover from \<open>\<not> a dvd b\<close> and \<open>a \<noteq> 0\<close>
+  have "euclidean_size (b mod a) < euclidean_size a"
+    using mod_size_less by blast
+  ultimately show False using \<open>euclidean_size a = euclidean_size b\<close>
+    by simp
+qed
+
+lemma euclidean_size_times_unit:
+  assumes "is_unit a"
+  shows   "euclidean_size (a * b) = euclidean_size b"
+proof (rule antisym)
+  from assms have [simp]: "a \<noteq> 0" by auto
+  thus "euclidean_size (a * b) \<ge> euclidean_size b" by (rule size_mult_mono')
+  from assms have "is_unit (1 div a)" by simp
+  hence "1 div a \<noteq> 0" by (intro notI) simp_all
+  hence "euclidean_size (a * b) \<le> euclidean_size ((1 div a) * (a * b))"
+    by (rule size_mult_mono')
+  also from assms have "(1 div a) * (a * b) = b"
+    by (simp add: algebra_simps unit_div_mult_swap)
+  finally show "euclidean_size (a * b) \<le> euclidean_size b" .
+qed
+
+lemma euclidean_size_unit:
+  "is_unit a \<Longrightarrow> euclidean_size a = euclidean_size 1"
+  using euclidean_size_times_unit [of a 1] by simp
+
+lemma unit_iff_euclidean_size:
+  "is_unit a \<longleftrightarrow> euclidean_size a = euclidean_size 1 \<and> a \<noteq> 0"
+proof safe
+  assume A: "a \<noteq> 0" and B: "euclidean_size a = euclidean_size 1"
+  show "is_unit a"
+    by (rule dvd_euclidean_size_eq_imp_dvd [OF A B]) simp_all
+qed (auto intro: euclidean_size_unit)
+
+lemma euclidean_size_times_nonunit:
+  assumes "a \<noteq> 0" "b \<noteq> 0" "\<not> is_unit a"
+  shows   "euclidean_size b < euclidean_size (a * b)"
+proof (rule ccontr)
+  assume "\<not>euclidean_size b < euclidean_size (a * b)"
+  with size_mult_mono'[OF assms(1), of b]
+    have eq: "euclidean_size (a * b) = euclidean_size b" by simp
+  have "a * b dvd b"
+    by (rule dvd_euclidean_size_eq_imp_dvd [OF _ eq])
+       (use assms in simp_all)
+  hence "a * b dvd 1 * b" by simp
+  with \<open>b \<noteq> 0\<close> have "is_unit a" by (subst (asm) dvd_times_right_cancel_iff)
+  with assms(3) show False by contradiction
+qed
+
+lemma dvd_imp_size_le:
+  assumes "a dvd b" "b \<noteq> 0"
+  shows   "euclidean_size a \<le> euclidean_size b"
+  using assms by (auto simp: size_mult_mono)
+
+lemma dvd_proper_imp_size_less:
+  assumes "a dvd b" "\<not> b dvd a" "b \<noteq> 0"
+  shows   "euclidean_size a < euclidean_size b"
+proof -
+  from assms(1) obtain c where "b = a * c" by (erule dvdE)
+  hence z: "b = c * a" by (simp add: mult.commute)
+  from z assms have "\<not>is_unit c" by (auto simp: mult.commute mult_unit_dvd_iff)
+  with z assms show ?thesis
+    by (auto intro!: euclidean_size_times_nonunit)
+qed
+
+lemma unit_imp_mod_eq_0:
+  "a mod b = 0" if "is_unit b"
+  using that by (simp add: mod_eq_0_iff_dvd unit_imp_dvd)
+
+lemma mod_eq_self_iff_div_eq_0:
+  "a mod b = a \<longleftrightarrow> a div b = 0" (is "?P \<longleftrightarrow> ?Q")
+proof
+  assume ?P
+  with div_mult_mod_eq [of a b] show ?Q
+    by auto
+next
+  assume ?Q
+  with div_mult_mod_eq [of a b] show ?P
+    by simp
+qed
+
+lemma coprime_mod_left_iff [simp]:
+  "coprime (a mod b) b \<longleftrightarrow> coprime a b" if "b \<noteq> 0"
+  by (rule iffI; rule coprimeI)
+    (use that in \<open>auto dest!: dvd_mod_imp_dvd coprime_common_divisor simp add: dvd_mod_iff\<close>)
+
+lemma coprime_mod_right_iff [simp]:
+  "coprime a (b mod a) \<longleftrightarrow> coprime a b" if "a \<noteq> 0"
+  using that coprime_mod_left_iff [of a b] by (simp add: ac_simps)
+
+end
+
+class euclidean_ring = idom_modulo + euclidean_semiring
+begin
+
+lemma dvd_diff_commute [ac_simps]:
+  "a dvd c - b \<longleftrightarrow> a dvd b - c"
+proof -
+  have "a dvd c - b \<longleftrightarrow> a dvd (c - b) * - 1"
+    by (subst dvd_mult_unit_iff) simp_all
+  then show ?thesis
+    by simp
+qed
+
+end
+
+
+subsection \<open>Euclidean (semi)rings with cancel rules\<close>
+
+class euclidean_semiring_cancel = euclidean_semiring +
+  assumes div_mult_self1 [simp]: "b \<noteq> 0 \<Longrightarrow> (a + c * b) div b = c + a div b"
+  and div_mult_mult1 [simp]: "c \<noteq> 0 \<Longrightarrow> (c * a) div (c * b) = a div b"
+begin
+
+lemma div_mult_self2 [simp]:
+  assumes "b \<noteq> 0"
+  shows "(a + b * c) div b = c + a div b"
+  using assms div_mult_self1 [of b a c] by (simp add: mult.commute)
+
+lemma div_mult_self3 [simp]:
+  assumes "b \<noteq> 0"
+  shows "(c * b + a) div b = c + a div b"
+  using assms by (simp add: add.commute)
+
+lemma div_mult_self4 [simp]:
+  assumes "b \<noteq> 0"
+  shows "(b * c + a) div b = c + a div b"
+  using assms by (simp add: add.commute)
+
+lemma mod_mult_self1 [simp]: "(a + c * b) mod b = a mod b"
+proof (cases "b = 0")
+  case True then show ?thesis by simp
+next
+  case False
+  have "a + c * b = (a + c * b) div b * b + (a + c * b) mod b"
+    by (simp add: div_mult_mod_eq)
+  also from False div_mult_self1 [of b a c] have
+    "\<dots> = (c + a div b) * b + (a + c * b) mod b"
+      by (simp add: algebra_simps)
+  finally have "a = a div b * b + (a + c * b) mod b"
+    by (simp add: add.commute [of a] add.assoc distrib_right)
+  then have "a div b * b + (a + c * b) mod b = a div b * b + a mod b"
+    by (simp add: div_mult_mod_eq)
+  then show ?thesis by simp
+qed
+
+lemma mod_mult_self2 [simp]:
+  "(a + b * c) mod b = a mod b"
+  by (simp add: mult.commute [of b])
+
+lemma mod_mult_self3 [simp]:
+  "(c * b + a) mod b = a mod b"
+  by (simp add: add.commute)
+
+lemma mod_mult_self4 [simp]:
+  "(b * c + a) mod b = a mod b"
+  by (simp add: add.commute)
+
+lemma mod_mult_self1_is_0 [simp]:
+  "b * a mod b = 0"
+  using mod_mult_self2 [of 0 b a] by simp
+
+lemma mod_mult_self2_is_0 [simp]:
+  "a * b mod b = 0"
+  using mod_mult_self1 [of 0 a b] by simp
+
+lemma div_add_self1:
+  assumes "b \<noteq> 0"
+  shows "(b + a) div b = a div b + 1"
+  using assms div_mult_self1 [of b a 1] by (simp add: add.commute)
+
+lemma div_add_self2:
+  assumes "b \<noteq> 0"
+  shows "(a + b) div b = a div b + 1"
+  using assms div_add_self1 [of b a] by (simp add: add.commute)
+
+lemma mod_add_self1 [simp]:
+  "(b + a) mod b = a mod b"
+  using mod_mult_self1 [of a 1 b] by (simp add: add.commute)
+
+lemma mod_add_self2 [simp]:
+  "(a + b) mod b = a mod b"
+  using mod_mult_self1 [of a 1 b] by simp
+
+lemma mod_div_trivial [simp]:
+  "a mod b div b = 0"
+proof (cases "b = 0")
+  assume "b = 0"
+  thus ?thesis by simp
+next
+  assume "b \<noteq> 0"
+  hence "a div b + a mod b div b = (a mod b + a div b * b) div b"
+    by (rule div_mult_self1 [symmetric])
+  also have "\<dots> = a div b"
+    by (simp only: mod_div_mult_eq)
+  also have "\<dots> = a div b + 0"
+    by simp
+  finally show ?thesis
+    by (rule add_left_imp_eq)
+qed
+
+lemma mod_mod_trivial [simp]:
+  "a mod b mod b = a mod b"
+proof -
+  have "a mod b mod b = (a mod b + a div b * b) mod b"
+    by (simp only: mod_mult_self1)
+  also have "\<dots> = a mod b"
+    by (simp only: mod_div_mult_eq)
+  finally show ?thesis .
+qed
+
+lemma mod_mod_cancel:
+  assumes "c dvd b"
+  shows "a mod b mod c = a mod c"
+proof -
+  from \<open>c dvd b\<close> obtain k where "b = c * k"
+    by (rule dvdE)
+  have "a mod b mod c = a mod (c * k) mod c"
+    by (simp only: \<open>b = c * k\<close>)
+  also have "\<dots> = (a mod (c * k) + a div (c * k) * k * c) mod c"
+    by (simp only: mod_mult_self1)
+  also have "\<dots> = (a div (c * k) * (c * k) + a mod (c * k)) mod c"
+    by (simp only: ac_simps)
+  also have "\<dots> = a mod c"
+    by (simp only: div_mult_mod_eq)
+  finally show ?thesis .
+qed
+
+lemma div_mult_mult2 [simp]:
+  "c \<noteq> 0 \<Longrightarrow> (a * c) div (b * c) = a div b"
+  by (drule div_mult_mult1) (simp add: mult.commute)
+
+lemma div_mult_mult1_if [simp]:
+  "(c * a) div (c * b) = (if c = 0 then 0 else a div b)"
+  by simp_all
+
+lemma mod_mult_mult1:
+  "(c * a) mod (c * b) = c * (a mod b)"
+proof (cases "c = 0")
+  case True then show ?thesis by simp
+next
+  case False
+  from div_mult_mod_eq
+  have "((c * a) div (c * b)) * (c * b) + (c * a) mod (c * b) = c * a" .
+  with False have "c * ((a div b) * b + a mod b) + (c * a) mod (c * b)
+    = c * a + c * (a mod b)" by (simp add: algebra_simps)
+  with div_mult_mod_eq show ?thesis by simp
+qed
+
+lemma mod_mult_mult2:
+  "(a * c) mod (b * c) = (a mod b) * c"
+  using mod_mult_mult1 [of c a b] by (simp add: mult.commute)
+
+lemma mult_mod_left: "(a mod b) * c = (a * c) mod (b * c)"
+  by (fact mod_mult_mult2 [symmetric])
+
+lemma mult_mod_right: "c * (a mod b) = (c * a) mod (c * b)"
+  by (fact mod_mult_mult1 [symmetric])
+
+lemma dvd_mod: "k dvd m \<Longrightarrow> k dvd n \<Longrightarrow> k dvd (m mod n)"
+  unfolding dvd_def by (auto simp add: mod_mult_mult1)
+
+lemma div_plus_div_distrib_dvd_left:
+  "c dvd a \<Longrightarrow> (a + b) div c = a div c + b div c"
+  by (cases "c = 0") auto
+
+lemma div_plus_div_distrib_dvd_right:
+  "c dvd b \<Longrightarrow> (a + b) div c = a div c + b div c"
+  using div_plus_div_distrib_dvd_left [of c b a]
+  by (simp add: ac_simps)
+
+lemma sum_div_partition:
+  \<open>(\<Sum>a\<in>A. f a) div b = (\<Sum>a\<in>A \<inter> {a. b dvd f a}. f a div b) + (\<Sum>a\<in>A \<inter> {a. \<not> b dvd f a}. f a) div b\<close>
+    if \<open>finite A\<close>
+proof -
+  have \<open>A = A \<inter> {a. b dvd f a} \<union> A \<inter> {a. \<not> b dvd f a}\<close>
+    by auto
+  then have \<open>(\<Sum>a\<in>A. f a) = (\<Sum>a\<in>A \<inter> {a. b dvd f a} \<union> A \<inter> {a. \<not> b dvd f a}. f a)\<close>
+    by simp
+  also have \<open>\<dots> = (\<Sum>a\<in>A \<inter> {a. b dvd f a}. f a) + (\<Sum>a\<in>A \<inter> {a. \<not> b dvd f a}. f a)\<close>
+    using \<open>finite A\<close> by (auto intro: sum.union_inter_neutral)
+  finally have *: \<open>sum f A = sum f (A \<inter> {a. b dvd f a}) + sum f (A \<inter> {a. \<not> b dvd f a})\<close> .
+  define B where B: \<open>B = A \<inter> {a. b dvd f a}\<close>
+  with \<open>finite A\<close> have \<open>finite B\<close> and \<open>a \<in> B \<Longrightarrow> b dvd f a\<close> for a
+    by simp_all
+  then have \<open>(\<Sum>a\<in>B. f a) div b = (\<Sum>a\<in>B. f a div b)\<close> and \<open>b dvd (\<Sum>a\<in>B. f a)\<close>
+    by induction (simp_all add: div_plus_div_distrib_dvd_left)
+  then show ?thesis using *
+    by (simp add: B div_plus_div_distrib_dvd_left)
+qed
+
+named_theorems mod_simps
+
+text \<open>Addition respects modular equivalence.\<close>
+
+lemma mod_add_left_eq [mod_simps]:
+  "(a mod c + b) mod c = (a + b) mod c"
+proof -
+  have "(a + b) mod c = (a div c * c + a mod c + b) mod c"
+    by (simp only: div_mult_mod_eq)
+  also have "\<dots> = (a mod c + b + a div c * c) mod c"
+    by (simp only: ac_simps)
+  also have "\<dots> = (a mod c + b) mod c"
+    by (rule mod_mult_self1)
+  finally show ?thesis
+    by (rule sym)
+qed
+
+lemma mod_add_right_eq [mod_simps]:
+  "(a + b mod c) mod c = (a + b) mod c"
+  using mod_add_left_eq [of b c a] by (simp add: ac_simps)
+
+lemma mod_add_eq:
+  "(a mod c + b mod c) mod c = (a + b) mod c"
+  by (simp add: mod_add_left_eq mod_add_right_eq)
+
+lemma mod_sum_eq [mod_simps]:
+  "(\<Sum>i\<in>A. f i mod a) mod a = sum f A mod a"
+proof (induct A rule: infinite_finite_induct)
+  case (insert i A)
+  then have "(\<Sum>i\<in>insert i A. f i mod a) mod a
+    = (f i mod a + (\<Sum>i\<in>A. f i mod a)) mod a"
+    by simp
+  also have "\<dots> = (f i + (\<Sum>i\<in>A. f i mod a) mod a) mod a"
+    by (simp add: mod_simps)
+  also have "\<dots> = (f i + (\<Sum>i\<in>A. f i) mod a) mod a"
+    by (simp add: insert.hyps)
+  finally show ?case
+    by (simp add: insert.hyps mod_simps)
+qed simp_all
+
+lemma mod_add_cong:
+  assumes "a mod c = a' mod c"
+  assumes "b mod c = b' mod c"
+  shows "(a + b) mod c = (a' + b') mod c"
+proof -
+  have "(a mod c + b mod c) mod c = (a' mod c + b' mod c) mod c"
+    unfolding assms ..
+  then show ?thesis
+    by (simp add: mod_add_eq)
+qed
+
+text \<open>Multiplication respects modular equivalence.\<close>
+
+lemma mod_mult_left_eq [mod_simps]:
+  "((a mod c) * b) mod c = (a * b) mod c"
+proof -
+  have "(a * b) mod c = ((a div c * c + a mod c) * b) mod c"
+    by (simp only: div_mult_mod_eq)
+  also have "\<dots> = (a mod c * b + a div c * b * c) mod c"
+    by (simp only: algebra_simps)
+  also have "\<dots> = (a mod c * b) mod c"
+    by (rule mod_mult_self1)
+  finally show ?thesis
+    by (rule sym)
+qed
+
+lemma mod_mult_right_eq [mod_simps]:
+  "(a * (b mod c)) mod c = (a * b) mod c"
+  using mod_mult_left_eq [of b c a] by (simp add: ac_simps)
+
+lemma mod_mult_eq:
+  "((a mod c) * (b mod c)) mod c = (a * b) mod c"
+  by (simp add: mod_mult_left_eq mod_mult_right_eq)
+
+lemma mod_prod_eq [mod_simps]:
+  "(\<Prod>i\<in>A. f i mod a) mod a = prod f A mod a"
+proof (induct A rule: infinite_finite_induct)
+  case (insert i A)
+  then have "(\<Prod>i\<in>insert i A. f i mod a) mod a
+    = (f i mod a * (\<Prod>i\<in>A. f i mod a)) mod a"
+    by simp
+  also have "\<dots> = (f i * ((\<Prod>i\<in>A. f i mod a) mod a)) mod a"
+    by (simp add: mod_simps)
+  also have "\<dots> = (f i * ((\<Prod>i\<in>A. f i) mod a)) mod a"
+    by (simp add: insert.hyps)
+  finally show ?case
+    by (simp add: insert.hyps mod_simps)
+qed simp_all
+
+lemma mod_mult_cong:
+  assumes "a mod c = a' mod c"
+  assumes "b mod c = b' mod c"
+  shows "(a * b) mod c = (a' * b') mod c"
+proof -
+  have "(a mod c * (b mod c)) mod c = (a' mod c * (b' mod c)) mod c"
+    unfolding assms ..
+  then show ?thesis
+    by (simp add: mod_mult_eq)
+qed
+
+text \<open>Exponentiation respects modular equivalence.\<close>
+
+lemma power_mod [mod_simps]:
+  "((a mod b) ^ n) mod b = (a ^ n) mod b"
+proof (induct n)
+  case 0
+  then show ?case by simp
+next
+  case (Suc n)
+  have "(a mod b) ^ Suc n mod b = (a mod b) * ((a mod b) ^ n mod b) mod b"
+    by (simp add: mod_mult_right_eq)
+  with Suc show ?case
+    by (simp add: mod_mult_left_eq mod_mult_right_eq)
+qed
+
+lemma power_diff_power_eq:
+  \<open>a ^ m div a ^ n = (if n \<le> m then a ^ (m - n) else 1 div a ^ (n - m))\<close>
+    if \<open>a \<noteq> 0\<close>
+proof (cases \<open>n \<le> m\<close>)
+  case True
+  with that power_diff [symmetric, of a n m] show ?thesis by simp
+next
+  case False
+  then obtain q where n: \<open>n = m + Suc q\<close>
+    by (auto simp add: not_le dest: less_imp_Suc_add)
+  then have \<open>a ^ m div a ^ n = (a ^ m * 1) div (a ^ m * a ^ Suc q)\<close>
+    by (simp add: power_add ac_simps)
+  moreover from that have \<open>a ^ m \<noteq> 0\<close>
+    by simp
+  ultimately have \<open>a ^ m div a ^ n = 1 div a ^ Suc q\<close>
+    by (subst (asm) div_mult_mult1) simp
+  with False n show ?thesis
+    by simp
+qed
+
+end
+
+
+class euclidean_ring_cancel = euclidean_ring + euclidean_semiring_cancel
+begin
+
+subclass idom_divide ..
+
+lemma div_minus_minus [simp]: "(- a) div (- b) = a div b"
+  using div_mult_mult1 [of "- 1" a b] by simp
+
+lemma mod_minus_minus [simp]: "(- a) mod (- b) = - (a mod b)"
+  using mod_mult_mult1 [of "- 1" a b] by simp
+
+lemma div_minus_right: "a div (- b) = (- a) div b"
+  using div_minus_minus [of "- a" b] by simp
+
+lemma mod_minus_right: "a mod (- b) = - ((- a) mod b)"
+  using mod_minus_minus [of "- a" b] by simp
+
+lemma div_minus1_right [simp]: "a div (- 1) = - a"
+  using div_minus_right [of a 1] by simp
+
+lemma mod_minus1_right [simp]: "a mod (- 1) = 0"
+  using mod_minus_right [of a 1] by simp
+
+text \<open>Negation respects modular equivalence.\<close>
+
+lemma mod_minus_eq [mod_simps]:
+  "(- (a mod b)) mod b = (- a) mod b"
+proof -
+  have "(- a) mod b = (- (a div b * b + a mod b)) mod b"
+    by (simp only: div_mult_mod_eq)
+  also have "\<dots> = (- (a mod b) + - (a div b) * b) mod b"
+    by (simp add: ac_simps)
+  also have "\<dots> = (- (a mod b)) mod b"
+    by (rule mod_mult_self1)
+  finally show ?thesis
+    by (rule sym)
+qed
+
+lemma mod_minus_cong:
+  assumes "a mod b = a' mod b"
+  shows "(- a) mod b = (- a') mod b"
+proof -
+  have "(- (a mod b)) mod b = (- (a' mod b)) mod b"
+    unfolding assms ..
+  then show ?thesis
+    by (simp add: mod_minus_eq)
+qed
+
+text \<open>Subtraction respects modular equivalence.\<close>
+
+lemma mod_diff_left_eq [mod_simps]:
+  "(a mod c - b) mod c = (a - b) mod c"
+  using mod_add_cong [of a c "a mod c" "- b" "- b"]
+  by simp
+
+lemma mod_diff_right_eq [mod_simps]:
+  "(a - b mod c) mod c = (a - b) mod c"
+  using mod_add_cong [of a c a "- b" "- (b mod c)"] mod_minus_cong [of "b mod c" c b]
+  by simp
+
+lemma mod_diff_eq:
+  "(a mod c - b mod c) mod c = (a - b) mod c"
+  using mod_add_cong [of a c "a mod c" "- b" "- (b mod c)"] mod_minus_cong [of "b mod c" c b]
+  by simp
+
+lemma mod_diff_cong:
+  assumes "a mod c = a' mod c"
+  assumes "b mod c = b' mod c"
+  shows "(a - b) mod c = (a' - b') mod c"
+  using assms mod_add_cong [of a c a' "- b" "- b'"] mod_minus_cong [of b c "b'"]
+  by simp
+
+lemma minus_mod_self2 [simp]:
+  "(a - b) mod b = a mod b"
+  using mod_diff_right_eq [of a b b]
+  by (simp add: mod_diff_right_eq)
+
+lemma minus_mod_self1 [simp]:
+  "(b - a) mod b = - a mod b"
+  using mod_add_self2 [of "- a" b] by simp
+
+lemma mod_eq_dvd_iff:
+  "a mod c = b mod c \<longleftrightarrow> c dvd a - b" (is "?P \<longleftrightarrow> ?Q")
+proof
+  assume ?P
+  then have "(a mod c - b mod c) mod c = 0"
+    by simp
+  then show ?Q
+    by (simp add: dvd_eq_mod_eq_0 mod_simps)
+next
+  assume ?Q
+  then obtain d where d: "a - b = c * d" ..
+  then have "a = c * d + b"
+    by (simp add: algebra_simps)
+  then show ?P by simp
+qed
+
+lemma mod_eqE:
+  assumes "a mod c = b mod c"
+  obtains d where "b = a + c * d"
+proof -
+  from assms have "c dvd a - b"
+    by (simp add: mod_eq_dvd_iff)
+  then obtain d where "a - b = c * d" ..
+  then have "b = a + c * - d"
+    by (simp add: algebra_simps)
+  with that show thesis .
+qed
+
+lemma invertible_coprime:
+  "coprime a c" if "a * b mod c = 1"
+  by (rule coprimeI) (use that dvd_mod_iff [of _ c "a * b"] in auto)
+
+end
+
+
+subsection \<open>Uniquely determined division\<close>
+
+class unique_euclidean_semiring = euclidean_semiring +
+  assumes euclidean_size_mult: \<open>euclidean_size (a * b) = euclidean_size a * euclidean_size b\<close>
+  fixes division_segment :: \<open>'a \<Rightarrow> 'a\<close>
+  assumes is_unit_division_segment [simp]: \<open>is_unit (division_segment a)\<close>
+    and division_segment_mult:
+    \<open>a \<noteq> 0 \<Longrightarrow> b \<noteq> 0 \<Longrightarrow> division_segment (a * b) = division_segment a * division_segment b\<close>
+    and division_segment_mod:
+    \<open>b \<noteq> 0 \<Longrightarrow> \<not> b dvd a \<Longrightarrow> division_segment (a mod b) = division_segment b\<close>
+  assumes div_bounded:
+    \<open>b \<noteq> 0 \<Longrightarrow> division_segment r = division_segment b
+    \<Longrightarrow> euclidean_size r < euclidean_size b
+    \<Longrightarrow> (q * b + r) div b = q\<close>
+begin
+
+lemma division_segment_not_0 [simp]:
+  \<open>division_segment a \<noteq> 0\<close>
+  using is_unit_division_segment [of a] is_unitE [of \<open>division_segment a\<close>] by blast
+
+lemma euclidean_relationI [case_names by0 divides euclidean_relation]:
+  \<open>(a div b, a mod b) = (q, r)\<close>
+    if by0: \<open>b = 0 \<Longrightarrow> q = 0 \<and> r = a\<close>
+    and divides: \<open>b \<noteq> 0 \<Longrightarrow> b dvd a \<Longrightarrow> r = 0 \<and> a = q * b\<close>
+    and euclidean_relation: \<open>b \<noteq> 0 \<Longrightarrow> \<not> b dvd a \<Longrightarrow> division_segment r = division_segment b
+      \<and> euclidean_size r < euclidean_size b \<and> a = q * b + r\<close>
+proof (cases \<open>b = 0\<close>)
+  case True
+  with by0 show ?thesis
+    by simp
+next
+  case False
+  show ?thesis
+  proof (cases \<open>b dvd a\<close>)
+    case True
+    with \<open>b \<noteq> 0\<close> divides
+    show ?thesis
+      by simp
+  next
+    case False
+    with \<open>b \<noteq> 0\<close> euclidean_relation
+    have \<open>division_segment r = division_segment b\<close>
+      \<open>euclidean_size r < euclidean_size b\<close> \<open>a = q * b + r\<close>
+      by simp_all
+    from \<open>b \<noteq> 0\<close> \<open>division_segment r = division_segment b\<close>
+      \<open>euclidean_size r < euclidean_size b\<close>
+    have \<open>(q * b + r) div b = q\<close>
+      by (rule div_bounded)
+    with \<open>a = q * b + r\<close>
+    have \<open>q = a div b\<close>
+      by simp
+    from \<open>a = q * b + r\<close>
+    have \<open>a div b * b + a mod b = q * b + r\<close>
+      by (simp add: div_mult_mod_eq)
+    with \<open>q = a div b\<close>
+    have \<open>q * b + a mod b = q * b + r\<close>
+      by simp
+    then have \<open>r = a mod b\<close>
+      by simp
+    with \<open>q = a div b\<close>
+    show ?thesis
+      by simp
+  qed
+qed
+
+subclass euclidean_semiring_cancel
+proof
+  fix a b c
+  assume \<open>b \<noteq> 0\<close>
+  have \<open>((a + c * b) div b, (a + c * b) mod b) = (c + a div b, a mod b)\<close>
+  proof (cases b \<open>c + a div b\<close> \<open>a mod b\<close> \<open>a + c * b\<close> rule: euclidean_relationI)
+    case by0
+    with \<open>b \<noteq> 0\<close>
+    show ?case
+      by simp
+  next
+    case divides
+    then show ?case
+      by (simp add: algebra_simps dvd_add_left_iff)
+  next
+    case euclidean_relation
+    then have \<open>\<not> b dvd a\<close>
+      by (simp add: dvd_add_left_iff)
+    have \<open>a mod b + (b * c + b * (a div b)) = b * c + ((a div b) * b + a mod b)\<close>
+      by (simp add: ac_simps)
+    with \<open>b \<noteq> 0\<close> have *: \<open>a mod b + (b * c + b * (a div b)) = b * c + a\<close>
+      by (simp add: div_mult_mod_eq)
+    from \<open>\<not> b dvd a\<close> euclidean_relation show ?case
+      by (simp_all add: algebra_simps division_segment_mod mod_size_less *)
+  qed
+  then show \<open>(a + c * b) div b = c + a div b\<close>
+    by simp
+next
+  fix a b c
+  assume \<open>c \<noteq> 0\<close>
+  have \<open>((c * a) div (c * b), (c * a) mod (c * b)) = (a div b, c * (a mod b))\<close>
+  proof (cases \<open>c * b\<close> \<open>a div b\<close> \<open>c * (a mod b)\<close> \<open>c * a\<close> rule: euclidean_relationI)
+    case by0
+    with \<open>c \<noteq> 0\<close> show ?case
+      by simp
+  next
+    case divides
+    then show ?case
+      by (auto simp add: algebra_simps)
+  next
+    case euclidean_relation
+    then have \<open>b \<noteq> 0\<close> \<open>a mod b \<noteq> 0\<close>
+      by (simp_all add: mod_eq_0_iff_dvd)
+    have \<open>c * (a mod b) + b * (c * (a div b)) = c * ((a div b) * b + a mod b)\<close>
+      by (simp add: algebra_simps)
+    with \<open>b \<noteq> 0\<close> have *: \<open>c * (a mod b) + b * (c * (a div b)) = c * a\<close>
+      by (simp add: div_mult_mod_eq)
+    from \<open>b \<noteq> 0\<close> \<open>c \<noteq> 0\<close> have \<open>euclidean_size c * euclidean_size (a mod b)
+      < euclidean_size c * euclidean_size b\<close>
+      using mod_size_less [of b a] by simp
+    with euclidean_relation \<open>b \<noteq> 0\<close> \<open>a mod b \<noteq> 0\<close> show ?case
+      by (simp add: algebra_simps division_segment_mult division_segment_mod euclidean_size_mult *)
+  qed
+  then show \<open>(c * a) div (c * b) = a div b\<close>
+    by simp
+qed
+
+lemma div_eq_0_iff:
+  \<open>a div b = 0 \<longleftrightarrow> euclidean_size a < euclidean_size b \<or> b = 0\<close> (is "_ \<longleftrightarrow> ?P")
+  if \<open>division_segment a = division_segment b\<close>
+proof (cases \<open>a = 0 \<or> b = 0\<close>)
+  case True
+  then show ?thesis by auto
+next
+  case False
+  then have \<open>a \<noteq> 0\<close> \<open>b \<noteq> 0\<close>
+    by simp_all
+  have \<open>a div b = 0 \<longleftrightarrow> euclidean_size a < euclidean_size b\<close>
+  proof
+    assume \<open>a div b = 0\<close>
+    then have \<open>a mod b = a\<close>
+      using div_mult_mod_eq [of a b] by simp
+    with \<open>b \<noteq> 0\<close> mod_size_less [of b a]
+    show \<open>euclidean_size a < euclidean_size b\<close>
+      by simp
+  next
+    assume \<open>euclidean_size a < euclidean_size b\<close>
+    have \<open>(a div b, a mod b) = (0, a)\<close>
+    proof (cases b 0 a a rule: euclidean_relationI)
+      case by0
+      show ?case
+        by simp
+    next
+      case divides
+      with \<open>euclidean_size a < euclidean_size b\<close> show ?case
+        using dvd_imp_size_le [of b a] \<open>a \<noteq> 0\<close> by simp
+    next
+      case euclidean_relation
+      with \<open>euclidean_size a < euclidean_size b\<close> that
+      show ?case
+        by simp
+    qed
+    then show \<open>a div b = 0\<close>
+      by simp
+  qed
+  with \<open>b \<noteq> 0\<close> show ?thesis
+    by simp
+qed
+
+lemma div_mult1_eq:
+  \<open>(a * b) div c = a * (b div c) + a * (b mod c) div c\<close>
+proof -
+  have *: \<open>(a * b) mod c + (a * (c * (b div c)) + c * (a * (b mod c) div c)) = a * b\<close> (is \<open>?A + (?B + ?C) = _\<close>)
+  proof -
+    have \<open>?A = a * (b mod c) mod c\<close>
+      by (simp add: mod_mult_right_eq)
+    then have \<open>?C + ?A = a * (b mod c)\<close>
+      by (simp add: mult_div_mod_eq)
+    then have \<open>?B + (?C + ?A) = a * (c * (b div c) + (b mod c))\<close>
+      by (simp add: algebra_simps)
+    also have \<open>\<dots> = a * b\<close>
+      by (simp add: mult_div_mod_eq)
+    finally show ?thesis
+      by (simp add: algebra_simps)
+  qed
+  have \<open>((a * b) div c, (a * b) mod c) = (a * (b div c) + a * (b mod c) div c, (a * b) mod c)\<close>
+  proof (cases c \<open>a * (b div c) + a * (b mod c) div c\<close> \<open>(a * b) mod c\<close> \<open>a * b\<close> rule: euclidean_relationI)
+    case by0
+    then show ?case by simp
+  next
+    case divides
+    with * show ?case
+      by (simp add: algebra_simps)
+  next
+    case euclidean_relation
+    with * show ?case
+      by (simp add: division_segment_mod mod_size_less algebra_simps)
+  qed
+  then show ?thesis
+    by simp
+qed
+
+lemma div_add1_eq:
+  \<open>(a + b) div c = a div c + b div c + (a mod c + b mod c) div c\<close>
+proof -
+  have *: \<open>(a + b) mod c + (c * (a div c) + (c * (b div c) + c * ((a mod c + b mod c) div c))) = a + b\<close>
+    (is \<open>?A + (?B + (?C + ?D)) = _\<close>)
+  proof -
+    have \<open>?A + (?B + (?C + ?D)) = ?A + ?D + (?B + ?C)\<close>
+      by (simp add: ac_simps)
+    also have \<open>?A + ?D = (a mod c + b mod c) mod c + ?D\<close>
+      by (simp add: mod_add_eq)
+    also have \<open>\<dots> = a mod c + b mod c\<close>
+      by (simp add: mod_mult_div_eq)
+    finally have \<open>?A + (?B + (?C + ?D)) = (a mod c + ?B) + (b mod c + ?C)\<close>
+      by (simp add: ac_simps)
+    then show ?thesis
+      by (simp add: mod_mult_div_eq)
+  qed
+  have \<open>((a + b) div c, (a + b) mod c) = (a div c + b div c + (a mod c + b mod c) div c, (a + b) mod c)\<close>
+  proof (cases c \<open>a div c + b div c + (a mod c + b mod c) div c\<close> \<open>(a + b) mod c\<close> \<open>a + b\<close> rule: euclidean_relationI)
+    case by0
+    then show ?case
+      by simp
+  next
+    case divides
+    with * show ?case
+      by (simp add: algebra_simps)
+  next
+    case euclidean_relation
+    with * show ?case
+      by (simp add: division_segment_mod mod_size_less algebra_simps)
+  qed
+  then show ?thesis
+    by simp
+qed
+
+end
+
+class unique_euclidean_ring = euclidean_ring + unique_euclidean_semiring
+begin
+
+subclass euclidean_ring_cancel ..
+
+end
+
+
+subsection \<open>Euclidean division on \<^typ>\<open>nat\<close>\<close>
+
+instantiation nat :: normalization_semidom
+begin
+
+definition normalize_nat :: \<open>nat \<Rightarrow> nat\<close>
+  where [simp]: \<open>normalize = (id :: nat \<Rightarrow> nat)\<close>
+
+definition unit_factor_nat :: \<open>nat \<Rightarrow> nat\<close>
+  where \<open>unit_factor n = of_bool (n > 0)\<close> for n :: nat
+
+lemma unit_factor_simps [simp]:
+  \<open>unit_factor 0 = (0::nat)\<close>
+  \<open>unit_factor (Suc n) = 1\<close>
+  by (simp_all add: unit_factor_nat_def)
+
+definition divide_nat :: \<open>nat \<Rightarrow> nat \<Rightarrow> nat\<close>
+  where \<open>m div n = (if n = 0 then 0 else Max {k. k * n \<le> m})\<close> for m n :: nat
+
+instance
+  by standard (auto simp add: divide_nat_def ac_simps unit_factor_nat_def intro: Max_eqI)
+
+end
+
+lemma coprime_Suc_0_left [simp]:
+  "coprime (Suc 0) n"
+  using coprime_1_left [of n] by simp
+
+lemma coprime_Suc_0_right [simp]:
+  "coprime n (Suc 0)"
+  using coprime_1_right [of n] by simp
+
+lemma coprime_common_divisor_nat: "coprime a b \<Longrightarrow> x dvd a \<Longrightarrow> x dvd b \<Longrightarrow> x = 1"
+  for a b :: nat
+  by (drule coprime_common_divisor [of _ _ x]) simp_all
+
+instantiation nat :: unique_euclidean_semiring
+begin
+
+definition euclidean_size_nat :: \<open>nat \<Rightarrow> nat\<close>
+  where [simp]: \<open>euclidean_size_nat = id\<close>
+
+definition division_segment_nat :: \<open>nat \<Rightarrow> nat\<close>
+  where [simp]: \<open>division_segment n = 1\<close> for n :: nat
+
+definition modulo_nat :: \<open>nat \<Rightarrow> nat \<Rightarrow> nat\<close>
+  where \<open>m mod n = m - (m div n * n)\<close> for m n :: nat
+
+instance proof
+  fix m n :: nat
+  have ex: "\<exists>k. k * n \<le> l" for l :: nat
+    by (rule exI [of _ 0]) simp
+  have fin: "finite {k. k * n \<le> l}" if "n > 0" for l
+  proof -
+    from that have "{k. k * n \<le> l} \<subseteq> {k. k \<le> l}"
+      by (cases n) auto
+    then show ?thesis
+      by (rule finite_subset) simp
+  qed
+  have mult_div_unfold: "n * (m div n) = Max {l. l \<le> m \<and> n dvd l}"
+  proof (cases "n = 0")
+    case True
+    moreover have "{l. l = 0 \<and> l \<le> m} = {0::nat}"
+      by auto
+    ultimately show ?thesis
+      by simp
+  next
+    case False
+    with ex [of m] fin have "n * Max {k. k * n \<le> m} = Max (times n ` {k. k * n \<le> m})"
+      by (auto simp add: nat_mult_max_right intro: hom_Max_commute)
+    also have "times n ` {k. k * n \<le> m} = {l. l \<le> m \<and> n dvd l}"
+      by (auto simp add: ac_simps elim!: dvdE)
+    finally show ?thesis
+      using False by (simp add: divide_nat_def ac_simps)
+  qed
+  have less_eq: "m div n * n \<le> m"
+    by (auto simp add: mult_div_unfold ac_simps intro: Max.boundedI)
+  then show "m div n * n + m mod n = m"
+    by (simp add: modulo_nat_def)
+  assume "n \<noteq> 0"
+  show "euclidean_size (m mod n) < euclidean_size n"
+  proof -
+    have "m < Suc (m div n) * n"
+    proof (rule ccontr)
+      assume "\<not> m < Suc (m div n) * n"
+      then have "Suc (m div n) * n \<le> m"
+        by (simp add: not_less)
+      moreover from \<open>n \<noteq> 0\<close> have "Max {k. k * n \<le> m} < Suc (m div n)"
+        by (simp add: divide_nat_def)
+      with \<open>n \<noteq> 0\<close> ex fin have "\<And>k. k * n \<le> m \<Longrightarrow> k < Suc (m div n)"
+        by auto
+      ultimately have "Suc (m div n) < Suc (m div n)"
+        by blast
+      then show False
+        by simp
+    qed
+    with \<open>n \<noteq> 0\<close> show ?thesis
+      by (simp add: modulo_nat_def)
+  qed
+  show "euclidean_size m \<le> euclidean_size (m * n)"
+    using \<open>n \<noteq> 0\<close> by (cases n) simp_all
+  fix q r :: nat
+  show "(q * n + r) div n = q" if "euclidean_size r < euclidean_size n"
+  proof -
+    from that have "r < n"
+      by simp
+    have "k \<le> q" if "k * n \<le> q * n + r" for k
+    proof (rule ccontr)
+      assume "\<not> k \<le> q"
+      then have "q < k"
+        by simp
+      then obtain l where "k = Suc (q + l)"
+        by (auto simp add: less_iff_Suc_add)
+      with \<open>r < n\<close> that show False
+        by (simp add: algebra_simps)
+    qed
+    with \<open>n \<noteq> 0\<close> ex fin show ?thesis
+      by (auto simp add: divide_nat_def Max_eq_iff)
+  qed
+qed simp_all
+
+end
+
+lemma euclidean_relation_natI [case_names by0 divides euclidean_relation]:
+  \<open>(m div n, m mod n) = (q, r)\<close>
+    if by0: \<open>n = 0 \<Longrightarrow> q = 0 \<and> r = m\<close>
+    and divides: \<open>n > 0 \<Longrightarrow> n dvd m \<Longrightarrow> r = 0 \<and> m = q * n\<close>
+    and euclidean_relation: \<open>n > 0 \<Longrightarrow> \<not> n dvd m \<Longrightarrow> r < n \<and> m = q * n + r\<close> for m n q r :: nat
+  by (rule euclidean_relationI) (use that in simp_all)
+
+lemma div_nat_eqI:
+  \<open>m div n = q\<close> if \<open>n * q \<le> m\<close> and \<open>m < n * Suc q\<close> for m n q :: nat
+proof -
+  have \<open>(m div n, m mod n) = (q, m - n * q)\<close>
+  proof (cases n q \<open>m - n * q\<close>  m rule: euclidean_relation_natI)
+    case by0
+    with that show ?case
+      by simp
+  next
+    case divides
+    from \<open>n dvd m\<close> obtain s where \<open>m = n * s\<close> ..
+    with \<open>n > 0\<close> that have \<open>s < Suc q\<close>
+      by (simp only: mult_less_cancel1)
+    with \<open>m = n * s\<close> \<open>n > 0\<close> that have \<open>q = s\<close>
+      by simp
+    with \<open>m = n * s\<close> show ?case
+      by (simp add: ac_simps)
+  next
+    case euclidean_relation
+    with that show ?case
+      by (simp add: ac_simps)
+  qed
+  then show ?thesis
+    by simp
+qed
+
+lemma mod_nat_eqI:
+  \<open>m mod n = r\<close> if \<open>r < n\<close> and \<open>r \<le> m\<close> and \<open>n dvd m - r\<close> for m n r :: nat
+proof -
+  have \<open>(m div n, m mod n) = ((m - r) div n, r)\<close>
+  proof (cases n \<open>(m - r) div n\<close> r  m rule: euclidean_relation_natI)
+    case by0
+    with that show ?case
+      by simp
+  next
+    case divides
+    from that dvd_minus_add [of r \<open>m\<close> 1 n]
+    have \<open>n dvd m + (n - r)\<close>
+      by simp
+    with divides have \<open>n dvd n - r\<close>
+      by (simp add: dvd_add_right_iff)
+    then have \<open>n \<le> n - r\<close>
+      by (rule dvd_imp_le) (use \<open>r < n\<close> in simp)
+    with \<open>n > 0\<close> have \<open>r = 0\<close>
+      by simp
+    with \<open>n > 0\<close> that show ?case
+      by simp
+  next
+    case euclidean_relation
+    with that show ?case
+      by (simp add: ac_simps)
+  qed
+  then show ?thesis
+    by simp
+qed
+
+text \<open>Tool support\<close>
+
+ML \<open>
+structure Cancel_Div_Mod_Nat = Cancel_Div_Mod
+(
+  val div_name = \<^const_name>\<open>divide\<close>;
+  val mod_name = \<^const_name>\<open>modulo\<close>;
+  val mk_binop = HOLogic.mk_binop;
+  val dest_plus = HOLogic.dest_bin \<^const_name>\<open>Groups.plus\<close> HOLogic.natT;
+  val mk_sum = Arith_Data.mk_sum;
+  fun dest_sum tm =
+    if HOLogic.is_zero tm then []
+    else
+      (case try HOLogic.dest_Suc tm of
+        SOME t => HOLogic.Suc_zero :: dest_sum t
+      | NONE =>
+          (case try dest_plus tm of
+            SOME (t, u) => dest_sum t @ dest_sum u
+          | NONE => [tm]));
+
+  val div_mod_eqs = map mk_meta_eq @{thms cancel_div_mod_rules};
+
+  val prove_eq_sums = Arith_Data.prove_conv2 all_tac
+    (Arith_Data.simp_all_tac @{thms add_0_left add_0_right ac_simps})
+)
+\<close>
+
+simproc_setup cancel_div_mod_nat ("(m::nat) + n") =
+  \<open>K Cancel_Div_Mod_Nat.proc\<close>
+
+lemma div_mult_self_is_m [simp]:
+  "m * n div n = m" if "n > 0" for m n :: nat
+  using that by simp
+
+lemma div_mult_self1_is_m [simp]:
+  "n * m div n = m" if "n > 0" for m n :: nat
+  using that by simp
+
+lemma mod_less_divisor [simp]:
+  "m mod n < n" if "n > 0" for m n :: nat
+  using mod_size_less [of n m] that by simp
+
+lemma mod_le_divisor [simp]:
+  "m mod n \<le> n" if "n > 0" for m n :: nat
+  using that by (auto simp add: le_less)
+
+lemma div_times_less_eq_dividend [simp]:
+  "m div n * n \<le> m" for m n :: nat
+  by (simp add: minus_mod_eq_div_mult [symmetric])
+
+lemma times_div_less_eq_dividend [simp]:
+  "n * (m div n) \<le> m" for m n :: nat
+  using div_times_less_eq_dividend [of m n]
+  by (simp add: ac_simps)
+
+lemma dividend_less_div_times:
+  "m < n + (m div n) * n" if "0 < n" for m n :: nat
+proof -
+  from that have "m mod n < n"
+    by simp
+  then show ?thesis
+    by (simp add: minus_mod_eq_div_mult [symmetric])
+qed
+
+lemma dividend_less_times_div:
+  "m < n + n * (m div n)" if "0 < n" for m n :: nat
+  using dividend_less_div_times [of n m] that
+  by (simp add: ac_simps)
+
+lemma mod_Suc_le_divisor [simp]:
+  "m mod Suc n \<le> n"
+  using mod_less_divisor [of "Suc n" m] by arith
+
+lemma mod_less_eq_dividend [simp]:
+  "m mod n \<le> m" for m n :: nat
+proof (rule add_leD2)
+  from div_mult_mod_eq have "m div n * n + m mod n = m" .
+  then show "m div n * n + m mod n \<le> m" by auto
+qed
+
+lemma
+  div_less [simp]: "m div n = 0"
+  and mod_less [simp]: "m mod n = m"
+  if "m < n" for m n :: nat
+  using that by (auto intro: div_nat_eqI mod_nat_eqI)
+
+lemma split_div:
+  \<open>P (m div n) \<longleftrightarrow>
+    (n = 0 \<longrightarrow> P 0) \<and>
+    (n \<noteq> 0 \<longrightarrow> (\<forall>i j. j < n \<and> m = n * i + j \<longrightarrow> P i))\<close> (is ?div)
+  and split_mod:
+  \<open>Q (m mod n) \<longleftrightarrow>
+    (n = 0 \<longrightarrow> Q m) \<and>
+    (n \<noteq> 0 \<longrightarrow> (\<forall>i j. j < n \<and> m = n * i + j \<longrightarrow> Q j))\<close> (is ?mod)
+  for m n :: nat
+proof -
+  have *: \<open>R (m div n) (m mod n) \<longleftrightarrow>
+    (n = 0 \<longrightarrow> R 0 m) \<and>
+    (n \<noteq> 0 \<longrightarrow> (\<forall>i j. j < n \<and> m = n * i + j \<longrightarrow> R i j))\<close> for R
+    by (cases \<open>n = 0\<close>) auto
+  from * [of \<open>\<lambda>q _. P q\<close>] show ?div .
+  from * [of \<open>\<lambda>_ r. Q r\<close>] show ?mod .
+qed
+
+declare split_div [of _ _ \<open>numeral n\<close>, linarith_split] for n
+declare split_mod [of _ _ \<open>numeral n\<close>, linarith_split] for n
+
+lemma split_div':
+  "P (m div n) \<longleftrightarrow> n = 0 \<and> P 0 \<or> (\<exists>q. (n * q \<le> m \<and> m < n * Suc q) \<and> P q)"
+proof (cases "n = 0")
+  case True
+  then show ?thesis
+    by simp
+next
+  case False
+  then have "n * q \<le> m \<and> m < n * Suc q \<longleftrightarrow> m div n = q" for q
+    by (auto intro: div_nat_eqI dividend_less_times_div)
+  then show ?thesis
+    by auto
+qed
+
+lemma le_div_geq:
+  "m div n = Suc ((m - n) div n)" if "0 < n" and "n \<le> m" for m n :: nat
+proof -
+  from \<open>n \<le> m\<close> obtain q where "m = n + q"
+    by (auto simp add: le_iff_add)
+  with \<open>0 < n\<close> show ?thesis
+    by (simp add: div_add_self1)
+qed
+
+lemma le_mod_geq:
+  "m mod n = (m - n) mod n" if "n \<le> m" for m n :: nat
+proof -
+  from \<open>n \<le> m\<close> obtain q where "m = n + q"
+    by (auto simp add: le_iff_add)
+  then show ?thesis
+    by simp
+qed
+
+lemma div_if:
+  "m div n = (if m < n \<or> n = 0 then 0 else Suc ((m - n) div n))"
+  by (simp add: le_div_geq)
+
+lemma mod_if:
+  "m mod n = (if m < n then m else (m - n) mod n)" for m n :: nat
+  by (simp add: le_mod_geq)
+
+lemma div_eq_0_iff:
+  "m div n = 0 \<longleftrightarrow> m < n \<or> n = 0" for m n :: nat
+  by (simp add: div_eq_0_iff)
+
+lemma div_greater_zero_iff:
+  "m div n > 0 \<longleftrightarrow> n \<le> m \<and> n > 0" for m n :: nat
+  using div_eq_0_iff [of m n] by auto
+
+lemma mod_greater_zero_iff_not_dvd:
+  "m mod n > 0 \<longleftrightarrow> \<not> n dvd m" for m n :: nat
+  by (simp add: dvd_eq_mod_eq_0)
+
+lemma div_by_Suc_0 [simp]:
+  "m div Suc 0 = m"
+  using div_by_1 [of m] by simp
+
+lemma mod_by_Suc_0 [simp]:
+  "m mod Suc 0 = 0"
+  using mod_by_1 [of m] by simp
+
+lemma div2_Suc_Suc [simp]:
+  "Suc (Suc m) div 2 = Suc (m div 2)"
+  by (simp add: numeral_2_eq_2 le_div_geq)
+
+lemma Suc_n_div_2_gt_zero [simp]:
+  "0 < Suc n div 2" if "n > 0" for n :: nat
+  using that by (cases n) simp_all
+
+lemma div_2_gt_zero [simp]:
+  "0 < n div 2" if "Suc 0 < n" for n :: nat
+  using that Suc_n_div_2_gt_zero [of "n - 1"] by simp
+
+lemma mod2_Suc_Suc [simp]:
+  "Suc (Suc m) mod 2 = m mod 2"
+  by (simp add: numeral_2_eq_2 le_mod_geq)
+
+lemma add_self_div_2 [simp]:
+  "(m + m) div 2 = m" for m :: nat
+  by (simp add: mult_2 [symmetric])
+
+lemma add_self_mod_2 [simp]:
+  "(m + m) mod 2 = 0" for m :: nat
+  by (simp add: mult_2 [symmetric])
+
+lemma mod2_gr_0 [simp]:
+  "0 < m mod 2 \<longleftrightarrow> m mod 2 = 1" for m :: nat
+proof -
+  have "m mod 2 < 2"
+    by (rule mod_less_divisor) simp
+  then have "m mod 2 = 0 \<or> m mod 2 = 1"
+    by arith
+  then show ?thesis
+    by auto
+qed
+
+lemma mod_Suc_eq [mod_simps]:
+  "Suc (m mod n) mod n = Suc m mod n"
+proof -
+  have "(m mod n + 1) mod n = (m + 1) mod n"
+    by (simp only: mod_simps)
+  then show ?thesis
+    by simp
+qed
+
+lemma mod_Suc_Suc_eq [mod_simps]:
+  "Suc (Suc (m mod n)) mod n = Suc (Suc m) mod n"
+proof -
+  have "(m mod n + 2) mod n = (m + 2) mod n"
+    by (simp only: mod_simps)
+  then show ?thesis
+    by simp
+qed
+
+lemma
+  Suc_mod_mult_self1 [simp]: "Suc (m + k * n) mod n = Suc m mod n"
+  and Suc_mod_mult_self2 [simp]: "Suc (m + n * k) mod n = Suc m mod n"
+  and Suc_mod_mult_self3 [simp]: "Suc (k * n + m) mod n = Suc m mod n"
+  and Suc_mod_mult_self4 [simp]: "Suc (n * k + m) mod n = Suc m mod n"
+  by (subst mod_Suc_eq [symmetric], simp add: mod_simps)+
+
+lemma Suc_0_mod_eq [simp]:
+  "Suc 0 mod n = of_bool (n \<noteq> Suc 0)"
+  by (cases n) simp_all
+
+lemma div_mult2_eq:
+    \<open>m div (n * q) = (m div n) div q\<close> (is ?Q)
+  and mod_mult2_eq:
+    \<open>m mod (n * q) = n * (m div n mod q) + m mod n\<close> (is ?R)
+  for m n q :: nat
+proof -
+  have \<open>(m div (n * q), m mod (n * q)) = ((m div n) div q, n * (m div n mod q) + m mod n)\<close>
+  proof (cases \<open>n * q\<close> \<open>(m div n) div q\<close> \<open>n * (m div n mod q) + m mod n\<close> m rule: euclidean_relation_natI)
+    case by0
+    then show ?case
+      by auto
+  next
+    case divides
+    from \<open>n * q dvd m\<close> obtain t where \<open>m = n * q * t\<close> ..
+    with \<open>n * q > 0\<close> show ?case
+      by (simp add: algebra_simps)
+  next
+    case euclidean_relation
+    then have \<open>n > 0\<close> \<open>q > 0\<close>
+      by simp_all
+    from \<open>n > 0\<close> have \<open>m mod n < n\<close>
+      by (rule mod_less_divisor)
+    from \<open>q > 0\<close> have \<open>m div n mod q < q\<close>
+      by (rule mod_less_divisor)
+    then obtain s where \<open>q = Suc (m div n mod q + s)\<close>
+      by (blast dest: less_imp_Suc_add)
+    moreover have \<open>m mod n + n * (m div n mod q) < n * Suc (m div n mod q + s)\<close>
+      using \<open>m mod n < n\<close> by (simp add: add_mult_distrib2)
+    ultimately have \<open>m mod n + n * (m div n mod q) < n * q\<close>
+      by simp
+    then show ?case
+      by (simp add: algebra_simps flip: add_mult_distrib2)
+  qed
+  then show ?Q and ?R
+    by simp_all
+qed
+
+lemma div_le_mono:
+  "m div k \<le> n div k" if "m \<le> n" for m n k :: nat
+proof -
+  from that obtain q where "n = m + q"
+    by (auto simp add: le_iff_add)
+  then show ?thesis
+    by (simp add: div_add1_eq [of m q k])
+qed
+
+text \<open>Antimonotonicity of \<^const>\<open>divide\<close> in second argument\<close>
+
+lemma div_le_mono2:
+  "k div n \<le> k div m" if "0 < m" and "m \<le> n" for m n k :: nat
+using that proof (induct k arbitrary: m rule: less_induct)
+  case (less k)
+  show ?case
+  proof (cases "n \<le> k")
+    case False
+    then show ?thesis
+      by simp
+  next
+    case True
+    have "(k - n) div n \<le> (k - m) div n"
+      using less.prems
+      by (blast intro: div_le_mono diff_le_mono2)
+    also have "\<dots> \<le> (k - m) div m"
+      using \<open>n \<le> k\<close> less.prems less.hyps [of "k - m" m]
+      by simp
+    finally show ?thesis
+      using \<open>n \<le> k\<close> less.prems
+      by (simp add: le_div_geq)
+  qed
+qed
+
+lemma div_le_dividend [simp]:
+  "m div n \<le> m" for m n :: nat
+  using div_le_mono2 [of 1 n m] by (cases "n = 0") simp_all
+
+lemma div_less_dividend [simp]:
+  "m div n < m" if "1 < n" and "0 < m" for m n :: nat
+using that proof (induct m rule: less_induct)
+  case (less m)
+  show ?case
+  proof (cases "n < m")
+    case False
+    with less show ?thesis
+      by (cases "n = m") simp_all
+  next
+    case True
+    then show ?thesis
+      using less.hyps [of "m - n"] less.prems
+      by (simp add: le_div_geq)
+  qed
+qed
+
+lemma div_eq_dividend_iff:
+  "m div n = m \<longleftrightarrow> n = 1" if "m > 0" for m n :: nat
+proof
+  assume "n = 1"
+  then show "m div n = m"
+    by simp
+next
+  assume P: "m div n = m"
+  show "n = 1"
+  proof (rule ccontr)
+    have "n \<noteq> 0"
+      by (rule ccontr) (use that P in auto)
+    moreover assume "n \<noteq> 1"
+    ultimately have "n > 1"
+      by simp
+    with that have "m div n < m"
+      by simp
+    with P show False
+      by simp
+  qed
+qed
+
+lemma less_mult_imp_div_less:
+  "m div n < i" if "m < i * n" for m n i :: nat
+proof -
+  from that have "i * n > 0"
+    by (cases "i * n = 0") simp_all
+  then have "i > 0" and "n > 0"
+    by simp_all
+  have "m div n * n \<le> m"
+    by simp
+  then have "m div n * n < i * n"
+    using that by (rule le_less_trans)
+  with \<open>n > 0\<close> show ?thesis
+    by simp
+qed
+
+lemma div_less_iff_less_mult:
+  \<open>m div q < n \<longleftrightarrow> m < n * q\<close> (is \<open>?P \<longleftrightarrow> ?Q\<close>)
+  if \<open>q > 0\<close> for m n q :: nat
+proof
+  assume ?Q then show ?P
+    by (rule less_mult_imp_div_less)
+next
+  assume ?P
+  then obtain h where \<open>n = Suc (m div q + h)\<close>
+    using less_natE by blast
+  moreover have \<open>m < m + (Suc h * q - m mod q)\<close>
+    using that by (simp add: trans_less_add1)
+  ultimately show ?Q
+    by (simp add: algebra_simps flip: minus_mod_eq_mult_div)
+qed
+
+lemma less_eq_div_iff_mult_less_eq:
+  \<open>m \<le> n div q \<longleftrightarrow> m * q \<le> n\<close> if \<open>q > 0\<close> for m n q :: nat
+  using div_less_iff_less_mult [of q n m] that by auto
+
+lemma div_Suc:
+  \<open>Suc m div n = (if Suc m mod n = 0 then Suc (m div n) else m div n)\<close>  (is "_ = ?rhs")
+proof (cases \<open>n = 0 \<or> n = 1\<close>)
+  case True
+  then show ?thesis by auto
+next
+  case False
+  then have \<open>n > 1\<close>
+    by simp
+  then have *: \<open>Suc 0 div n = 0\<close>
+    by (simp add: div_eq_0_iff)
+  have \<open>(m + 1) div n = ?rhs\<close>
+  proof (cases \<open>n dvd Suc m\<close>)
+    case True
+    then obtain q where \<open>Suc m = n * q\<close> ..
+    then have m: \<open>m = n * q - 1\<close>
+      by simp
+    have \<open>q > 0\<close> by (rule ccontr)
+      (use \<open>Suc m = n * q\<close> in simp)
+    from m have \<open>m mod n = (n * q - 1) mod n\<close>
+      by simp
+    also have \<open>\<dots> = (n * q - 1 + n) mod n\<close>
+      by simp
+    also have \<open>n * q - 1 + n = n * q + (n - 1)\<close>
+      using \<open>n > 1\<close> \<open>q > 0\<close> by (simp add: algebra_simps)
+    finally have \<open>m mod n = (n - 1) mod n\<close>
+      by simp
+    with \<open>n > 1\<close> have \<open>m mod n = n - 1\<close>
+      by simp
+    with True \<open>n > 1\<close> show ?thesis
+      by (subst div_add1_eq) auto
+  next
+    case False
+    have \<open>Suc (m mod n) \<noteq> n\<close>
+    proof (rule ccontr)
+      assume \<open>\<not> Suc (m mod n) \<noteq> n\<close>
+      then have \<open>m mod n = n - 1\<close>
+        by simp
+      with \<open>n > 1\<close> have \<open>(m + 1) mod n = 0\<close>
+        by (subst mod_add_left_eq [symmetric]) simp
+      then have \<open>n dvd Suc m\<close>
+        by auto
+      with False show False ..
+    qed
+    moreover have \<open>Suc (m mod n) \<le> n\<close>
+      using \<open>n > 1\<close> by (simp add: Suc_le_eq)
+    ultimately have \<open>Suc (m mod n) < n\<close>
+      by simp
+    with False \<open>n > 1\<close> show ?thesis
+      by (subst div_add1_eq) (auto simp add: div_eq_0_iff mod_greater_zero_iff_not_dvd)
+  qed
+  then show ?thesis
+    by simp
+qed
+
+lemma mod_Suc:
+  \<open>Suc m mod n = (if Suc (m mod n) = n then 0 else Suc (m mod n))\<close>  (is "_ = ?rhs")
+proof (cases "n = 0")
+  case True
+  then show ?thesis
+    by simp
+next
+  case False
+  have "Suc m mod n = Suc (m mod n) mod n"
+    by (simp add: mod_simps)
+  also have "\<dots> = ?rhs"
+    using False by (auto intro!: mod_nat_eqI intro: neq_le_trans simp add: Suc_le_eq)
+  finally show ?thesis .
+qed
+
+lemma Suc_times_mod_eq:
+  "Suc (m * n) mod m = 1" if "Suc 0 < m"
+  using that by (simp add: mod_Suc)
+
+lemma Suc_times_numeral_mod_eq [simp]:
+  "Suc (numeral k * n) mod numeral k = 1" if "numeral k \<noteq> (1::nat)"
+  by (rule Suc_times_mod_eq) (use that in simp)
+
+lemma Suc_div_le_mono [simp]:
+  "m div n \<le> Suc m div n"
+  by (simp add: div_le_mono)
+
+text \<open>These lemmas collapse some needless occurrences of Suc:
+  at least three Sucs, since two and fewer are rewritten back to Suc again!
+  We already have some rules to simplify operands smaller than 3.\<close>
+
+lemma div_Suc_eq_div_add3 [simp]:
+  "m div Suc (Suc (Suc n)) = m div (3 + n)"
+  by (simp add: Suc3_eq_add_3)
+
+lemma mod_Suc_eq_mod_add3 [simp]:
+  "m mod Suc (Suc (Suc n)) = m mod (3 + n)"
+  by (simp add: Suc3_eq_add_3)
+
+lemma Suc_div_eq_add3_div:
+  "Suc (Suc (Suc m)) div n = (3 + m) div n"
+  by (simp add: Suc3_eq_add_3)
+
+lemma Suc_mod_eq_add3_mod:
+  "Suc (Suc (Suc m)) mod n = (3 + m) mod n"
+  by (simp add: Suc3_eq_add_3)
+
+lemmas Suc_div_eq_add3_div_numeral [simp] =
+  Suc_div_eq_add3_div [of _ "numeral v"] for v
+
+lemmas Suc_mod_eq_add3_mod_numeral [simp] =
+  Suc_mod_eq_add3_mod [of _ "numeral v"] for v
+
+lemma (in field_char_0) of_nat_div:
+  "of_nat (m div n) = ((of_nat m - of_nat (m mod n)) / of_nat n)"
+proof -
+  have "of_nat (m div n) = ((of_nat (m div n * n + m mod n) - of_nat (m mod n)) / of_nat n :: 'a)"
+    unfolding of_nat_add by (cases "n = 0") simp_all
+  then show ?thesis
+    by simp
+qed
+
+text \<open>An ``induction'' law for modulus arithmetic.\<close>
+
+lemma mod_induct [consumes 3, case_names step]:
+  "P m" if "P n" and "n < p" and "m < p"
+    and step: "\<And>n. n < p \<Longrightarrow> P n \<Longrightarrow> P (Suc n mod p)"
+using \<open>m < p\<close> proof (induct m)
+  case 0
+  show ?case
+  proof (rule ccontr)
+    assume "\<not> P 0"
+    from \<open>n < p\<close> have "0 < p"
+      by simp
+    from \<open>n < p\<close> obtain m where "0 < m" and "p = n + m"
+      by (blast dest: less_imp_add_positive)
+    with \<open>P n\<close> have "P (p - m)"
+      by simp
+    moreover have "\<not> P (p - m)"
+    using \<open>0 < m\<close> proof (induct m)
+      case 0
+      then show ?case
+        by simp
+    next
+      case (Suc m)
+      show ?case
+      proof
+        assume P: "P (p - Suc m)"
+        with \<open>\<not> P 0\<close> have "Suc m < p"
+          by (auto intro: ccontr)
+        then have "Suc (p - Suc m) = p - m"
+          by arith
+        moreover from \<open>0 < p\<close> have "p - Suc m < p"
+          by arith
+        with P step have "P ((Suc (p - Suc m)) mod p)"
+          by blast
+        ultimately show False
+          using \<open>\<not> P 0\<close> Suc.hyps by (cases "m = 0") simp_all
+      qed
+    qed
+    ultimately show False
+      by blast
+  qed
+next
+  case (Suc m)
+  then have "m < p" and mod: "Suc m mod p = Suc m"
+    by simp_all
+  from \<open>m < p\<close> have "P m"
+    by (rule Suc.hyps)
+  with \<open>m < p\<close> have "P (Suc m mod p)"
+    by (rule step)
+  with mod show ?case
+    by simp
+qed
+
+lemma funpow_mod_eq: \<^marker>\<open>contributor \<open>Lars Noschinski\<close>\<close>
+  \<open>(f ^^ (m mod n)) x = (f ^^ m) x\<close> if \<open>(f ^^ n) x = x\<close>
+proof -
+  have \<open>(f ^^ m) x = (f ^^ (m mod n + m div n * n)) x\<close>
+    by simp
+  also have \<open>\<dots> = (f ^^ (m mod n)) (((f ^^ n) ^^ (m div n)) x)\<close>
+    by (simp only: funpow_add funpow_mult ac_simps) simp
+  also have \<open>((f ^^ n) ^^ q) x = x\<close> for q
+    by (induction q) (use \<open>(f ^^ n) x = x\<close> in simp_all)
+  finally show ?thesis
+    by simp
+qed
+
+lemma mod_eq_dvd_iff_nat:
+  \<open>m mod q = n mod q \<longleftrightarrow> q dvd m - n\<close> (is \<open>?P \<longleftrightarrow> ?Q\<close>)
+    if \<open>m \<ge> n\<close> for m n q :: nat
+proof
+  assume ?Q
+  then obtain s where \<open>m - n = q * s\<close> ..
+  with that have \<open>m = q * s + n\<close>
+    by simp
+  then show ?P
+    by simp
+next
+  assume ?P
+  have \<open>m - n = m div q * q + m mod q - (n div q * q + n mod q)\<close>
+    by simp
+  also have \<open>\<dots> = q * (m div q - n div q)\<close>
+    by (simp only: algebra_simps \<open>?P\<close>)
+  finally show ?Q ..
+qed
+
+lemma mod_eq_iff_dvd_symdiff_nat:
+  \<open>m mod q = n mod q \<longleftrightarrow> q dvd nat \<bar>int m - int n\<bar>\<close>
+  by (auto simp add: abs_if mod_eq_dvd_iff_nat nat_diff_distrib dest: sym intro: sym)
+
+lemma mod_eq_nat1E:
+  fixes m n q :: nat
+  assumes "m mod q = n mod q" and "m \<ge> n"
+  obtains s where "m = n + q * s"
+proof -
+  from assms have "q dvd m - n"
+    by (simp add: mod_eq_dvd_iff_nat)
+  then obtain s where "m - n = q * s" ..
+  with \<open>m \<ge> n\<close> have "m = n + q * s"
+    by simp
+  with that show thesis .
+qed
+
+lemma mod_eq_nat2E:
+  fixes m n q :: nat
+  assumes "m mod q = n mod q" and "n \<ge> m"
+  obtains s where "n = m + q * s"
+  using assms mod_eq_nat1E [of n q m] by (auto simp add: ac_simps)
+
+lemma nat_mod_eq_iff:
+  "(x::nat) mod n = y mod n \<longleftrightarrow> (\<exists>q1 q2. x + n * q1 = y + n * q2)"  (is "?lhs = ?rhs")
+proof
+  assume H: "x mod n = y mod n"
+  { assume xy: "x \<le> y"
+    from H have th: "y mod n = x mod n" by simp
+    from mod_eq_nat1E [OF th xy] obtain q where "y = x + n * q" .
+    then have "x + n * q = y + n * 0"
+      by simp
+    then have "\<exists>q1 q2. x + n * q1 = y + n * q2"
+      by blast
+  }
+  moreover
+  { assume xy: "y \<le> x"
+    from mod_eq_nat1E [OF H xy] obtain q where "x = y + n * q" .
+    then have "x + n * 0 = y + n * q"
+      by simp
+    then have "\<exists>q1 q2. x + n * q1 = y + n * q2"
+      by blast
+  }
+  ultimately show ?rhs using linear[of x y] by blast
+next
+  assume ?rhs then obtain q1 q2 where q12: "x + n * q1 = y + n * q2" by blast
+  hence "(x + n * q1) mod n = (y + n * q2) mod n" by simp
+  thus  ?lhs by simp
+qed
+
+
+
+subsection \<open>Elementary euclidean division on \<^typ>\<open>int\<close>\<close>
+
+subsubsection \<open>Basic instantiation\<close>
+
+instantiation int :: "{normalization_semidom, idom_modulo}"
+begin
+
+definition normalize_int :: \<open>int \<Rightarrow> int\<close>
+  where [simp]: \<open>normalize = (abs :: int \<Rightarrow> int)\<close>
+
+definition unit_factor_int :: \<open>int \<Rightarrow> int\<close>
+  where [simp]: \<open>unit_factor = (sgn :: int \<Rightarrow> int)\<close>
+
+definition divide_int :: \<open>int \<Rightarrow> int \<Rightarrow> int\<close>
+  where \<open>k div l = (sgn k * sgn l * int (nat \<bar>k\<bar> div nat \<bar>l\<bar>)
+    - of_bool (l \<noteq> 0 \<and> sgn k \<noteq> sgn l \<and> \<not> l dvd k))\<close>
+
+lemma divide_int_unfold:
+  \<open>(sgn k * int m) div (sgn l * int n) = (sgn k * sgn l * int (m div n)
+    - of_bool ((k = 0 \<longleftrightarrow> m = 0) \<and> l \<noteq> 0 \<and> n \<noteq> 0 \<and> sgn k \<noteq> sgn l \<and> \<not> n dvd m))\<close>
+  by (simp add: divide_int_def sgn_mult nat_mult_distrib abs_mult sgn_eq_0_iff ac_simps)
+
+definition modulo_int :: \<open>int \<Rightarrow> int \<Rightarrow> int\<close>
+  where \<open>k mod l = sgn k * int (nat \<bar>k\<bar> mod nat \<bar>l\<bar>) + l * of_bool (sgn k \<noteq> sgn l \<and> \<not> l dvd k)\<close>
+
+lemma modulo_int_unfold:
+  \<open>(sgn k * int m) mod (sgn l * int n) =
+    sgn k * int (m mod (of_bool (l \<noteq> 0) * n)) + (sgn l * int n) * of_bool ((k = 0 \<longleftrightarrow> m = 0) \<and> sgn k \<noteq> sgn l \<and> \<not> n dvd m)\<close>
+  by (auto simp add: modulo_int_def sgn_mult abs_mult)
+
+instance proof
+  fix k :: int show "k div 0 = 0"
+  by (simp add: divide_int_def)
+next
+  fix k l :: int
+  assume "l \<noteq> 0"
+  obtain n m and s t where k: "k = sgn s * int n" and l: "l = sgn t * int m"
+    by (blast intro: int_sgnE elim: that)
+  then have "k * l = sgn (s * t) * int (n * m)"
+    by (simp add: ac_simps sgn_mult)
+  with k l \<open>l \<noteq> 0\<close> show "k * l div l = k"
+    by (simp only: divide_int_unfold)
+      (auto simp add: algebra_simps sgn_mult sgn_1_pos sgn_0_0)
+next
+  fix k l :: int
+  obtain n m and s t where "k = sgn s * int n" and "l = sgn t * int m"
+    by (blast intro: int_sgnE elim: that)
+  then show "k div l * l + k mod l = k"
+    by (simp add: divide_int_unfold modulo_int_unfold algebra_simps modulo_nat_def of_nat_diff)
+qed (auto simp add: sgn_mult mult_sgn_abs abs_eq_iff')
+
+end
+
+
+subsubsection \<open>Algebraic foundations\<close>
+
+lemma coprime_int_iff [simp]:
+  "coprime (int m) (int n) \<longleftrightarrow> coprime m n" (is "?P \<longleftrightarrow> ?Q")
+proof
+  assume ?P
+  show ?Q
+  proof (rule coprimeI)
+    fix q
+    assume "q dvd m" "q dvd n"
+    then have "int q dvd int m" "int q dvd int n"
+      by simp_all
+    with \<open>?P\<close> have "is_unit (int q)"
+      by (rule coprime_common_divisor)
+    then show "is_unit q"
+      by simp
+  qed
+next
+  assume ?Q
+  show ?P
+  proof (rule coprimeI)
+    fix k
+    assume "k dvd int m" "k dvd int n"
+    then have "nat \<bar>k\<bar> dvd m" "nat \<bar>k\<bar> dvd n"
+      by simp_all
+    with \<open>?Q\<close> have "is_unit (nat \<bar>k\<bar>)"
+      by (rule coprime_common_divisor)
+    then show "is_unit k"
+      by simp
+  qed
+qed
+
+lemma coprime_abs_left_iff [simp]:
+  "coprime \<bar>k\<bar> l \<longleftrightarrow> coprime k l" for k l :: int
+  using coprime_normalize_left_iff [of k l] by simp
+
+lemma coprime_abs_right_iff [simp]:
+  "coprime k \<bar>l\<bar> \<longleftrightarrow> coprime k l" for k l :: int
+  using coprime_abs_left_iff [of l k] by (simp add: ac_simps)
+
+lemma coprime_nat_abs_left_iff [simp]:
+  "coprime (nat \<bar>k\<bar>) n \<longleftrightarrow> coprime k (int n)"
+proof -
+  define m where "m = nat \<bar>k\<bar>"
+  then have "\<bar>k\<bar> = int m"
+    by simp
+  moreover have "coprime k (int n) \<longleftrightarrow> coprime \<bar>k\<bar> (int n)"
+    by simp
+  ultimately show ?thesis
+    by simp
+qed
+
+lemma coprime_nat_abs_right_iff [simp]:
+  "coprime n (nat \<bar>k\<bar>) \<longleftrightarrow> coprime (int n) k"
+  using coprime_nat_abs_left_iff [of k n] by (simp add: ac_simps)
+
+lemma coprime_common_divisor_int: "coprime a b \<Longrightarrow> x dvd a \<Longrightarrow> x dvd b \<Longrightarrow> \<bar>x\<bar> = 1"
+  for a b :: int
+  by (drule coprime_common_divisor [of _ _ x]) simp_all
+
+
+subsubsection \<open>Basic conversions\<close>
+
+lemma div_abs_eq_div_nat:
+  "\<bar>k\<bar> div \<bar>l\<bar> = int (nat \<bar>k\<bar> div nat \<bar>l\<bar>)"
+  by (auto simp add: divide_int_def)
+
+lemma div_eq_div_abs:
+  \<open>k div l = sgn k * sgn l * (\<bar>k\<bar> div \<bar>l\<bar>)
+    - of_bool (l \<noteq> 0 \<and> sgn k \<noteq> sgn l \<and> \<not> l dvd k)\<close>
+  for k l :: int
+  by (simp add: divide_int_def [of k l] div_abs_eq_div_nat)
+
+lemma div_abs_eq:
+  \<open>\<bar>k\<bar> div \<bar>l\<bar> = sgn k * sgn l * (k div l + of_bool (sgn k \<noteq> sgn l \<and> \<not> l dvd k))\<close>
+  for k l :: int
+  by (simp add: div_eq_div_abs [of k l] ac_simps)
+
+lemma mod_abs_eq_div_nat:
+  "\<bar>k\<bar> mod \<bar>l\<bar> = int (nat \<bar>k\<bar> mod nat \<bar>l\<bar>)"
+  by (simp add: modulo_int_def)
+
+lemma mod_eq_mod_abs:
+  \<open>k mod l = sgn k * (\<bar>k\<bar> mod \<bar>l\<bar>) + l * of_bool (sgn k \<noteq> sgn l \<and> \<not> l dvd k)\<close>
+  for k l :: int
+  by (simp add: modulo_int_def [of k l] mod_abs_eq_div_nat)
+
+lemma mod_abs_eq:
+  \<open>\<bar>k\<bar> mod \<bar>l\<bar> = sgn k * (k mod l - l * of_bool (sgn k \<noteq> sgn l \<and> \<not> l dvd k))\<close>
+  for k l :: int
+  by (auto simp: mod_eq_mod_abs [of k l])
+
+lemma div_sgn_abs_cancel:
+  fixes k l v :: int
+  assumes "v \<noteq> 0"
+  shows "(sgn v * \<bar>k\<bar>) div (sgn v * \<bar>l\<bar>) = \<bar>k\<bar> div \<bar>l\<bar>"
+  using assms by (simp add: sgn_mult abs_mult sgn_0_0
+    divide_int_def [of "sgn v * \<bar>k\<bar>" "sgn v * \<bar>l\<bar>"] flip: div_abs_eq_div_nat)
+
+lemma div_eq_sgn_abs:
+  fixes k l v :: int
+  assumes "sgn k = sgn l"
+  shows "k div l = \<bar>k\<bar> div \<bar>l\<bar>"
+  using assms by (auto simp add: div_abs_eq)
+
+lemma div_dvd_sgn_abs:
+  fixes k l :: int
+  assumes "l dvd k"
+  shows "k div l = (sgn k * sgn l) * (\<bar>k\<bar> div \<bar>l\<bar>)"
+  using assms by (auto simp add: div_abs_eq ac_simps)
+
+lemma div_noneq_sgn_abs:
+  fixes k l :: int
+  assumes "l \<noteq> 0"
+  assumes "sgn k \<noteq> sgn l"
+  shows "k div l = - (\<bar>k\<bar> div \<bar>l\<bar>) - of_bool (\<not> l dvd k)"
+  using assms by (auto simp add: div_abs_eq ac_simps sgn_0_0 dest!: sgn_not_eq_imp)
+
+
+subsubsection \<open>Euclidean division\<close>
+
+instantiation int :: unique_euclidean_ring
+begin
+
+definition euclidean_size_int :: "int \<Rightarrow> nat"
+  where [simp]: "euclidean_size_int = (nat \<circ> abs :: int \<Rightarrow> nat)"
+
+definition division_segment_int :: "int \<Rightarrow> int"
+  where "division_segment_int k = (if k \<ge> 0 then 1 else - 1)"
+
+lemma division_segment_eq_sgn:
+  "division_segment k = sgn k" if "k \<noteq> 0" for k :: int
+  using that by (simp add: division_segment_int_def)
+
+lemma abs_division_segment [simp]:
+  "\<bar>division_segment k\<bar> = 1" for k :: int
+  by (simp add: division_segment_int_def)
+
+lemma abs_mod_less:
+  "\<bar>k mod l\<bar> < \<bar>l\<bar>" if "l \<noteq> 0" for k l :: int
+proof -
+  obtain n m and s t where "k = sgn s * int n" and "l = sgn t * int m"
+    by (blast intro: int_sgnE elim: that)
+  with that show ?thesis
+    by (auto simp add: modulo_int_unfold abs_mult mod_greater_zero_iff_not_dvd
+        simp flip: right_diff_distrib dest!: sgn_not_eq_imp)
+      (simp add: sgn_0_0)
+qed
+
+lemma sgn_mod:
+  "sgn (k mod l) = sgn l" if "l \<noteq> 0" "\<not> l dvd k" for k l :: int
+proof -
+  obtain n m and s t where "k = sgn s * int n" and "l = sgn t * int m"
+    by (blast intro: int_sgnE elim: that)
+  with that show ?thesis
+    by (auto simp add: modulo_int_unfold sgn_mult mod_greater_zero_iff_not_dvd
+      simp flip: right_diff_distrib dest!: sgn_not_eq_imp)
+qed
+
+instance proof
+  fix k l :: int
+  show "division_segment (k mod l) = division_segment l" if
+    "l \<noteq> 0" and "\<not> l dvd k"
+    using that by (simp add: division_segment_eq_sgn dvd_eq_mod_eq_0 sgn_mod)
+next
+  fix l q r :: int
+  obtain n m and s t
+     where l: "l = sgn s * int n" and q: "q = sgn t * int m"
+    by (blast intro: int_sgnE elim: that)
+  assume \<open>l \<noteq> 0\<close>
+  with l have "s \<noteq> 0" and "n > 0"
+    by (simp_all add: sgn_0_0)
+  assume "division_segment r = division_segment l"
+  moreover have "r = sgn r * \<bar>r\<bar>"
+    by (simp add: sgn_mult_abs)
+  moreover define u where "u = nat \<bar>r\<bar>"
+  ultimately have "r = sgn l * int u"
+    using division_segment_eq_sgn \<open>l \<noteq> 0\<close> by (cases "r = 0") simp_all
+  with l \<open>n > 0\<close> have r: "r = sgn s * int u"
+    by (simp add: sgn_mult)
+  assume "euclidean_size r < euclidean_size l"
+  with l r \<open>s \<noteq> 0\<close> have "u < n"
+    by (simp add: abs_mult)
+  show "(q * l + r) div l = q"
+  proof (cases "q = 0 \<or> r = 0")
+    case True
+    then show ?thesis
+    proof
+      assume "q = 0"
+      then show ?thesis
+        using l r \<open>u < n\<close> by (simp add: divide_int_unfold)
+    next
+      assume "r = 0"
+      from \<open>r = 0\<close> have *: "q * l + r = sgn (t * s) * int (n * m)"
+        using q l by (simp add: ac_simps sgn_mult)
+      from \<open>s \<noteq> 0\<close> \<open>n > 0\<close> show ?thesis
+        by (simp only: *, simp only: * q l divide_int_unfold)
+          (auto simp add: sgn_mult ac_simps)
+    qed
+  next
+    case False
+    with q r have "t \<noteq> 0" and "m > 0" and "s \<noteq> 0" and "u > 0"
+      by (simp_all add: sgn_0_0)
+    moreover from \<open>0 < m\<close> \<open>u < n\<close> have "u \<le> m * n"
+      using mult_le_less_imp_less [of 1 m u n] by simp
+    ultimately have *: "q * l + r = sgn (s * t)
+      * int (if t < 0 then m * n - u else m * n + u)"
+      using l q r
+      by (simp add: sgn_mult algebra_simps of_nat_diff)
+    have "(m * n - u) div n = m - 1" if "u > 0"
+      using \<open>0 < m\<close> \<open>u < n\<close> that
+      by (auto intro: div_nat_eqI simp add: algebra_simps)
+    moreover have "n dvd m * n - u \<longleftrightarrow> n dvd u"
+      using \<open>u \<le> m * n\<close> dvd_diffD1 [of n "m * n" u]
+      by auto
+    ultimately show ?thesis
+      using \<open>s \<noteq> 0\<close> \<open>m > 0\<close> \<open>u > 0\<close> \<open>u < n\<close> \<open>u \<le> m * n\<close>
+      by (simp only: *, simp only: l q divide_int_unfold)
+        (auto simp add: sgn_mult sgn_0_0 sgn_1_pos algebra_simps dest: dvd_imp_le)
+  qed
+qed (use mult_le_mono2 [of 1] in \<open>auto simp add: division_segment_int_def not_le zero_less_mult_iff mult_less_0_iff abs_mult sgn_mult abs_mod_less sgn_mod nat_mult_distrib\<close>)
+
+end
+
+lemma euclidean_relation_intI [case_names by0 divides euclidean_relation]:
+  \<open>(k div l, k mod l) = (q, r)\<close>
+    if by0': \<open>l = 0 \<Longrightarrow> q = 0 \<and> r = k\<close>
+    and divides': \<open>l \<noteq> 0 \<Longrightarrow> l dvd k \<Longrightarrow> r = 0 \<and> k = q * l\<close>
+    and euclidean_relation': \<open>l \<noteq> 0 \<Longrightarrow> \<not> l dvd k \<Longrightarrow> sgn r = sgn l
+      \<and> \<bar>r\<bar> < \<bar>l\<bar> \<and> k = q * l + r\<close> for k l :: int
+proof (cases l q r k rule: euclidean_relationI)
+  case by0
+  then show ?case
+    by (rule by0')
+next
+  case divides
+  then show ?case
+    by (rule divides')
+next
+  case euclidean_relation
+  with euclidean_relation' have \<open>sgn r = sgn l\<close> \<open>\<bar>r\<bar> < \<bar>l\<bar>\<close> \<open>k = q * l + r\<close>
+    by simp_all
+  from \<open>sgn r = sgn l\<close> \<open>l \<noteq> 0\<close> have \<open>division_segment r = division_segment l\<close>
+    by (simp add: division_segment_int_def sgn_if split: if_splits)
+  with \<open>\<bar>r\<bar> < \<bar>l\<bar>\<close> \<open>k = q * l + r\<close>
+  show ?case
+    by simp
+qed
+
+
+subsection \<open>Special case: euclidean rings containing the natural numbers\<close>
+
+class unique_euclidean_semiring_with_nat = semidom + semiring_char_0 + unique_euclidean_semiring +
+  assumes of_nat_div: "of_nat (m div n) = of_nat m div of_nat n"
+    and division_segment_of_nat [simp]: "division_segment (of_nat n) = 1"
+    and division_segment_euclidean_size [simp]: "division_segment a * of_nat (euclidean_size a) = a"
+begin
+
+lemma division_segment_eq_iff:
+  "a = b" if "division_segment a = division_segment b"
+    and "euclidean_size a = euclidean_size b"
+  using that division_segment_euclidean_size [of a] by simp
+
+lemma euclidean_size_of_nat [simp]:
+  "euclidean_size (of_nat n) = n"
+proof -
+  have "division_segment (of_nat n) * of_nat (euclidean_size (of_nat n)) = of_nat n"
+    by (fact division_segment_euclidean_size)
+  then show ?thesis by simp
+qed
+
+lemma of_nat_euclidean_size:
+  "of_nat (euclidean_size a) = a div division_segment a"
+proof -
+  have "of_nat (euclidean_size a) = division_segment a * of_nat (euclidean_size a) div division_segment a"
+    by (subst nonzero_mult_div_cancel_left) simp_all
+  also have "\<dots> = a div division_segment a"
+    by simp
+  finally show ?thesis .
+qed
+
+lemma division_segment_1 [simp]:
+  "division_segment 1 = 1"
+  using division_segment_of_nat [of 1] by simp
+
+lemma division_segment_numeral [simp]:
+  "division_segment (numeral k) = 1"
+  using division_segment_of_nat [of "numeral k"] by simp
+
+lemma euclidean_size_1 [simp]:
+  "euclidean_size 1 = 1"
+  using euclidean_size_of_nat [of 1] by simp
+
+lemma euclidean_size_numeral [simp]:
+  "euclidean_size (numeral k) = numeral k"
+  using euclidean_size_of_nat [of "numeral k"] by simp
+
+lemma of_nat_dvd_iff:
+  "of_nat m dvd of_nat n \<longleftrightarrow> m dvd n" (is "?P \<longleftrightarrow> ?Q")
+proof (cases "m = 0")
+  case True
+  then show ?thesis
+    by simp
+next
+  case False
+  show ?thesis
+  proof
+    assume ?Q
+    then show ?P
+      by auto
+  next
+    assume ?P
+    with False have "of_nat n = of_nat n div of_nat m * of_nat m"
+      by simp
+    then have "of_nat n = of_nat (n div m * m)"
+      by (simp add: of_nat_div)
+    then have "n = n div m * m"
+      by (simp only: of_nat_eq_iff)
+    then have "n = m * (n div m)"
+      by (simp add: ac_simps)
+    then show ?Q ..
+  qed
+qed
+
+lemma of_nat_mod:
+  "of_nat (m mod n) = of_nat m mod of_nat n"
+proof -
+  have "of_nat m div of_nat n * of_nat n + of_nat m mod of_nat n = of_nat m"
+    by (simp add: div_mult_mod_eq)
+  also have "of_nat m = of_nat (m div n * n + m mod n)"
+    by simp
+  finally show ?thesis
+    by (simp only: of_nat_div of_nat_mult of_nat_add) simp
+qed
+
+lemma one_div_two_eq_zero [simp]:
+  "1 div 2 = 0"
+proof -
+  from of_nat_div [symmetric] have "of_nat 1 div of_nat 2 = of_nat 0"
+    by (simp only:) simp
+  then show ?thesis
+    by simp
+qed
+
+lemma one_mod_two_eq_one [simp]:
+  "1 mod 2 = 1"
+proof -
+  from of_nat_mod [symmetric] have "of_nat 1 mod of_nat 2 = of_nat 1"
+    by (simp only:) simp
+  then show ?thesis
+    by simp
+qed
+
+lemma one_mod_2_pow_eq [simp]:
+  "1 mod (2 ^ n) = of_bool (n > 0)"
+proof -
+  have "1 mod (2 ^ n) = of_nat (1 mod (2 ^ n))"
+    using of_nat_mod [of 1 "2 ^ n"] by simp
+  also have "\<dots> = of_bool (n > 0)"
+    by simp
+  finally show ?thesis .
+qed
+
+lemma one_div_2_pow_eq [simp]:
+  "1 div (2 ^ n) = of_bool (n = 0)"
+  using div_mult_mod_eq [of 1 "2 ^ n"] by auto
+
+lemma div_mult2_eq':
+  \<open>a div (of_nat m * of_nat n) = a div of_nat m div of_nat n\<close>
+proof (cases \<open>m = 0 \<or> n = 0\<close>)
+  case True
+  then show ?thesis
+    by auto
+next
+  case False
+  then have \<open>m > 0\<close> \<open>n > 0\<close>
+    by simp_all
+  show ?thesis
+  proof (cases \<open>of_nat m * of_nat n dvd a\<close>)
+    case True
+    then obtain b where \<open>a = (of_nat m * of_nat n) * b\<close> ..
+    then have \<open>a = of_nat m * (of_nat n * b)\<close>
+      by (simp add: ac_simps)
+    then show ?thesis
+      by simp
+  next
+    case False
+    define q where \<open>q = a div (of_nat m * of_nat n)\<close>
+    define r where \<open>r = a mod (of_nat m * of_nat n)\<close>
+    from \<open>m > 0\<close> \<open>n > 0\<close> \<open>\<not> of_nat m * of_nat n dvd a\<close> r_def have "division_segment r = 1"
+      using division_segment_of_nat [of "m * n"] by (simp add: division_segment_mod)
+    with division_segment_euclidean_size [of r]
+    have "of_nat (euclidean_size r) = r"
+      by simp
+    have "a mod (of_nat m * of_nat n) div (of_nat m * of_nat n) = 0"
+      by simp
+    with \<open>m > 0\<close> \<open>n > 0\<close> r_def have "r div (of_nat m * of_nat n) = 0"
+      by simp
+    with \<open>of_nat (euclidean_size r) = r\<close>
+    have "of_nat (euclidean_size r) div (of_nat m * of_nat n) = 0"
+      by simp
+    then have "of_nat (euclidean_size r div (m * n)) = 0"
+      by (simp add: of_nat_div)
+    then have "of_nat (euclidean_size r div m div n) = 0"
+      by (simp add: div_mult2_eq)
+    with \<open>of_nat (euclidean_size r) = r\<close> have "r div of_nat m div of_nat n = 0"
+      by (simp add: of_nat_div)
+    with \<open>m > 0\<close> \<open>n > 0\<close> q_def
+    have "q = (r div of_nat m + q * of_nat n * of_nat m div of_nat m) div of_nat n"
+      by simp
+    moreover have \<open>a = q * (of_nat m * of_nat n) + r\<close>
+      by (simp add: q_def r_def div_mult_mod_eq)
+    ultimately show \<open>a div (of_nat m * of_nat n) = a div of_nat m div of_nat n\<close>
+      using q_def [symmetric] div_plus_div_distrib_dvd_right [of \<open>of_nat m\<close> \<open>q * (of_nat m * of_nat n)\<close> r]
+      by (simp add: ac_simps)
+  qed
+qed
+
+lemma mod_mult2_eq':
+  "a mod (of_nat m * of_nat n) = of_nat m * (a div of_nat m mod of_nat n) + a mod of_nat m"
+proof -
+  have "a div (of_nat m * of_nat n) * (of_nat m * of_nat n) + a mod (of_nat m * of_nat n) = a div of_nat m div of_nat n * of_nat n * of_nat m + (a div of_nat m mod of_nat n * of_nat m + a mod of_nat m)"
+    by (simp add: combine_common_factor div_mult_mod_eq)
+  moreover have "a div of_nat m div of_nat n * of_nat n * of_nat m = of_nat n * of_nat m * (a div of_nat m div of_nat n)"
+    by (simp add: ac_simps)
+  ultimately show ?thesis
+    by (simp add: div_mult2_eq' mult_commute)
+qed
+
+lemma div_mult2_numeral_eq:
+  "a div numeral k div numeral l = a div numeral (k * l)" (is "?A = ?B")
+proof -
+  have "?A = a div of_nat (numeral k) div of_nat (numeral l)"
+    by simp
+  also have "\<dots> = a div (of_nat (numeral k) * of_nat (numeral l))"
+    by (fact div_mult2_eq' [symmetric])
+  also have "\<dots> = ?B"
+    by simp
+  finally show ?thesis .
+qed
+
+lemma numeral_Bit0_div_2:
+  "numeral (num.Bit0 n) div 2 = numeral n"
+proof -
+  have "numeral (num.Bit0 n) = numeral n + numeral n"
+    by (simp only: numeral.simps)
+  also have "\<dots> = numeral n * 2"
+    by (simp add: mult_2_right)
+  finally have "numeral (num.Bit0 n) div 2 = numeral n * 2 div 2"
+    by simp
+  also have "\<dots> = numeral n"
+    by (rule nonzero_mult_div_cancel_right) simp
+  finally show ?thesis .
+qed
+
+lemma numeral_Bit1_div_2:
+  "numeral (num.Bit1 n) div 2 = numeral n"
+proof -
+  have "numeral (num.Bit1 n) = numeral n + numeral n + 1"
+    by (simp only: numeral.simps)
+  also have "\<dots> = numeral n * 2 + 1"
+    by (simp add: mult_2_right)
+  finally have "numeral (num.Bit1 n) div 2 = (numeral n * 2 + 1) div 2"
+    by simp
+  also have "\<dots> = numeral n * 2 div 2 + 1 div 2"
+    using dvd_triv_right by (rule div_plus_div_distrib_dvd_left)
+  also have "\<dots> = numeral n * 2 div 2"
+    by simp
+  also have "\<dots> = numeral n"
+    by (rule nonzero_mult_div_cancel_right) simp
+  finally show ?thesis .
+qed
+
+lemma exp_mod_exp:
+  \<open>2 ^ m mod 2 ^ n = of_bool (m < n) * 2 ^ m\<close>
+proof -
+  have \<open>(2::nat) ^ m mod 2 ^ n = of_bool (m < n) * 2 ^ m\<close> (is \<open>?lhs = ?rhs\<close>)
+    by (auto simp add: not_less monoid_mult_class.power_add dest!: le_Suc_ex)
+  then have \<open>of_nat ?lhs = of_nat ?rhs\<close>
+    by simp
+  then show ?thesis
+    by (simp add: of_nat_mod)
+qed
+
+lemma mask_mod_exp:
+  \<open>(2 ^ n - 1) mod 2 ^ m = 2 ^ min m n - 1\<close>
+proof -
+  have \<open>(2 ^ n - 1) mod 2 ^ m = 2 ^ min m n - (1::nat)\<close> (is \<open>?lhs = ?rhs\<close>)
+  proof (cases \<open>n \<le> m\<close>)
+    case True
+    then show ?thesis
+      by (simp add: Suc_le_lessD)
+  next
+    case False
+    then have \<open>m < n\<close>
+      by simp
+    then obtain q where n: \<open>n = Suc q + m\<close>
+      by (auto dest: less_imp_Suc_add)
+    then have \<open>min m n = m\<close>
+      by simp
+    moreover have \<open>(2::nat) ^ m \<le> 2 * 2 ^ q * 2 ^ m\<close>
+      using mult_le_mono1 [of 1 \<open>2 * 2 ^ q\<close> \<open>2 ^ m\<close>] by simp
+    with n have \<open>2 ^ n - 1 = (2 ^ Suc q - 1) * 2 ^ m + (2 ^ m - (1::nat))\<close>
+      by (simp add: monoid_mult_class.power_add algebra_simps)
+    ultimately show ?thesis
+      by (simp only: euclidean_semiring_cancel_class.mod_mult_self3) simp
+  qed
+  then have \<open>of_nat ?lhs = of_nat ?rhs\<close>
+    by simp
+  then show ?thesis
+    by (simp add: of_nat_mod of_nat_diff)
+qed
+
+lemma of_bool_half_eq_0 [simp]:
+  \<open>of_bool b div 2 = 0\<close>
+  by simp
+
+end
+
+class unique_euclidean_ring_with_nat = ring + unique_euclidean_semiring_with_nat
+
+instance nat :: unique_euclidean_semiring_with_nat
+  by standard (simp_all add: dvd_eq_mod_eq_0)
+
+instance int :: unique_euclidean_ring_with_nat
+  by standard (auto simp add: divide_int_def division_segment_int_def elim: contrapos_np)
+
+
+subsection \<open>More on euclidean division on \<^typ>\<open>int\<close>\<close>
+
+subsubsection \<open>Trivial reduction steps\<close>
+
+lemma div_pos_pos_trivial [simp]:
+  "k div l = 0" if "k \<ge> 0" and "k < l" for k l :: int
+  using that by (simp add: unique_euclidean_semiring_class.div_eq_0_iff division_segment_int_def)
+
+lemma mod_pos_pos_trivial [simp]:
+  "k mod l = k" if "k \<ge> 0" and "k < l" for k l :: int
+  using that by (simp add: mod_eq_self_iff_div_eq_0)
+
+lemma div_neg_neg_trivial [simp]:
+  "k div l = 0" if "k \<le> 0" and "l < k" for k l :: int
+  using that by (cases "k = 0") (simp, simp add: unique_euclidean_semiring_class.div_eq_0_iff division_segment_int_def)
+
+lemma mod_neg_neg_trivial [simp]:
+  "k mod l = k" if "k \<le> 0" and "l < k" for k l :: int
+  using that by (simp add: mod_eq_self_iff_div_eq_0)
+
+lemma
+  div_pos_neg_trivial: \<open>k div l = - 1\<close>  (is ?Q)
+  and mod_pos_neg_trivial: \<open>k mod l = k + l\<close>  (is ?R)
+    if \<open>0 < k\<close> and \<open>k + l \<le> 0\<close> for k l :: int sorry (*
+proof -
+  from that have \<open>l < 0\<close>
+    by simp
+  have \<open>(k div l, k mod l) = (- 1, k + l)\<close>
+  proof (cases l \<open>- 1 :: int\<close> \<open>k + l\<close> k rule: euclidean_relation_intI)
+    case by0
+    with \<open>l < 0\<close> show ?case
+      by simp
+  next
+    case divides
+    from \<open>l dvd k\<close> obtain j where \<open>k = l * j\<close> ..
+    with \<open>l < 0\<close> \<open>0 < k\<close> have \<open>j < 0\<close>
+      by (simp add: zero_less_mult_iff)
+    moreover from \<open>k + l \<le> 0\<close> \<open>k = l * j\<close> have \<open>l * (j + 1) \<le> 0\<close>
+      by (simp add: algebra_simps)
+    with \<open>l < 0\<close> have \<open>j + 1 \<ge> 0\<close>
+      by (simp add: mult_le_0_iff)
+    with \<open>j < 0\<close> have \<open>j = - 1\<close>
+      by simp
+    with \<open>k = l * j\<close> show ?case
+      by simp
+  next
+    case euclidean_relation
+    with \<open>k + l \<le> 0\<close> have \<open>k + l < 0\<close>
+      by (auto simp add: less_le add_eq_0_iff)
+    with \<open>0 < k\<close> show ?case
+      by simp
+  qed
+  then show ?Q and ?R
+    by simp_all
+qed*)
+
+text \<open>There is neither \<open>div_neg_pos_trivial\<close> nor \<open>mod_neg_pos_trivial\<close>
+  because \<^term>\<open>0 div l = 0\<close> would supersede it.\<close>
+
+
+subsubsection \<open>More uniqueness rules\<close>
+
+lemma
+  fixes a b q r :: int
+  assumes \<open>a = b * q + r\<close> \<open>0 \<le> r\<close> \<open>r < b\<close>
+  shows int_div_pos_eq:
+      \<open>a div b = q\<close> (is ?Q)
+    and int_mod_pos_eq:
+      \<open>a mod b = r\<close> (is ?R)
+proof -
+  from assms have \<open>(a div b, a mod b) = (q, r)\<close>
+    by (cases b q r a rule: euclidean_relation_intI)
+      (auto simp add: ac_simps dvd_add_left_iff sgn_1_pos le_less dest: zdvd_imp_le)
+  then show ?Q and ?R
+    by simp_all
+qed
+
+lemma int_div_neg_eq:
+  \<open>a div b = q\<close> if \<open>a = b * q + r\<close> \<open>r \<le> 0\<close> \<open>b < r\<close> for a b q r :: int
+  using that int_div_pos_eq [of a \<open>- b\<close> \<open>- q\<close> \<open>- r\<close>] by simp_all
+
+lemma int_mod_neg_eq:
+  \<open>a mod b = r\<close> if \<open>a = b * q + r\<close> \<open>r \<le> 0\<close> \<open>b < r\<close> for a b q r :: int
+  using that int_div_neg_eq [of a b q r] by simp
+
+
+subsubsection \<open>Laws for unary minus\<close>
+
+lemma zmod_zminus1_not_zero:
+  fixes k l :: int
+  shows "- k mod l \<noteq> 0 \<Longrightarrow> k mod l \<noteq> 0"
+  by (simp add: mod_eq_0_iff_dvd)
+
+lemma zmod_zminus2_not_zero:
+  fixes k l :: int
+  shows "k mod - l \<noteq> 0 \<Longrightarrow> k mod l \<noteq> 0"
+  by (simp add: mod_eq_0_iff_dvd)
+
+lemma zdiv_zminus1_eq_if:
+  \<open>(- a) div b = (if a mod b = 0 then - (a div b) else - (a div b) - 1)\<close>
+  if \<open>b \<noteq> 0\<close> for a b :: int
+  using that sgn_not_eq_imp [of b \<open>- a\<close>]
+  by (cases \<open>a = 0\<close>) (auto simp add: div_eq_div_abs [of \<open>- a\<close> b] div_eq_div_abs [of a b] sgn_eq_0_iff)
+
+lemma zdiv_zminus2_eq_if:
+  \<open>a div (- b) = (if a mod b = 0 then - (a div b) else - (a div b) - 1)\<close>
+  if \<open>b \<noteq> 0\<close> for a b :: int
+  using that by (auto simp add: zdiv_zminus1_eq_if div_minus_right)
+
+lemma zmod_zminus1_eq_if:
+  \<open>(- a) mod b = (if a mod b = 0 then 0 else b - (a mod b))\<close>
+  for a b :: int
+  by (cases \<open>b = 0\<close>)
+    (auto simp flip: minus_div_mult_eq_mod simp add: zdiv_zminus1_eq_if algebra_simps)
+
+lemma zmod_zminus2_eq_if:
+  \<open>a mod (- b) = (if a mod b = 0 then 0 else (a mod b) - b)\<close>
+  for a b :: int
+  by (auto simp add: zmod_zminus1_eq_if mod_minus_right)
+
+
+subsubsection \<open>Borders\<close>
+
+lemma pos_mod_bound [simp]:
+  "k mod l < l" if "l > 0" for k l :: int
+proof -
+  obtain m and s where "k = sgn s * int m"
+    by (rule int_sgnE)
+  moreover from that obtain n where "l = sgn 1 * int n"
+    by (cases l) simp_all
+  moreover from this that have "n > 0"
+    by simp
+  ultimately show ?thesis
+    by (simp only: modulo_int_unfold)
+      (auto simp add: mod_greater_zero_iff_not_dvd sgn_1_pos)
+qed
+
+lemma neg_mod_bound [simp]:
+  "l < k mod l" if "l < 0" for k l :: int
+proof -
+  obtain m and s where "k = sgn s * int m"
+    by (rule int_sgnE)
+  moreover from that obtain q where "l = sgn (- 1) * int (Suc q)"
+    by (cases l) simp_all
+  moreover define n where "n = Suc q"
+  then have "Suc q = n"
+    by simp
+  ultimately show ?thesis
+    by (simp only: modulo_int_unfold)
+      (auto simp add: mod_greater_zero_iff_not_dvd sgn_1_neg)
+qed
+
+lemma pos_mod_sign [simp]:
+  "0 \<le> k mod l" if "l > 0" for k l :: int
+proof -
+  obtain m and s where "k = sgn s * int m"
+    by (rule int_sgnE)
+  moreover from that obtain n where "l = sgn 1 * int n"
+    by (cases l) auto
+  moreover from this that have "n > 0"
+    by simp
+  ultimately show ?thesis
+    by (simp only: modulo_int_unfold) (auto simp add: sgn_1_pos)
+qed
+
+lemma neg_mod_sign [simp]:
+  "k mod l \<le> 0" if "l < 0" for k l :: int
+proof -
+  obtain m and s where "k = sgn s * int m"
+    by (rule int_sgnE)
+  moreover from that obtain q where "l = sgn (- 1) * int (Suc q)"
+    by (cases l) simp_all
+  moreover define n where "n = Suc q"
+  then have "Suc q = n"
+    by simp
+  moreover have \<open>int (m mod n) \<le> int n\<close>
+    using \<open>Suc q = n\<close> by simp
+  then have \<open>sgn s * int (m mod n) \<le> int n\<close>
+    by (cases s \<open>0::int\<close> rule: linorder_cases) simp_all
+  ultimately show ?thesis
+    by (simp only: modulo_int_unfold) auto
+qed
+
+
+subsubsection \<open>Splitting Rules for div and mod\<close>
+
+lemma split_zdiv:
+  \<open>P (n div k) \<longleftrightarrow>
+    (k = 0 \<longrightarrow> P 0) \<and>
+    (0 < k \<longrightarrow> (\<forall>i j. 0 \<le> j \<and> j < k \<and> n = k * i + j \<longrightarrow> P i)) \<and>
+    (k < 0 \<longrightarrow> (\<forall>i j. k < j \<and> j \<le> 0 \<and> n = k * i + j \<longrightarrow> P i))\<close> (is ?div)
+  and split_zmod:
+  \<open>Q (n mod k) \<longleftrightarrow>
+    (k = 0 \<longrightarrow> Q n) \<and>
+    (0 < k \<longrightarrow> (\<forall>i j. 0 \<le> j \<and> j < k \<and> n = k * i + j \<longrightarrow> Q j)) \<and>
+    (k < 0 \<longrightarrow> (\<forall>i j. k < j \<and> j \<le> 0 \<and> n = k * i + j \<longrightarrow> Q j))\<close> (is ?mod)
+  for n k :: int
+proof -
+  have *: \<open>R (n div k) (n mod k) \<longleftrightarrow>
+    (k = 0 \<longrightarrow> R 0 n) \<and>
+    (0 < k \<longrightarrow> (\<forall>i j. 0 \<le> j \<and> j < k \<and> n = k * i + j \<longrightarrow> R i j)) \<and>
+    (k < 0 \<longrightarrow> (\<forall>i j. k < j \<and> j \<le> 0 \<and> n = k * i + j \<longrightarrow> R i j))\<close> for R
+    by (cases \<open>k = 0\<close>)
+      (auto simp add: linorder_class.neq_iff)
+  from * [of \<open>\<lambda>q _. P q\<close>] show ?div .
+  from * [of \<open>\<lambda>_ r. Q r\<close>] show ?mod .
+qed
+
+text \<open>Enable (lin)arith to deal with \<^const>\<open>divide\<close> and \<^const>\<open>modulo\<close>
+  when these are applied to some constant that is of the form
+  \<^term>\<open>numeral k\<close>:\<close>
+declare split_zdiv [of _ _ \<open>numeral n\<close>, linarith_split] for n
+declare split_zdiv [of _ _ \<open>- numeral n\<close>, linarith_split] for n
+declare split_zmod [of _ _ \<open>numeral n\<close>, linarith_split] for n
+declare split_zmod [of _ _ \<open>- numeral n\<close>, linarith_split] for n
+
+lemma zdiv_eq_0_iff:
+  "i div k = 0 \<longleftrightarrow> k = 0 \<or> 0 \<le> i \<and> i < k \<or> i \<le> 0 \<and> k < i" (is "?L = ?R")
+  for i k :: int
+proof
+  assume ?L
+  moreover have "?L \<longrightarrow> ?R"
+    by (rule split_zdiv [THEN iffD2]) simp
+  ultimately show ?R
+    by blast
+next
+  assume ?R then show ?L
+    by auto
+qed
+
+lemma zmod_trivial_iff:
+  fixes i k :: int
+  shows "i mod k = i \<longleftrightarrow> k = 0 \<or> 0 \<le> i \<and> i < k \<or> i \<le> 0 \<and> k < i"
+proof -
+  have "i mod k = i \<longleftrightarrow> i div k = 0"
+    using div_mult_mod_eq [of i k] by safe auto
+  with zdiv_eq_0_iff
+  show ?thesis
+    by simp
+qed
+
+
+subsubsection \<open>Algebraic rewrites\<close>
+
+lemma zdiv_zmult2_eq:
+  \<open>a div (b * c) = (a div b) div c\<close> if \<open>c \<ge> 0\<close> for a b c :: int
+proof (cases \<open>b \<ge> 0\<close>)
+  case True
+  with that show ?thesis
+    using div_mult2_eq' [of a \<open>nat b\<close> \<open>nat c\<close>] by simp
+next
+  case False
+  with that show ?thesis
+    using div_mult2_eq' [of \<open>- a\<close> \<open>nat (- b)\<close> \<open>nat c\<close>] by simp
+qed
+
+lemma zdiv_zmult2_eq':
+  \<open>k div (l * j) = ((sgn j * k) div l) div \<bar>j\<bar>\<close> for k l j :: int
+proof -
+  have \<open>k div (l * j) = (sgn j * k) div (sgn j * (l * j))\<close>
+    by (simp add: sgn_0_0)
+  also have \<open>sgn j * (l * j) = l * \<bar>j\<bar>\<close>
+    by (simp add: mult.left_commute [of _ l] abs_sgn) (simp add: ac_simps)
+  also have \<open>(sgn j * k) div (l * \<bar>j\<bar>) = ((sgn j * k) div l) div \<bar>j\<bar>\<close>
+    by (simp add: zdiv_zmult2_eq)
+  finally show ?thesis .
+qed
+
+lemma zmod_zmult2_eq:
+  \<open>a mod (b * c) = b * (a div b mod c) + a mod b\<close> if \<open>c \<ge> 0\<close> for a b c :: int
+proof (cases \<open>b \<ge> 0\<close>)
+  case True
+  with that show ?thesis
+    using mod_mult2_eq' [of a \<open>nat b\<close> \<open>nat c\<close>] by simp
+next
+  case False
+  with that show ?thesis
+    using mod_mult2_eq' [of \<open>- a\<close> \<open>nat (- b)\<close> \<open>nat c\<close>] by simp
+qed
+
+lemma half_nonnegative_int_iff [simp]:
+  \<open>k div 2 \<ge> 0 \<longleftrightarrow> k \<ge> 0\<close> for k :: int
+  by auto
+
+lemma half_negative_int_iff [simp]:
+  \<open>k div 2 < 0 \<longleftrightarrow> k < 0\<close> for k :: int
+  by auto
+
+
+subsubsection \<open>Distributive laws for conversions.\<close>
+
+lemma zdiv_int:
+  "int (a div b) = int a div int b"
+  by (fact of_nat_div)
+
+lemma zmod_int:
+  "int (a mod b) = int a mod int b"
+  by (fact of_nat_mod)
+
+lemma nat_div_distrib:
+  \<open>nat (x div y) = nat x div nat y\<close> if \<open>0 \<le> x\<close>
+  using that by (simp add: divide_int_def sgn_if)
+
+lemma nat_div_distrib':
+  \<open>nat (x div y) = nat x div nat y\<close> if \<open>0 \<le> y\<close>
+  using that by (simp add: divide_int_def sgn_if)
+
+lemma nat_mod_distrib: \<comment> \<open>Fails if y<0: the LHS collapses to (nat z) but the RHS doesn't\<close>
+  \<open>nat (x mod y) = nat x mod nat y\<close> if \<open>0 \<le> x\<close> \<open>0 \<le> y\<close>
+  using that by (simp add: modulo_int_def sgn_if)
+
+
+subsubsection \<open>Monotonicity in the First Argument (Dividend)\<close>
+
+lemma zdiv_mono1:
+  \<open>a div b \<le> a' div b\<close>
+    if \<open>a \<le> a'\<close> \<open>0 < b\<close>
+    for a b b' :: int
+proof -
+  from \<open>a \<le> a'\<close> have \<open>b * (a div b) + a mod b \<le> b * (a' div b) + a' mod b\<close>
+    by simp
+  then have \<open>b * (a div b) \<le> (a' mod b - a mod b) + b * (a' div b)\<close>
+    by (simp add: algebra_simps)
+  moreover have \<open>a' mod b < b + a mod b\<close>
+    by (rule less_le_trans [of _ b]) (use \<open>0 < b\<close> in simp_all)
+  ultimately have \<open>b * (a div b) < b * (1 + a' div b)\<close>
+    by (simp add: distrib_left)
+  with \<open>0 < b\<close> have \<open>a div b < 1 + a' div b\<close>
+    by (simp add: mult_less_cancel_left)
+  then show ?thesis
+    by simp
+qed
+
+lemma zdiv_mono1_neg:
+  \<open>a' div b \<le> a div b\<close>
+    if \<open>a \<le> a'\<close> \<open>b < 0\<close>
+    for a a' b :: int
+  using that zdiv_mono1 [of \<open>- a'\<close> \<open>- a\<close> \<open>- b\<close>] by simp
+
+
+subsubsection \<open>Monotonicity in the Second Argument (Divisor)\<close>
+
+lemma zdiv_mono2:
+  \<open>a div b \<le> a div b'\<close> if \<open>0 \<le> a\<close> \<open>0 < b'\<close> \<open>b' \<le> b\<close> for a b b' :: int
+proof -
+  define q q' r r' where **: \<open>q = a div b\<close> \<open>q' = a div b'\<close> \<open>r = a mod b\<close> \<open>r' = a mod b'\<close>
+  then have *: \<open>b * q + r = b' * q' + r'\<close> \<open>0 \<le> b' * q' + r'\<close>
+    \<open>r' < b'\<close> \<open>0 \<le> r\<close> \<open>0 < b'\<close> \<open>b' \<le> b\<close>
+    using that by simp_all
+  have \<open>0 < b' * (q' + 1)\<close>
+    using * by (simp add: distrib_left)
+  with * have \<open>0 \<le> q'\<close>
+    by (simp add: zero_less_mult_iff)
+  moreover have \<open>b * q = r' - r + b' * q'\<close>
+    using * by linarith
+  ultimately have \<open>b * q < b * (q' + 1)\<close>
+    using mult_right_mono * unfolding distrib_left by fastforce
+  with * have \<open>q \<le> q'\<close>
+    by (simp add: mult_less_cancel_left_pos)
+  with ** show ?thesis
+    by simp
+qed
+
+lemma zdiv_mono2_neg:
+  \<open>a div b' \<le> a div b\<close> if \<open>a < 0\<close> \<open>0 < b'\<close> \<open>b' \<le> b\<close> for a b b' :: int
+proof -
+  define q q' r r' where **: \<open>q = a div b\<close> \<open>q' = a div b'\<close> \<open>r = a mod b\<close> \<open>r' = a mod b'\<close>
+  then have *: \<open>b * q + r = b' * q' + r'\<close> \<open>b' * q' + r' < 0\<close>
+    \<open>r < b\<close> \<open>0 \<le> r'\<close> \<open>0 < b'\<close> \<open>b' \<le> b\<close>
+    using that by simp_all
+  have \<open>b' * q' < 0\<close>
+    using * by linarith
+  with * have \<open>q' \<le> 0\<close>
+    by (simp add: mult_less_0_iff)
+  have \<open>b * q' \<le> b' * q'\<close>
+    by (simp add: \<open>q' \<le> 0\<close> * mult_right_mono_neg)
+  then have "b * q' < b * (q + 1)"
+    using * by (simp add: distrib_left)
+  then have \<open>q' \<le> q\<close>
+    using * by (simp add: mult_less_cancel_left)
+  then show ?thesis
+    by (simp add: **)
+qed
+
+
+subsubsection \<open>Quotients of Signs\<close>
+
+lemma div_eq_minus1:
+  \<open>0 < b \<Longrightarrow> - 1 div b = - 1\<close> for b :: int
+  by (simp add: divide_int_def)
+
+lemma zmod_minus1:
+  \<open>0 < b \<Longrightarrow> - 1 mod b = b - 1\<close> for b :: int
+  by (auto simp add: modulo_int_def)
+
+lemma minus_mod_int_eq:
+  \<open>- k mod l = l - 1 - (k - 1) mod l\<close> if \<open>l \<ge> 0\<close> for k l :: int
+proof (cases \<open>l = 0\<close>)
+  case True
+  then show ?thesis
+    by simp
+next
+  case False
+  with that have \<open>l > 0\<close>
+    by simp
+  then show ?thesis
+  proof (cases \<open>l dvd k\<close>)
+    case True
+    then obtain j where \<open>k = l * j\<close> ..
+    moreover have \<open>(l * j mod l - 1) mod l = l - 1\<close>
+      using \<open>l > 0\<close> by (simp add: zmod_minus1)
+    then have \<open>(l * j - 1) mod l = l - 1\<close>
+      by (simp only: mod_simps)
+    ultimately show ?thesis
+      by simp
+  next
+    case False
+    moreover have 1: \<open>0 < k mod l\<close>
+      using \<open>0 < l\<close> False le_less by fastforce
+    moreover have 2: \<open>k mod l < 1 + l\<close>
+      using \<open>0 < l\<close> pos_mod_bound[of l k] by linarith
+    from 1 2 \<open>l > 0\<close> have \<open>(k mod l - 1) mod l = k mod l - 1\<close>
+      by (simp add: zmod_trivial_iff)
+    ultimately show ?thesis
+      by (simp only: zmod_zminus1_eq_if)
+         (simp add: mod_eq_0_iff_dvd algebra_simps mod_simps)
+  qed
+qed
+
+lemma div_neg_pos_less0:
+  \<open>a div b < 0\<close> if \<open>a < 0\<close> \<open>0 < b\<close> for a b :: int
+proof -
+  have "a div b \<le> - 1 div b"
+    using zdiv_mono1 that by auto
+  also have "... \<le> -1"
+    by (simp add: that(2) div_eq_minus1)
+  finally show ?thesis
+    by force
+qed
+
+lemma div_nonneg_neg_le0:
+  \<open>a div b \<le> 0\<close> if \<open>0 \<le> a\<close> \<open>b < 0\<close> for a b :: int
+  using that by (auto dest: zdiv_mono1_neg)
+
+lemma div_nonpos_pos_le0:
+  \<open>a div b \<le> 0\<close> if \<open>a \<le> 0\<close> \<open>0 < b\<close> for a b :: int
+  using that by (auto dest: zdiv_mono1)
+
+text\<open>Now for some equivalences of the form \<open>a div b >=< 0 \<longleftrightarrow> \<dots>\<close>
+conditional upon the sign of \<open>a\<close> or \<open>b\<close>. There are many more.
+They should all be simp rules unless that causes too much search.\<close>
+
+lemma pos_imp_zdiv_nonneg_iff:
+  \<open>0 \<le> a div b \<longleftrightarrow> 0 \<le> a\<close>
+  if \<open>0 < b\<close> for a b :: int
+proof
+  assume \<open>0 \<le> a div b\<close>
+  show \<open>0 \<le> a\<close>
+  proof (rule ccontr)
+    assume \<open>\<not> 0 \<le> a\<close>
+    then have \<open>a < 0\<close>
+      by simp
+    then have \<open>a div b < 0\<close>
+      using that by (rule div_neg_pos_less0)
+    with \<open>0 \<le> a div b\<close> show False
+      by simp
+  qed
+next
+  assume "0 \<le> a"
+  then have "0 div b \<le> a div b"
+    using zdiv_mono1 that by blast
+  then show "0 \<le> a div b"
+    by auto
+qed
+
+lemma neg_imp_zdiv_nonneg_iff:
+  \<open>0 \<le> a div b \<longleftrightarrow> a \<le> 0\<close> if \<open>b < 0\<close> for a b :: int
+  using that pos_imp_zdiv_nonneg_iff [of \<open>- b\<close> \<open>- a\<close>] by simp
+
+lemma pos_imp_zdiv_pos_iff:
+  \<open>0 < (i::int) div k \<longleftrightarrow> k \<le> i\<close> if \<open>0 < k\<close> for i k :: int
+  using that pos_imp_zdiv_nonneg_iff [of k i] zdiv_eq_0_iff [of i k] by arith
+
+lemma pos_imp_zdiv_neg_iff:
+  \<open>a div b < 0 \<longleftrightarrow> a < 0\<close> if \<open>0 < b\<close> for a b :: int
+    \<comment> \<open>But not \<^prop>\<open>a div b \<le> 0 \<longleftrightarrow> a \<le> 0\<close>; consider \<^prop>\<open>a = 1\<close>, \<^prop>\<open>b = 2\<close> when \<^prop>\<open>a div b = 0\<close>.\<close>
+  using that by (simp add: pos_imp_zdiv_nonneg_iff flip: linorder_not_le)
+
+lemma neg_imp_zdiv_neg_iff:
+    \<comment> \<open>But not \<^prop>\<open>a div b \<le> 0 \<longleftrightarrow> 0 \<le> a\<close>; consider \<^prop>\<open>a = - 1\<close>, \<^prop>\<open>b = - 2\<close> when \<^prop>\<open>a div b = 0\<close>.\<close>
+  \<open>a div b < 0 \<longleftrightarrow> 0 < a\<close> if \<open>b < 0\<close> for a b :: int
+  using that by (simp add: neg_imp_zdiv_nonneg_iff flip: linorder_not_le)
+
+lemma nonneg1_imp_zdiv_pos_iff:
+  \<open>a div b > 0 \<longleftrightarrow> a \<ge> b \<and> b > 0\<close> if \<open>0 \<le> a\<close> for a b :: int
+proof -
+  have "0 < a div b \<Longrightarrow> b \<le> a"
+    using div_pos_pos_trivial[of a b] that by arith
+  moreover have "0 < a div b \<Longrightarrow> b > 0"
+    using that div_nonneg_neg_le0[of a b] by (cases "b=0"; force)
+  moreover have "b \<le> a \<and> 0 < b \<Longrightarrow> 0 < a div b"
+    using int_one_le_iff_zero_less[of "a div b"] zdiv_mono1[of b a b] by simp
+  ultimately show ?thesis
+    by blast
+qed
+
+lemma zmod_le_nonneg_dividend:
+  \<open>m mod k \<le> m\<close> if \<open>(m::int) \<ge> 0\<close> for m k :: int
+proof -
+  from that have \<open>m > 0 \<or> m = 0\<close>
+    by auto
+  then show ?thesis proof
+    assume \<open>m = 0\<close> then show ?thesis
+      by simp
+  next
+    assume \<open>m > 0\<close> then show ?thesis
+    proof (cases k \<open>0::int\<close> rule: linorder_cases)
+      case less
+      moreover define l where \<open>l = - k\<close>
+      ultimately have \<open>l > 0\<close>
+        by simp
+      with \<open>m > 0\<close> have \<open>int (nat m mod nat l) \<le> m\<close>
+        by (simp flip: le_nat_iff)
+      then have \<open>int (nat m mod nat l) - l \<le> m\<close>
+        using \<open>l > 0\<close> by simp
+      with \<open>m > 0\<close> \<open>l > 0\<close> show ?thesis
+        by (simp add: modulo_int_def l_def flip: le_nat_iff)
+    qed (simp_all add: modulo_int_def flip: le_nat_iff)
+  qed
+qed
+
+lemma sgn_div_eq_sgn_mult:
+  \<open>sgn (k div l) = of_bool (k div l \<noteq> 0) * sgn (k * l)\<close>
+  for k l :: int
+proof (cases \<open>k div l = 0\<close>)
+  case True
+  then show ?thesis
+    by simp
+next
+  case False
+  have \<open>0 \<le> \<bar>k\<bar> div \<bar>l\<bar>\<close>
+    by (cases \<open>l = 0\<close>) (simp_all add: pos_imp_zdiv_nonneg_iff)
+  then have \<open>\<bar>k\<bar> div \<bar>l\<bar> \<noteq> 0 \<longleftrightarrow> 0 < \<bar>k\<bar> div \<bar>l\<bar>\<close>
+    by (simp add: less_le)
+  also have \<open>\<dots> \<longleftrightarrow> \<bar>k\<bar> \<ge> \<bar>l\<bar>\<close>
+    using False nonneg1_imp_zdiv_pos_iff by auto
+  finally have *: \<open>\<bar>k\<bar> div \<bar>l\<bar> \<noteq> 0 \<longleftrightarrow> \<bar>l\<bar> \<le> \<bar>k\<bar>\<close> .
+  show ?thesis
+    using \<open>0 \<le> \<bar>k\<bar> div \<bar>l\<bar>\<close> False
+  by (auto simp add: div_eq_div_abs [of k l] div_eq_sgn_abs [of k l]
+    sgn_mult sgn_1_pos sgn_1_neg sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest!: sgn_not_eq_imp)
+qed
+
+
+subsubsection \<open>Further properties\<close>
+
+lemma div_int_pos_iff:
+  "k div l \<ge> 0 \<longleftrightarrow> k = 0 \<or> l = 0 \<or> k \<ge> 0 \<and> l \<ge> 0
+    \<or> k < 0 \<and> l < 0"
+  for k l :: int
+proof (cases "k = 0 \<or> l = 0")
+  case False
+  then have *: "k \<noteq> 0" "l \<noteq> 0"
+    by auto
+  then have "0 \<le> k div l \<Longrightarrow> \<not> k < 0 \<Longrightarrow> 0 \<le> l"
+    by (meson neg_imp_zdiv_neg_iff not_le not_less_iff_gr_or_eq)
+  then show ?thesis
+   using * by (auto simp add: pos_imp_zdiv_nonneg_iff neg_imp_zdiv_nonneg_iff)
+qed auto
+
+lemma mod_int_pos_iff:
+  \<open>k mod l \<ge> 0 \<longleftrightarrow> l dvd k \<or> l = 0 \<and> k \<ge> 0 \<or> l > 0\<close>
+  for k l :: int
+proof (cases "l > 0")
+  case False
+  then show ?thesis
+    by (simp add: dvd_eq_mod_eq_0) (use neg_mod_sign [of l k] in \<open>auto simp add: le_less not_less\<close>)
+qed auto
+
+lemma abs_div:
+  \<open>\<bar>x div y\<bar> = \<bar>x\<bar> div \<bar>y\<bar>\<close> if \<open>y dvd x\<close> for x y :: int
+  using that by (cases \<open>y = 0\<close>) (auto simp add: abs_mult)
+
+lemma int_power_div_base: \<^marker>\<open>contributor \<open>Matthias Daum\<close>\<close>
+  \<open>k ^ m div k = k ^ (m - Suc 0)\<close> if \<open>0 < m\<close> \<open>0 < k\<close> for k :: int
+  using that by (cases m) simp_all
+
+lemma int_div_less_self: \<^marker>\<open>contributor \<open>Matthias Daum\<close>\<close>
+  \<open>x div k < x\<close> if \<open>0 < x\<close> \<open>1 < k\<close> for x k :: int
+proof -
+  from that have \<open>nat (x div k) = nat x div nat k\<close>
+    by (simp add: nat_div_distrib)
+  also from that have \<open>nat x div nat k < nat x\<close>
+    by simp
+  finally show ?thesis
+    by simp
+qed
+
+
+subsubsection \<open>Computing \<open>div\<close> and \<open>mod\<close> by shifting\<close>
+
+lemma div_pos_geq:
+  \<open>k div l = (k - l) div l + 1\<close> if \<open>0 < l\<close> \<open>l \<le> k\<close> for k l :: int
+proof -
+  have "k = (k - l) + l" by simp
+  then obtain j where k: "k = j + l" ..
+  with that show ?thesis by (simp add: div_add_self2)
+qed
+
+lemma mod_pos_geq:
+  \<open>k mod l = (k - l) mod l\<close>  if \<open>0 < l\<close> \<open>l \<le> k\<close> for k l :: int
+proof -
+  have "k = (k - l) + l" by simp
+  then obtain j where k: "k = j + l" ..
+  with that show ?thesis by simp
+qed
+
+lemma pos_zdiv_mult_2: \<open>(1 + 2 * b) div (2 * a) = b div a\<close> (is ?Q)
+  and pos_zmod_mult_2: \<open>(1 + 2 * b) mod (2 * a) = 1 + 2 * (b mod a)\<close> (is ?R)
+  if \<open>0 \<le> a\<close> for a b :: int
+proof -
+  have \<open>((1 + 2 * b) div (2 * a), (1 + 2 * b) mod (2 * a)) = (b div a, 1 + 2 * (b mod a))\<close>
+  proof (cases \<open>2 * a\<close> \<open>b div a\<close> \<open>1 + 2 * (b mod a)\<close> \<open>1 + 2 * b\<close> rule: euclidean_relation_intI)
+    case by0
+    then show ?case
+      by simp
+  next
+    case divides
+    have \<open>2 dvd (2 * a)\<close>
+      by simp
+    then have \<open>2 dvd (1 + 2 * b)\<close>
+      using \<open>2 * a dvd 1 + 2 * b\<close> by (rule dvd_trans)
+    then have \<open>2 dvd (1 + b * 2)\<close>
+      by (simp add: ac_simps)
+    then have \<open>is_unit (2 :: int)\<close>
+      by simp
+    then show ?case
+      by simp
+  next
+    case euclidean_relation
+    with that have \<open>a > 0\<close>
+      by simp
+    moreover have \<open>b mod a < a\<close>
+      using \<open>a > 0\<close> by simp
+    then have \<open>1 + 2 * (b mod a) < 2 * a\<close>
+      by simp
+    moreover have \<open>2 * (b mod a) + a * (2 * (b div a)) = 2 * (b div a * a + b mod a)\<close>
+      by (simp only: algebra_simps)
+    moreover have \<open>0 \<le> 2 * (b mod a)\<close>
+      using \<open>a > 0\<close> by simp
+    ultimately show ?case
+      by (simp add: algebra_simps)
+  qed
+  then show ?Q and ?R
+    by simp_all
+qed
+
+lemma neg_zdiv_mult_2: \<open>(1 + 2 * b) div (2 * a) = (b + 1) div a\<close> (is ?Q)
+  and neg_zmod_mult_2: \<open>(1 + 2 * b) mod (2 * a) = 2 * ((b + 1) mod a) - 1\<close> (is ?R)
+  if \<open>a \<le> 0\<close> for a b :: int
+proof -
+  have \<open>((1 + 2 * b) div (2 * a), (1 + 2 * b) mod (2 * a)) = ((b + 1) div a, 2 * ((b + 1) mod a) - 1)\<close>
+  proof (cases \<open>2 * a\<close> \<open>(b + 1) div a\<close> \<open>2 * ((b + 1) mod a) - 1\<close> \<open>1 + 2 * b\<close> rule: euclidean_relation_intI)
+    case by0
+    then show ?case
+      by simp
+  next
+    case divides
+    have \<open>2 dvd (2 * a)\<close>
+      by simp
+    then have \<open>2 dvd (1 + 2 * b)\<close>
+      using \<open>2 * a dvd 1 + 2 * b\<close> by (rule dvd_trans)
+    then have \<open>2 dvd (1 + b * 2)\<close>
+      by (simp add: ac_simps)
+    then have \<open>is_unit (2 :: int)\<close>
+      by simp
+    then show ?case
+      by simp
+  next
+    case euclidean_relation
+    with that have \<open>a < 0\<close>
+      by simp
+    moreover have \<open>(b + 1) mod a > a\<close>
+      using \<open>a < 0\<close> by simp
+    then have \<open>2 * ((b + 1) mod a) > 1 + 2 * a\<close>
+      by simp
+    moreover have \<open>((1 + b) mod a) \<le> 0\<close>
+      using \<open>a < 0\<close> by simp
+    then have \<open>2 * ((1 + b) mod a) \<le> 0\<close>
+      by simp
+    moreover have \<open>2 * ((1 + b) mod a) + a * (2 * ((1 + b) div a)) =
+      2 * ((1 + b) div a * a + (1 + b) mod a)\<close>
+      by (simp only: algebra_simps)
+    ultimately show ?case
+      by (simp add: algebra_simps sgn_mult abs_mult)
+  qed
+  then show ?Q and ?R
+    by simp_all
+qed
+
+lemma zdiv_numeral_Bit0 [simp]:
+  \<open>numeral (Num.Bit0 v) div numeral (Num.Bit0 w) =
+    numeral v div (numeral w :: int)\<close>
+  unfolding numeral.simps unfolding mult_2 [symmetric]
+  by (rule div_mult_mult1) simp
+
+lemma zdiv_numeral_Bit1 [simp]:
+  \<open>numeral (Num.Bit1 v) div numeral (Num.Bit0 w) =
+    (numeral v div (numeral w :: int))\<close>
+  unfolding numeral.simps
+  unfolding mult_2 [symmetric] add.commute [of _ 1]
+  by (rule pos_zdiv_mult_2) simp
+
+lemma zmod_numeral_Bit0 [simp]:
+  \<open>numeral (Num.Bit0 v) mod numeral (Num.Bit0 w) =
+    (2::int) * (numeral v mod numeral w)\<close>
+  unfolding numeral_Bit0 [of v] numeral_Bit0 [of w]
+  unfolding mult_2 [symmetric] by (rule mod_mult_mult1)
+
+lemma zmod_numeral_Bit1 [simp]:
+  \<open>numeral (Num.Bit1 v) mod numeral (Num.Bit0 w) =
+    2 * (numeral v mod numeral w) + (1::int)\<close>
+  unfolding numeral_Bit1 [of v] numeral_Bit0 [of w]
+  unfolding mult_2 [symmetric] add.commute [of _ 1]
+  by (rule pos_zmod_mult_2) simp
+
+
+subsection \<open>Generic symbolic computations\<close>
+
+text \<open>
+  The following type class contains everything necessary to formulate
+  a division algorithm in ring structures with numerals, restricted
+  to its positive segments.
+\<close>
+
+class unique_euclidean_semiring_with_nat_division = unique_euclidean_semiring_with_nat +
+  fixes divmod :: \<open>num \<Rightarrow> num \<Rightarrow> 'a \<times> 'a\<close>
+    and divmod_step :: \<open>'a \<Rightarrow> 'a \<times> 'a \<Rightarrow> 'a \<times> 'a\<close> \<comment> \<open>
+      These are conceptually definitions but force generated code
+      to be monomorphic wrt. particular instances of this class which
+      yields a significant speedup.\<close>
+  assumes divmod_def: \<open>divmod m n = (numeral m div numeral n, numeral m mod numeral n)\<close>
+    and divmod_step_def [simp]: \<open>divmod_step l (q, r) =
+      (if euclidean_size l \<le> euclidean_size r then (2 * q + 1, r - l)
+       else (2 * q, r))\<close> \<comment> \<open>
+         This is a formulation of one step (referring to one digit position)
+         in school-method division: compare the dividend at the current
+         digit position with the remainder from previous division steps
+         and evaluate accordingly.\<close>
+begin
+
+lemma fst_divmod:
+  \<open>fst (divmod m n) = numeral m div numeral n\<close>
+  by (simp add: divmod_def)
+
+lemma snd_divmod:
+  \<open>snd (divmod m n) = numeral m mod numeral n\<close>
+  by (simp add: divmod_def)
+
+text \<open>
+  Following a formulation of school-method division.
+  If the divisor is smaller than the dividend, terminate.
+  If not, shift the dividend to the right until termination
+  occurs and then reiterate single division steps in the
+  opposite direction.
+\<close>
+
+lemma divmod_divmod_step:
+  \<open>divmod m n = (if m < n then (0, numeral m)
+    else divmod_step (numeral n) (divmod m (Num.Bit0 n)))\<close>
+proof (cases \<open>m < n\<close>)
+  case True
+  then show ?thesis
+    by (simp add: prod_eq_iff fst_divmod snd_divmod flip: of_nat_numeral of_nat_div of_nat_mod)
+next
+  case False
+  define r s t where \<open>r = (numeral m :: nat)\<close> \<open>s = (numeral n :: nat)\<close> \<open>t = 2 * s\<close>
+  then have *: \<open>numeral m = of_nat r\<close> \<open>numeral n = of_nat s\<close> \<open>numeral (num.Bit0 n) = of_nat t\<close>
+    and \<open>\<not> s \<le> r mod s\<close>
+    by (simp_all add: not_le)
+  have t: \<open>2 * (r div t) = r div s - r div s mod 2\<close>
+    \<open>r mod t = s * (r div s mod 2) + r mod s\<close>
+    by (simp add: Rings.minus_mod_eq_mult_div Groups.mult.commute [of 2] Euclidean_Division.div_mult2_eq \<open>t = 2 * s\<close>)
+      (use mod_mult2_eq [of r s 2] in \<open>simp add: ac_simps \<open>t = 2 * s\<close>\<close>)
+  have rs: \<open>r div s mod 2 = 0 \<or> r div s mod 2 = Suc 0\<close>
+    by auto
+  from \<open>\<not> s \<le> r mod s\<close> have \<open>s \<le> r mod t \<Longrightarrow>
+     r div s = Suc (2 * (r div t)) \<and>
+     r mod s = r mod t - s\<close>
+    using rs
+    by (auto simp add: t)
+  moreover have \<open>r mod t < s \<Longrightarrow>
+     r div s = 2 * (r div t) \<and>
+     r mod s = r mod t\<close>
+    using rs
+    by (auto simp add: t)
+  ultimately show ?thesis
+    by (simp add: divmod_def prod_eq_iff split_def Let_def
+        not_less mod_eq_0_iff_dvd Rings.mod_eq_0_iff_dvd False not_le *)
+    (simp add: flip: of_nat_numeral of_nat_mult add.commute [of 1] of_nat_div of_nat_mod of_nat_Suc of_nat_diff)
+qed
+
+text \<open>The division rewrite proper -- first, trivial results involving \<open>1\<close>\<close>
+
+lemma divmod_trivial [simp]:
+  "divmod m Num.One = (numeral m, 0)"
+  "divmod num.One (num.Bit0 n) = (0, Numeral1)"
+  "divmod num.One (num.Bit1 n) = (0, Numeral1)"
+  using divmod_divmod_step [of "Num.One"] by (simp_all add: divmod_def)
+
+text \<open>Division by an even number is a right-shift\<close>
+
+lemma divmod_cancel [simp]:
+  \<open>divmod (Num.Bit0 m) (Num.Bit0 n) = (case divmod m n of (q, r) \<Rightarrow> (q, 2 * r))\<close> (is ?P)
+  \<open>divmod (Num.Bit1 m) (Num.Bit0 n) = (case divmod m n of (q, r) \<Rightarrow> (q, 2 * r + 1))\<close> (is ?Q)
+proof -
+  define r s where \<open>r = (numeral m :: nat)\<close> \<open>s = (numeral n :: nat)\<close>
+  then have *: \<open>numeral m = of_nat r\<close> \<open>numeral n = of_nat s\<close>
+    \<open>numeral (num.Bit0 m) = of_nat (2 * r)\<close> \<open>numeral (num.Bit0 n) = of_nat (2 * s)\<close>
+    \<open>numeral (num.Bit1 m) = of_nat (Suc (2 * r))\<close>
+    by simp_all
+  have **: \<open>Suc (2 * r) div 2 = r\<close>
+    by simp
+  show ?P and ?Q
+    by (simp_all add: divmod_def *)
+      (simp_all flip: of_nat_numeral of_nat_div of_nat_mod of_nat_mult add.commute [of 1] of_nat_Suc
+       add: Euclidean_Division.mod_mult_mult1 div_mult2_eq [of _ 2] mod_mult2_eq [of _ 2] **)
+qed
+
+text \<open>The really hard work\<close>
+
+lemma divmod_steps [simp]:
+  "divmod (num.Bit0 m) (num.Bit1 n) =
+      (if m \<le> n then (0, numeral (num.Bit0 m))
+       else divmod_step (numeral (num.Bit1 n))
+             (divmod (num.Bit0 m)
+               (num.Bit0 (num.Bit1 n))))"
+  "divmod (num.Bit1 m) (num.Bit1 n) =
+      (if m < n then (0, numeral (num.Bit1 m))
+       else divmod_step (numeral (num.Bit1 n))
+             (divmod (num.Bit1 m)
+               (num.Bit0 (num.Bit1 n))))"
+  by (simp_all add: divmod_divmod_step)
+
+lemmas divmod_algorithm_code = divmod_trivial divmod_cancel divmod_steps
+
+text \<open>Special case: divisibility\<close>
+
+definition divides_aux :: "'a \<times> 'a \<Rightarrow> bool"
+where
+  "divides_aux qr \<longleftrightarrow> snd qr = 0"
+
+lemma divides_aux_eq [simp]:
+  "divides_aux (q, r) \<longleftrightarrow> r = 0"
+  by (simp add: divides_aux_def)
+
+lemma dvd_numeral_simp [simp]:
+  "numeral m dvd numeral n \<longleftrightarrow> divides_aux (divmod n m)"
+  by (simp add: divmod_def mod_eq_0_iff_dvd)
+
+text \<open>Generic computation of quotient and remainder\<close>
+
+lemma numeral_div_numeral [simp]:
+  "numeral k div numeral l = fst (divmod k l)"
+  by (simp add: fst_divmod)
+
+lemma numeral_mod_numeral [simp]:
+  "numeral k mod numeral l = snd (divmod k l)"
+  by (simp add: snd_divmod)
+
+lemma one_div_numeral [simp]:
+  "1 div numeral n = fst (divmod num.One n)"
+  by (simp add: fst_divmod)
+
+lemma one_mod_numeral [simp]:
+  "1 mod numeral n = snd (divmod num.One n)"
+  by (simp add: snd_divmod)
+
+end
+
+instantiation nat :: unique_euclidean_semiring_with_nat_division
+begin
+
+definition divmod_nat :: "num \<Rightarrow> num \<Rightarrow> nat \<times> nat"
+where
+  divmod'_nat_def: "divmod_nat m n = (numeral m div numeral n, numeral m mod numeral n)"
+
+definition divmod_step_nat :: "nat \<Rightarrow> nat \<times> nat \<Rightarrow> nat \<times> nat"
+where
+  "divmod_step_nat l qr = (let (q, r) = qr
+    in if r \<ge> l then (2 * q + 1, r - l)
+    else (2 * q, r))"
+
+instance
+  by standard (simp_all add: divmod'_nat_def divmod_step_nat_def)
+
+end
+
+declare divmod_algorithm_code [where ?'a = nat, code]
+
+lemma Suc_0_div_numeral [simp]:
+  \<open>Suc 0 div numeral Num.One = 1\<close>
+  \<open>Suc 0 div numeral (Num.Bit0 n) = 0\<close>
+  \<open>Suc 0 div numeral (Num.Bit1 n) = 0\<close>
+  by simp_all
+
+lemma Suc_0_mod_numeral [simp]:
+  \<open>Suc 0 mod numeral Num.One = 0\<close>
+  \<open>Suc 0 mod numeral (Num.Bit0 n) = 1\<close>
+  \<open>Suc 0 mod numeral (Num.Bit1 n) = 1\<close>
+  by simp_all
+
+instantiation int :: unique_euclidean_semiring_with_nat_division
+begin
+
+definition divmod_int :: "num \<Rightarrow> num \<Rightarrow> int \<times> int"
+where
+  "divmod_int m n = (numeral m div numeral n, numeral m mod numeral n)"
+
+definition divmod_step_int :: "int \<Rightarrow> int \<times> int \<Rightarrow> int \<times> int"
+where
+  "divmod_step_int l qr = (let (q, r) = qr
+    in if \<bar>l\<bar> \<le> \<bar>r\<bar> then (2 * q + 1, r - l)
+    else (2 * q, r))"
+
+instance
+  by standard (auto simp add: divmod_int_def divmod_step_int_def)
+
+end
+
+declare divmod_algorithm_code [where ?'a = int, code]
+
+context
+begin
+
+qualified definition adjust_div :: "int \<times> int \<Rightarrow> int"
+where
+  "adjust_div qr = (let (q, r) = qr in q + of_bool (r \<noteq> 0))"
+
+qualified lemma adjust_div_eq [simp, code]:
+  "adjust_div (q, r) = q + of_bool (r \<noteq> 0)"
+  by (simp add: adjust_div_def)
+
+qualified definition adjust_mod :: "num \<Rightarrow> int \<Rightarrow> int"
+where
+  [simp]: "adjust_mod l r = (if r = 0 then 0 else numeral l - r)"
+
+lemma minus_numeral_div_numeral [simp]:
+  "- numeral m div numeral n = - (adjust_div (divmod m n) :: int)"
+proof -
+  have "int (fst (divmod m n)) = fst (divmod m n)"
+    by (simp only: fst_divmod divide_int_def) auto
+  then show ?thesis
+    by (auto simp add: split_def Let_def adjust_div_def divides_aux_def divide_int_def)
+qed
+
+lemma minus_numeral_mod_numeral [simp]:
+  "- numeral m mod numeral n = adjust_mod n (snd (divmod m n) :: int)"
+proof (cases "snd (divmod m n) = (0::int)")
+  case True
+  then show ?thesis
+    by (simp add: mod_eq_0_iff_dvd divides_aux_def)
+next
+  case False
+  then have "int (snd (divmod m n)) = snd (divmod m n)" if "snd (divmod m n) \<noteq> (0::int)"
+    by (simp only: snd_divmod modulo_int_def) auto
+  then show ?thesis
+    by (simp add: divides_aux_def adjust_div_def)
+      (simp add: divides_aux_def modulo_int_def)
+qed
+
+lemma numeral_div_minus_numeral [simp]:
+  "numeral m div - numeral n = - (adjust_div (divmod m n) :: int)"
+proof -
+  have "int (fst (divmod m n)) = fst (divmod m n)"
+    by (simp only: fst_divmod divide_int_def) auto
+  then show ?thesis
+    by (auto simp add: split_def Let_def adjust_div_def divides_aux_def divide_int_def)
+qed
+
+lemma numeral_mod_minus_numeral [simp]:
+  "numeral m mod - numeral n = - adjust_mod n (snd (divmod m n) :: int)"
+proof (cases "snd (divmod m n) = (0::int)")
+  case True
+  then show ?thesis
+    by (simp add: mod_eq_0_iff_dvd divides_aux_def)
+next
+  case False
+  then have "int (snd (divmod m n)) = snd (divmod m n)" if "snd (divmod m n) \<noteq> (0::int)"
+    by (simp only: snd_divmod modulo_int_def) auto
+  then show ?thesis
+    by (simp add: divides_aux_def adjust_div_def)
+      (simp add: divides_aux_def modulo_int_def)
+qed
+
+lemma minus_one_div_numeral [simp]:
+  "- 1 div numeral n = - (adjust_div (divmod Num.One n) :: int)"
+  using minus_numeral_div_numeral [of Num.One n] by simp
+
+lemma minus_one_mod_numeral [simp]:
+  "- 1 mod numeral n = adjust_mod n (snd (divmod Num.One n) :: int)"
+  using minus_numeral_mod_numeral [of Num.One n] by simp
+
+lemma one_div_minus_numeral [simp]:
+  "1 div - numeral n = - (adjust_div (divmod Num.One n) :: int)"
+  using numeral_div_minus_numeral [of Num.One n] by simp
+
+lemma one_mod_minus_numeral [simp]:
+  "1 mod - numeral n = - adjust_mod n (snd (divmod Num.One n) :: int)"
+  using numeral_mod_minus_numeral [of Num.One n] by simp
+
+lemma [code]:
+  fixes k :: int
+  shows
+    "k div 0 = 0"
+    "k mod 0 = k"
+    "0 div k = 0"
+    "0 mod k = 0"
+    "k div Int.Pos Num.One = k"
+    "k mod Int.Pos Num.One = 0"
+    "k div Int.Neg Num.One = - k"
+    "k mod Int.Neg Num.One = 0"
+    "Int.Pos m div Int.Pos n = (fst (divmod m n) :: int)"
+    "Int.Pos m mod Int.Pos n = (snd (divmod m n) :: int)"
+    "Int.Neg m div Int.Pos n = - (adjust_div (divmod m n) :: int)"
+    "Int.Neg m mod Int.Pos n = adjust_mod n (snd (divmod m n) :: int)"
+    "Int.Pos m div Int.Neg n = - (adjust_div (divmod m n) :: int)"
+    "Int.Pos m mod Int.Neg n = - adjust_mod n (snd (divmod m n) :: int)"
+    "Int.Neg m div Int.Neg n = (fst (divmod m n) :: int)"
+    "Int.Neg m mod Int.Neg n = - (snd (divmod m n) :: int)"
+  by simp_all
+
+end
+
+lemma divmod_BitM_2_eq [simp]:
+  \<open>divmod (Num.BitM m) (Num.Bit0 Num.One) = (numeral m - 1, (1 :: int))\<close>
+  by (cases m) simp_all
+
+
+subsubsection \<open>Computation by simplification\<close>
+
+lemma euclidean_size_nat_less_eq_iff:
+  \<open>euclidean_size m \<le> euclidean_size n \<longleftrightarrow> m \<le> n\<close> for m n :: nat
+  by simp
+
+lemma euclidean_size_int_less_eq_iff:
+  \<open>euclidean_size k \<le> euclidean_size l \<longleftrightarrow> \<bar>k\<bar> \<le> \<bar>l\<bar>\<close> for k l :: int
+  by auto
+
+simproc_setup numeral_divmod
+  ("0 div 0 :: 'a :: unique_euclidean_semiring_with_nat_division" | "0 mod 0 :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "0 div 1 :: 'a :: unique_euclidean_semiring_with_nat_division" | "0 mod 1 :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "0 div - 1 :: int" | "0 mod - 1 :: int" |
+   "0 div numeral b :: 'a :: unique_euclidean_semiring_with_nat_division" | "0 mod numeral b :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "0 div - numeral b :: int" | "0 mod - numeral b :: int" |
+   "1 div 0 :: 'a :: unique_euclidean_semiring_with_nat_division" | "1 mod 0 :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "1 div 1 :: 'a :: unique_euclidean_semiring_with_nat_division" | "1 mod 1 :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "1 div - 1 :: int" | "1 mod - 1 :: int" |
+   "1 div numeral b :: 'a :: unique_euclidean_semiring_with_nat_division" | "1 mod numeral b :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "1 div - numeral b :: int" |"1 mod - numeral b :: int" |
+   "- 1 div 0 :: int" | "- 1 mod 0 :: int" | "- 1 div 1 :: int" | "- 1 mod 1 :: int" |
+   "- 1 div - 1 :: int" | "- 1 mod - 1 :: int" | "- 1 div numeral b :: int" | "- 1 mod numeral b :: int" |
+   "- 1 div - numeral b :: int" | "- 1 mod - numeral b :: int" |
+   "numeral a div 0 :: 'a :: unique_euclidean_semiring_with_nat_division" | "numeral a mod 0 :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "numeral a div 1 :: 'a :: unique_euclidean_semiring_with_nat_division" | "numeral a mod 1 :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "numeral a div - 1 :: int" | "numeral a mod - 1 :: int" |
+   "numeral a div numeral b :: 'a :: unique_euclidean_semiring_with_nat_division" | "numeral a mod numeral b :: 'a :: unique_euclidean_semiring_with_nat_division" |
+   "numeral a div - numeral b :: int" | "numeral a mod - numeral b :: int" |
+   "- numeral a div 0 :: int" | "- numeral a mod 0 :: int" |
+   "- numeral a div 1 :: int" | "- numeral a mod 1 :: int" |
+   "- numeral a div - 1 :: int" | "- numeral a mod - 1 :: int" |
+   "- numeral a div numeral b :: int" | "- numeral a mod numeral b :: int" |
+   "- numeral a div - numeral b :: int" | "- numeral a mod - numeral b :: int") = \<open>
+  let
+    val if_cong = the (Code.get_case_cong \<^theory> \<^const_name>\<open>If\<close>);
+    fun successful_rewrite ctxt ct =
+      let
+        val thm = Simplifier.rewrite ctxt ct
+      in if Thm.is_reflexive thm then NONE else SOME thm end;
+  in fn phi =>
+    let
+      val simps = Morphism.fact phi (@{thms div_0 mod_0 div_by_0 mod_by_0 div_by_1 mod_by_1
+        one_div_numeral one_mod_numeral minus_one_div_numeral minus_one_mod_numeral
+        one_div_minus_numeral one_mod_minus_numeral
+        numeral_div_numeral numeral_mod_numeral minus_numeral_div_numeral minus_numeral_mod_numeral
+        numeral_div_minus_numeral numeral_mod_minus_numeral
+        div_minus_minus mod_minus_minus Euclidean_Division.adjust_div_eq of_bool_eq one_neq_zero
+        numeral_neq_zero neg_equal_0_iff_equal arith_simps arith_special divmod_trivial
+        divmod_cancel divmod_steps divmod_step_def fst_conv snd_conv numeral_One
+        case_prod_beta rel_simps Euclidean_Division.adjust_mod_def div_minus1_right mod_minus1_right
+        minus_minus numeral_times_numeral mult_zero_right mult_1_right
+        euclidean_size_nat_less_eq_iff euclidean_size_int_less_eq_iff diff_nat_numeral nat_numeral}
+        @ [@{lemma "0 = 0 \<longleftrightarrow> True" by simp}]);
+      fun prepare_simpset ctxt = HOL_ss |> Simplifier.simpset_map ctxt
+        (Simplifier.add_cong if_cong #> fold Simplifier.add_simp simps)
+    in fn ctxt => successful_rewrite (Simplifier.put_simpset (prepare_simpset ctxt) ctxt) end
+  end
+\<close> \<comment> \<open>
+  There is space for improvement here: the calculation itself
+  could be carried out outside the logic, and a generic simproc
+  (simplifier setup) for generic calculation would be helpful.
+\<close>
+
+
+subsubsection \<open>Code generation\<close>
+
+context
+begin
+
+qualified definition divmod_nat :: "nat \<Rightarrow> nat \<Rightarrow> nat \<times> nat"
+  where "divmod_nat m n = (m div n, m mod n)"
+
+qualified lemma divmod_nat_if [code]:
+  "divmod_nat m n = (if n = 0 \<or> m < n then (0, m) else
+    let (q, r) = divmod_nat (m - n) n in (Suc q, r))"
+  by (simp add: divmod_nat_def prod_eq_iff case_prod_beta not_less le_div_geq le_mod_geq)
+
+qualified lemma [code]:
+  "m div n = fst (divmod_nat m n)"
+  "m mod n = snd (divmod_nat m n)"
+  by (simp_all add: divmod_nat_def)
+
+end
+
+code_identifier
+  code_module Euclidean_Division \<rightharpoonup> (SML) Arith and (OCaml) Arith and (Haskell) Arith
+
+end
diff -urN ./Factorial.thy /cygdrive/c/Isabelle2022/src/HOL/Factorial.thy
--- ./Factorial.thy	2023-05-30 11:49:53.645647300 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Factorial.thy	2023-05-31 14:26:38.861397700 +0900
@@ -28,7 +28,7 @@
   have "prod Suc {0..<n} = \<Prod>{1..n}"
     by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
   then have "prod Suc {0..<n} = prod ((-) (n + 1)) {1..n}"
-    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by presburger
+    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by auto
   then show ?thesis
     unfolding fact_prod_Suc by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
 qed
diff -urN ./Groups_List.thy /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy
--- ./Groups_List.thy	2023-05-30 11:49:53.253421400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy	2023-05-31 15:58:09.698128300 +0900
@@ -3,7 +3,7 @@
 section \<open>Sum and product over lists\<close>
 
 theory Groups_List
-imports List
+imports List Divides
 begin
 
 locale monoid_list = monoid
diff -urN ./Groups_List.thy~ /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy~
--- ./Groups_List.thy~	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy~	2023-05-31 15:57:15.877719500 +0900
@@ -0,0 +1,601 @@
+(* Author: Tobias Nipkow, TU Muenchen *)
+
+section \<open>Sum and product over lists\<close>
+
+theory Groups_List
+imports List
+begin
+
+locale monoid_list = monoid
+begin
+
+definition F :: "'a list \<Rightarrow> 'a"
+where
+  eq_foldr [code]: "F xs = foldr f xs \<^bold>1"
+
+lemma Nil [simp]:
+  "F [] = \<^bold>1"
+  by (simp add: eq_foldr)
+
+lemma Cons [simp]:
+  "F (x # xs) = x \<^bold>* F xs"
+  by (simp add: eq_foldr)
+
+lemma append [simp]:
+  "F (xs @ ys) = F xs \<^bold>* F ys"
+  by (induct xs) (simp_all add: assoc)
+
+end
+
+locale comm_monoid_list = comm_monoid + monoid_list
+begin
+
+lemma rev [simp]:
+  "F (rev xs) = F xs"
+  by (simp add: eq_foldr foldr_fold  fold_rev fun_eq_iff assoc left_commute)
+
+end
+
+locale comm_monoid_list_set = list: comm_monoid_list + set: comm_monoid_set
+begin
+
+lemma distinct_set_conv_list:
+  "distinct xs \<Longrightarrow> set.F g (set xs) = list.F (map g xs)"
+  by (induct xs) simp_all
+
+lemma set_conv_list [code]:
+  "set.F g (set xs) = list.F (map g (remdups xs))"
+  by (simp add: distinct_set_conv_list [symmetric])
+
+end
+
+
+subsection \<open>List summation\<close>
+
+context monoid_add
+begin
+
+sublocale sum_list: monoid_list plus 0
+defines
+  sum_list = sum_list.F ..
+
+end
+
+context comm_monoid_add
+begin
+
+sublocale sum_list: comm_monoid_list plus 0
+rewrites
+  "monoid_list.F plus 0 = sum_list"
+proof -
+  show "comm_monoid_list plus 0" ..
+  then interpret sum_list: comm_monoid_list plus 0 .
+  from sum_list_def show "monoid_list.F plus 0 = sum_list" by simp
+qed
+
+sublocale sum: comm_monoid_list_set plus 0
+rewrites
+  "monoid_list.F plus 0 = sum_list"
+  and "comm_monoid_set.F plus 0 = sum"
+proof -
+  show "comm_monoid_list_set plus 0" ..
+  then interpret sum: comm_monoid_list_set plus 0 .
+  from sum_list_def show "monoid_list.F plus 0 = sum_list" by simp
+  from sum_def show "comm_monoid_set.F plus 0 = sum" by (auto intro: sym)
+qed
+
+end
+
+text \<open>Some syntactic sugar for summing a function over a list:\<close>
+syntax (ASCII)
+  "_sum_list" :: "pttrn => 'a list => 'b => 'b"    ("(3SUM _<-_. _)" [0, 51, 10] 10)
+syntax
+  "_sum_list" :: "pttrn => 'a list => 'b => 'b"    ("(3\<Sum>_\<leftarrow>_. _)" [0, 51, 10] 10)
+translations \<comment> \<open>Beware of argument permutation!\<close>
+  "\<Sum>x\<leftarrow>xs. b" == "CONST sum_list (CONST map (\<lambda>x. b) xs)"
+
+context
+  includes lifting_syntax
+begin
+
+lemma sum_list_transfer [transfer_rule]:
+  "(list_all2 A ===> A) sum_list sum_list"
+    if [transfer_rule]: "A 0 0" "(A ===> A ===> A) (+) (+)"
+  unfolding sum_list.eq_foldr [abs_def]
+  by transfer_prover
+
+end
+
+text \<open>TODO duplicates\<close>
+lemmas sum_list_simps = sum_list.Nil sum_list.Cons
+lemmas sum_list_append = sum_list.append
+lemmas sum_list_rev = sum_list.rev
+
+lemma (in monoid_add) fold_plus_sum_list_rev:
+  "fold plus xs = plus (sum_list (rev xs))"
+proof
+  fix x
+  have "fold plus xs x = sum_list (rev xs @ [x])"
+    by (simp add: foldr_conv_fold sum_list.eq_foldr)
+  also have "\<dots> = sum_list (rev xs) + x"
+    by simp
+  finally show "fold plus xs x = sum_list (rev xs) + x"
+    .
+qed
+
+lemma (in comm_monoid_add) sum_list_map_remove1:
+  "x \<in> set xs \<Longrightarrow> sum_list (map f xs) = f x + sum_list (map f (remove1 x xs))"
+  by (induct xs) (auto simp add: ac_simps)
+
+lemma (in monoid_add) size_list_conv_sum_list:
+  "size_list f xs = sum_list (map f xs) + size xs"
+  by (induct xs) auto
+
+lemma (in monoid_add) length_concat:
+  "length (concat xss) = sum_list (map length xss)"
+  by (induct xss) simp_all
+
+lemma (in monoid_add) length_product_lists:
+  "length (product_lists xss) = foldr (*) (map length xss) 1"
+proof (induct xss)
+  case (Cons xs xss) then show ?case by (induct xs) (auto simp: length_concat o_def)
+qed simp
+
+lemma (in monoid_add) sum_list_map_filter:
+  assumes "\<And>x. x \<in> set xs \<Longrightarrow> \<not> P x \<Longrightarrow> f x = 0"
+  shows "sum_list (map f (filter P xs)) = sum_list (map f xs)"
+  using assms by (induct xs) auto
+
+lemma sum_list_filter_le_nat:
+  fixes f :: "'a \<Rightarrow> nat"
+  shows "sum_list (map f (filter P xs)) \<le> sum_list (map f xs)"
+by(induction xs; simp)
+
+lemma (in comm_monoid_add) distinct_sum_list_conv_Sum:
+  "distinct xs \<Longrightarrow> sum_list xs = Sum (set xs)"
+  by (induct xs) simp_all
+
+lemma sum_list_upt[simp]:
+  "m \<le> n \<Longrightarrow> sum_list [m..<n] = \<Sum> {m..<n}"
+by(simp add: distinct_sum_list_conv_Sum)
+
+context ordered_comm_monoid_add
+begin
+
+lemma sum_list_nonneg: "(\<And>x. x \<in> set xs \<Longrightarrow> 0 \<le> x) \<Longrightarrow> 0 \<le> sum_list xs"
+by (induction xs) auto
+
+lemma sum_list_nonpos: "(\<And>x. x \<in> set xs \<Longrightarrow> x \<le> 0) \<Longrightarrow> sum_list xs \<le> 0"
+by (induction xs) (auto simp: add_nonpos_nonpos)
+
+lemma sum_list_nonneg_eq_0_iff:
+  "(\<And>x. x \<in> set xs \<Longrightarrow> 0 \<le> x) \<Longrightarrow> sum_list xs = 0 \<longleftrightarrow> (\<forall>x\<in> set xs. x = 0)"
+by (induction xs) (simp_all add: add_nonneg_eq_0_iff sum_list_nonneg)
+
+end
+
+context canonically_ordered_monoid_add
+begin
+
+lemma sum_list_eq_0_iff [simp]:
+  "sum_list ns = 0 \<longleftrightarrow> (\<forall>n \<in> set ns. n = 0)"
+by (simp add: sum_list_nonneg_eq_0_iff)
+
+lemma member_le_sum_list:
+  "x \<in> set xs \<Longrightarrow> x \<le> sum_list xs"
+by (induction xs) (auto simp: add_increasing add_increasing2)
+
+lemma elem_le_sum_list:
+  "k < size ns \<Longrightarrow> ns ! k \<le> sum_list (ns)"
+by (rule member_le_sum_list) simp
+
+end
+
+lemma (in ordered_cancel_comm_monoid_diff) sum_list_update:
+  "k < size xs \<Longrightarrow> sum_list (xs[k := x]) = sum_list xs + x - xs ! k"
+apply(induction xs arbitrary:k)
+ apply (auto simp: add_ac split: nat.split)
+apply(drule elem_le_sum_list)
+by (simp add: local.add_diff_assoc local.add_increasing)
+
+lemma (in monoid_add) sum_list_triv:
+  "(\<Sum>x\<leftarrow>xs. r) = of_nat (length xs) * r"
+  by (induct xs) (simp_all add: distrib_right)
+
+lemma (in monoid_add) sum_list_0 [simp]:
+  "(\<Sum>x\<leftarrow>xs. 0) = 0"
+  by (induct xs) (simp_all add: distrib_right)
+
+text\<open>For non-Abelian groups \<open>xs\<close> needs to be reversed on one side:\<close>
+lemma (in ab_group_add) uminus_sum_list_map:
+  "- sum_list (map f xs) = sum_list (map (uminus \<circ> f) xs)"
+  by (induct xs) simp_all
+
+lemma (in comm_monoid_add) sum_list_addf:
+  "(\<Sum>x\<leftarrow>xs. f x + g x) = sum_list (map f xs) + sum_list (map g xs)"
+  by (induct xs) (simp_all add: algebra_simps)
+
+lemma (in ab_group_add) sum_list_subtractf:
+  "(\<Sum>x\<leftarrow>xs. f x - g x) = sum_list (map f xs) - sum_list (map g xs)"
+  by (induct xs) (simp_all add: algebra_simps)
+
+lemma (in semiring_0) sum_list_const_mult:
+  "(\<Sum>x\<leftarrow>xs. c * f x) = c * (\<Sum>x\<leftarrow>xs. f x)"
+  by (induct xs) (simp_all add: algebra_simps)
+
+lemma (in semiring_0) sum_list_mult_const:
+  "(\<Sum>x\<leftarrow>xs. f x * c) = (\<Sum>x\<leftarrow>xs. f x) * c"
+  by (induct xs) (simp_all add: algebra_simps)
+
+lemma (in ordered_ab_group_add_abs) sum_list_abs:
+  "\<bar>sum_list xs\<bar> \<le> sum_list (map abs xs)"
+  by (induct xs) (simp_all add: order_trans [OF abs_triangle_ineq])
+
+lemma sum_list_mono:
+  fixes f g :: "'a \<Rightarrow> 'b::{monoid_add, ordered_ab_semigroup_add}"
+  shows "(\<And>x. x \<in> set xs \<Longrightarrow> f x \<le> g x) \<Longrightarrow> (\<Sum>x\<leftarrow>xs. f x) \<le> (\<Sum>x\<leftarrow>xs. g x)"
+by (induct xs) (simp, simp add: add_mono)
+
+lemma sum_list_strict_mono:
+  fixes f g :: "'a \<Rightarrow> 'b::{monoid_add, strict_ordered_ab_semigroup_add}"
+  shows "\<lbrakk> xs \<noteq> [];  \<And>x. x \<in> set xs \<Longrightarrow> f x < g x \<rbrakk>
+    \<Longrightarrow> sum_list (map f xs) < sum_list (map g xs)"
+proof (induction xs)
+  case Nil thus ?case by simp
+next
+  case C: (Cons _ xs)
+  show ?case
+  proof (cases xs)
+    case Nil thus ?thesis using C.prems by simp
+  next
+    case Cons thus ?thesis using C by(simp add: add_strict_mono)
+  qed
+qed
+
+text \<open>A much more general version of this monotonicity lemma
+can be formulated with multisets and the multiset order\<close>
+
+lemma sum_list_mono2: fixes xs :: "'a ::ordered_comm_monoid_add list"
+shows "\<lbrakk> length xs = length ys; \<And>i. i < length xs \<longrightarrow> xs!i \<le> ys!i \<rbrakk>
+  \<Longrightarrow> sum_list xs \<le> sum_list ys"
+apply(induction xs ys rule: list_induct2)
+by(auto simp: nth_Cons' less_Suc_eq_0_disj imp_ex add_mono)
+
+lemma (in monoid_add) sum_list_distinct_conv_sum_set:
+  "distinct xs \<Longrightarrow> sum_list (map f xs) = sum f (set xs)"
+  by (induct xs) simp_all
+
+lemma (in monoid_add) interv_sum_list_conv_sum_set_nat:
+  "sum_list (map f [m..<n]) = sum f (set [m..<n])"
+  by (simp add: sum_list_distinct_conv_sum_set)
+
+lemma (in monoid_add) interv_sum_list_conv_sum_set_int:
+  "sum_list (map f [k..l]) = sum f (set [k..l])"
+  by (simp add: sum_list_distinct_conv_sum_set)
+
+text \<open>General equivalence between \<^const>\<open>sum_list\<close> and \<^const>\<open>sum\<close>\<close>
+lemma (in monoid_add) sum_list_sum_nth:
+  "sum_list xs = (\<Sum> i = 0 ..< length xs. xs ! i)"
+  using interv_sum_list_conv_sum_set_nat [of "(!) xs" 0 "length xs"] by (simp add: map_nth)
+
+lemma sum_list_map_eq_sum_count:
+  "sum_list (map f xs) = sum (\<lambda>x. count_list xs x * f x) (set xs)"
+proof(induction xs)
+  case (Cons x xs)
+  show ?case (is "?l = ?r")
+  proof cases
+    assume "x \<in> set xs"
+    have "?l = f x + (\<Sum>x\<in>set xs. count_list xs x * f x)" by (simp add: Cons.IH)
+    also have "set xs = insert x (set xs - {x})" using \<open>x \<in> set xs\<close>by blast
+    also have "f x + (\<Sum>x\<in>insert x (set xs - {x}). count_list xs x * f x) = ?r"
+      by (simp add: sum.insert_remove eq_commute)
+    finally show ?thesis .
+  next
+    assume "x \<notin> set xs"
+    hence "\<And>xa. xa \<in> set xs \<Longrightarrow> x \<noteq> xa" by blast
+    thus ?thesis by (simp add: Cons.IH \<open>x \<notin> set xs\<close>)
+  qed
+qed simp
+
+lemma sum_list_map_eq_sum_count2:
+assumes "set xs \<subseteq> X" "finite X"
+shows "sum_list (map f xs) = sum (\<lambda>x. count_list xs x * f x) X"
+proof-
+  let ?F = "\<lambda>x. count_list xs x * f x"
+  have "sum ?F X = sum ?F (set xs \<union> (X - set xs))"
+    using Un_absorb1[OF assms(1)] by(simp)
+  also have "\<dots> = sum ?F (set xs)"
+    using assms(2)
+    by(simp add: sum.union_disjoint[OF _ _ Diff_disjoint] del: Un_Diff_cancel)
+  finally show ?thesis by(simp add:sum_list_map_eq_sum_count)
+qed
+
+lemma sum_list_replicate: "sum_list (replicate n c) = of_nat n * c"
+by(induction n)(auto simp add: distrib_right)
+
+
+lemma sum_list_nonneg:
+    "(\<And>x. x \<in> set xs \<Longrightarrow> (x :: 'a :: ordered_comm_monoid_add) \<ge> 0) \<Longrightarrow> sum_list xs \<ge> 0"
+  by (induction xs) simp_all
+
+lemma sum_list_Suc:
+  "sum_list (map (\<lambda>x. Suc(f x)) xs) = sum_list (map f xs) + length xs"
+by(induction xs; simp)
+
+lemma (in monoid_add) sum_list_map_filter':
+  "sum_list (map f (filter P xs)) = sum_list (map (\<lambda>x. if P x then f x else 0) xs)"
+  by (induction xs) simp_all
+
+text \<open>Summation of a strictly ascending sequence with length \<open>n\<close>
+  can be upper-bounded by summation over \<open>{0..<n}\<close>.\<close>
+
+lemma sorted_wrt_less_sum_mono_lowerbound:
+  fixes f :: "nat \<Rightarrow> ('b::ordered_comm_monoid_add)"
+  assumes mono: "\<And>x y. x\<le>y \<Longrightarrow> f x \<le> f y"
+  shows "sorted_wrt (<) ns \<Longrightarrow>
+    (\<Sum>i\<in>{0..<length ns}. f i) \<le> (\<Sum>i\<leftarrow>ns. f i)"
+proof (induction ns rule: rev_induct)
+  case Nil
+  then show ?case by simp
+next
+  case (snoc n ns)
+  have "sum f {0..<length (ns @ [n])}
+      = sum f {0..<length ns} + f (length ns)"
+    by simp
+  also have "sum f {0..<length ns} \<le> sum_list (map f ns)"
+    using snoc by (auto simp: sorted_wrt_append)
+  also have "length ns \<le> n"
+    using sorted_wrt_less_idx[OF snoc.prems(1), of "length ns"] by auto
+  finally have "sum f {0..<length (ns @ [n])} \<le> sum_list (map f ns) + f n"
+    using mono add_mono by blast
+  thus ?case by simp
+qed
+
+
+subsection \<open>Horner sums\<close>
+
+context comm_semiring_0
+begin
+
+definition horner_sum :: \<open>('b \<Rightarrow> 'a) \<Rightarrow> 'a \<Rightarrow> 'b list \<Rightarrow> 'a\<close>
+  where horner_sum_foldr: \<open>horner_sum f a xs = foldr (\<lambda>x b. f x + a * b) xs 0\<close>
+
+lemma horner_sum_simps [simp]:
+  \<open>horner_sum f a [] = 0\<close>
+  \<open>horner_sum f a (x # xs) = f x + a * horner_sum f a xs\<close>
+  by (simp_all add: horner_sum_foldr)
+
+lemma horner_sum_eq_sum_funpow:
+  \<open>horner_sum f a xs = (\<Sum>n = 0..<length xs. ((*) a ^^ n) (f (xs ! n)))\<close>
+proof (induction xs)
+  case Nil
+  then show ?case
+    by simp
+next
+  case (Cons x xs)
+  then show ?case
+    by (simp add: sum.atLeast0_lessThan_Suc_shift sum_distrib_left del: sum.op_ivl_Suc)
+qed
+
+end
+
+context
+  includes lifting_syntax
+begin
+
+lemma horner_sum_transfer [transfer_rule]:
+  \<open>((B ===> A) ===> A ===> list_all2 B ===> A) horner_sum horner_sum\<close>
+  if [transfer_rule]: \<open>A 0 0\<close>
+    and [transfer_rule]: \<open>(A ===> A ===> A) (+) (+)\<close>
+    and [transfer_rule]: \<open>(A ===> A ===> A) (*) (*)\<close>
+  by (unfold horner_sum_foldr) transfer_prover
+
+end
+
+context comm_semiring_1
+begin
+
+lemma horner_sum_eq_sum:
+  \<open>horner_sum f a xs = (\<Sum>n = 0..<length xs. f (xs ! n) * a ^ n)\<close>
+proof -
+  have \<open>(*) a ^^ n = (*) (a ^ n)\<close> for n
+    by (induction n) (simp_all add: ac_simps)
+  then show ?thesis
+    by (simp add: horner_sum_eq_sum_funpow ac_simps)
+qed
+
+lemma horner_sum_append:
+  \<open>horner_sum f a (xs @ ys) = horner_sum f a xs + a ^ length xs * horner_sum f a ys\<close>
+  using sum.atLeastLessThan_shift_bounds [of _ 0 \<open>length xs\<close> \<open>length ys\<close>]
+    atLeastLessThan_add_Un [of 0 \<open>length xs\<close> \<open>length ys\<close>]
+  by (simp add: horner_sum_eq_sum sum_distrib_left sum.union_disjoint ac_simps nth_append power_add)
+
+end
+
+context linordered_semidom
+begin
+
+lemma horner_sum_nonnegative:
+  \<open>0 \<le> horner_sum of_bool 2 bs\<close>
+  by (induction bs) simp_all
+
+end
+
+context unique_euclidean_semiring_numeral
+begin
+
+lemma horner_sum_bound:
+  \<open>horner_sum of_bool 2 bs < 2 ^ length bs\<close>
+proof (induction bs)
+  case Nil
+  then show ?case
+    by simp
+next
+  case (Cons b bs)
+  moreover define a where \<open>a = 2 ^ length bs - horner_sum of_bool 2 bs\<close>
+  ultimately have *: \<open>2 ^ length bs = horner_sum of_bool 2 bs + a\<close>
+    by simp
+  have \<open>1 < a * 2\<close> if \<open>0 < a\<close>
+    using that add_mono [of 1 a 1 a]
+    by (simp add: mult_2_right discrete)
+  with Cons show ?case
+    by (simp add: algebra_simps *)
+qed
+
+end
+
+lemma nat_horner_sum [simp]:
+  \<open>nat (horner_sum of_bool 2 bs) = horner_sum of_bool 2 bs\<close>
+  by (induction bs) (auto simp add: nat_add_distrib horner_sum_nonnegative)
+
+context unique_euclidean_semiring_numeral
+begin
+
+lemma horner_sum_less_eq_iff_lexordp_eq:
+  \<open>horner_sum of_bool 2 bs \<le> horner_sum of_bool 2 cs \<longleftrightarrow> lexordp_eq (rev bs) (rev cs)\<close>
+  if \<open>length bs = length cs\<close>
+proof -
+  have \<open>horner_sum of_bool 2 (rev bs) \<le> horner_sum of_bool 2 (rev cs) \<longleftrightarrow> lexordp_eq bs cs\<close>
+    if \<open>length bs = length cs\<close> for bs cs
+  using that proof (induction bs cs rule: list_induct2)
+    case Nil
+    then show ?case
+      by simp
+  next
+    case (Cons b bs c cs)
+    with horner_sum_nonnegative [of \<open>rev bs\<close>] horner_sum_nonnegative [of \<open>rev cs\<close>]
+      horner_sum_bound [of \<open>rev bs\<close>] horner_sum_bound [of \<open>rev cs\<close>]
+    show ?case
+      by (auto simp add: horner_sum_append not_le Cons intro: add_strict_increasing2 add_increasing)
+  qed
+  from that this [of \<open>rev bs\<close> \<open>rev cs\<close>] show ?thesis
+    by simp
+qed
+
+lemma horner_sum_less_iff_lexordp:
+  \<open>horner_sum of_bool 2 bs < horner_sum of_bool 2 cs \<longleftrightarrow> ord_class.lexordp (rev bs) (rev cs)\<close>
+  if \<open>length bs = length cs\<close>
+proof -
+  have \<open>horner_sum of_bool 2 (rev bs) < horner_sum of_bool 2 (rev cs) \<longleftrightarrow> ord_class.lexordp bs cs\<close>
+    if \<open>length bs = length cs\<close> for bs cs
+  using that proof (induction bs cs rule: list_induct2)
+    case Nil
+    then show ?case
+      by simp
+  next
+    case (Cons b bs c cs)
+    with horner_sum_nonnegative [of \<open>rev bs\<close>] horner_sum_nonnegative [of \<open>rev cs\<close>]
+      horner_sum_bound [of \<open>rev bs\<close>] horner_sum_bound [of \<open>rev cs\<close>]
+    show ?case
+      by (auto simp add: horner_sum_append not_less Cons intro: add_strict_increasing2 add_increasing)
+  qed
+  from that this [of \<open>rev bs\<close> \<open>rev cs\<close>] show ?thesis
+    by simp
+qed
+
+end
+
+
+subsection \<open>Further facts about \<^const>\<open>List.n_lists\<close>\<close>
+
+lemma length_n_lists: "length (List.n_lists n xs) = length xs ^ n"
+  by (induct n) (auto simp add: comp_def length_concat sum_list_triv)
+
+lemma distinct_n_lists:
+  assumes "distinct xs"
+  shows "distinct (List.n_lists n xs)"
+proof (rule card_distinct)
+  from assms have card_length: "card (set xs) = length xs" by (rule distinct_card)
+  have "card (set (List.n_lists n xs)) = card (set xs) ^ n"
+  proof (induct n)
+    case 0 then show ?case by simp
+  next
+    case (Suc n)
+    moreover have "card (\<Union>ys\<in>set (List.n_lists n xs). (\<lambda>y. y # ys) ` set xs)
+      = (\<Sum>ys\<in>set (List.n_lists n xs). card ((\<lambda>y. y # ys) ` set xs))"
+      by (rule card_UN_disjoint) auto
+    moreover have "\<And>ys. card ((\<lambda>y. y # ys) ` set xs) = card (set xs)"
+      by (rule card_image) (simp add: inj_on_def)
+    ultimately show ?case by auto
+  qed
+  also have "\<dots> = length xs ^ n" by (simp add: card_length)
+  finally show "card (set (List.n_lists n xs)) = length (List.n_lists n xs)"
+    by (simp add: length_n_lists)
+qed
+
+
+subsection \<open>Tools setup\<close>
+
+lemmas sum_code = sum.set_conv_list
+
+lemma sum_set_upto_conv_sum_list_int [code_unfold]:
+  "sum f (set [i..j::int]) = sum_list (map f [i..j])"
+  by (simp add: interv_sum_list_conv_sum_set_int)
+
+lemma sum_set_upt_conv_sum_list_nat [code_unfold]:
+  "sum f (set [m..<n]) = sum_list (map f [m..<n])"
+  by (simp add: interv_sum_list_conv_sum_set_nat)
+
+
+subsection \<open>List product\<close>
+
+context monoid_mult
+begin
+
+sublocale prod_list: monoid_list times 1
+defines
+  prod_list = prod_list.F ..
+
+end
+
+context comm_monoid_mult
+begin
+
+sublocale prod_list: comm_monoid_list times 1
+rewrites
+  "monoid_list.F times 1 = prod_list"
+proof -
+  show "comm_monoid_list times 1" ..
+  then interpret prod_list: comm_monoid_list times 1 .
+  from prod_list_def show "monoid_list.F times 1 = prod_list" by simp
+qed
+
+sublocale prod: comm_monoid_list_set times 1
+rewrites
+  "monoid_list.F times 1 = prod_list"
+  and "comm_monoid_set.F times 1 = prod"
+proof -
+  show "comm_monoid_list_set times 1" ..
+  then interpret prod: comm_monoid_list_set times 1 .
+  from prod_list_def show "monoid_list.F times 1 = prod_list" by simp
+  from prod_def show "comm_monoid_set.F times 1 = prod" by (auto intro: sym)
+qed
+
+end
+
+text \<open>Some syntactic sugar:\<close>
+
+syntax (ASCII)
+  "_prod_list" :: "pttrn => 'a list => 'b => 'b"    ("(3PROD _<-_. _)" [0, 51, 10] 10)
+syntax
+  "_prod_list" :: "pttrn => 'a list => 'b => 'b"    ("(3\<Prod>_\<leftarrow>_. _)" [0, 51, 10] 10)
+translations \<comment> \<open>Beware of argument permutation!\<close>
+  "\<Prod>x\<leftarrow>xs. b" \<rightleftharpoons> "CONST prod_list (CONST map (\<lambda>x. b) xs)"
+
+context
+  includes lifting_syntax
+begin
+
+lemma prod_list_transfer [transfer_rule]:
+  "(list_all2 A ===> A) prod_list prod_list"
+    if [transfer_rule]: "A 1 1" "(A ===> A ===> A) (*) (*)"
+  unfolding prod_list.eq_foldr [abs_def]
+  by transfer_prover
+
+end
+
+lemma prod_list_zero_iff:
+  "prod_list xs = 0 \<longleftrightarrow> (0 :: 'a :: {semiring_no_zero_divisors, semiring_1}) \<in> set xs"
+  by (induction xs) simp_all
+
+end
diff -urN ./List.thy /cygdrive/c/Isabelle2022/src/HOL/List.thy
--- ./List.thy	2023-05-30 11:50:42.721423600 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/List.thy	2023-05-31 14:26:38.879025000 +0900
@@ -5,7 +5,7 @@
 section \<open>The datatype of finite lists\<close>
 
 theory List
-imports Sledgehammer Lifting_Set
+imports Lifting_Set Set_Interval Numeral_Simprocs
 begin
 
 datatype (set: 'a) list =
@@ -962,13 +962,13 @@
 by (induct xs) auto
 
 lemma hd_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> hd (xs @ ys) = hd xs"
-by (simp add: hd_append split: list.split)
+by (simp add: hd_append)
 
 lemma tl_append: "tl (xs @ ys) = (case xs of [] \<Rightarrow> tl ys | z#zs \<Rightarrow> zs @ ys)"
-by (simp split: list.split)
+by (cases xs; simp)
 
 lemma tl_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> tl (xs @ ys) = tl xs @ ys"
-by (simp add: tl_append split: list.split)
+by (cases xs;simp add: tl_append)
 
 lemma tl_append_if: "tl (xs @ ys) = (if xs = [] then tl ys else tl xs @ ys)"
 by (simp)
@@ -1520,6 +1520,7 @@
 in K list_neq end
 \<close>
 
+
 subsubsection \<open>\<^const>\<open>filter\<close>\<close>
 
 lemma filter_append [simp]: "filter P (xs @ ys) = filter P xs @ filter P ys"
@@ -1591,7 +1592,7 @@
   proof (cases)
     assume "p x"
     hence eq: "?S' = insert 0 (Suc ` ?S)"
-      by(auto simp: image_def split:nat.split dest:gr0_implies_Suc)
+      by (auto simp: image_def dest:gr0_implies_Suc)
     have "length (filter p (x # xs)) = Suc(card ?S)"
       using Cons \<open>p x\<close> by simp
     also have "\<dots> = Suc(card(Suc ` ?S))" using fin
@@ -1854,7 +1855,6 @@
   qed
 qed
 
-
 subsubsection \<open>\<^const>\<open>list_update\<close>\<close>
 
 lemma length_list_update [simp]: "length(xs[i:=x]) = length xs"
@@ -2376,7 +2376,6 @@
 lemma nth_image: "l \<le> size xs \<Longrightarrow> nth xs ` {0..<l} = set(take l xs)"
   by (simp add: set_conv_nth) force
 
-
 subsubsection \<open>\<^const>\<open>takeWhile\<close> and \<^const>\<open>dropWhile\<close>\<close>
 
 lemma length_takeWhile_le: "length (takeWhile P xs) \<le> length xs"
@@ -2440,7 +2439,7 @@
   by (induct xs) (auto split: if_split_asm)
 
 lemma set_takeWhileD: "x \<in> set (takeWhile P xs) \<Longrightarrow> x \<in> set xs \<and> P x"
-  by (induct xs) (auto split: if_split_asm)
+  by (induct xs;auto) 
 
 lemma takeWhile_eq_all_conv[simp]:
   "(takeWhile P xs = xs) = (\<forall>x \<in> set xs. P x)"
@@ -2596,7 +2595,7 @@
 
 lemma zip_Cons1:
   "zip (x#xs) ys = (case ys of [] \<Rightarrow> [] | y#ys \<Rightarrow> (x,y)#zip xs ys)"
-  by(auto split:list.split)
+  by (cases xs; cases ys; simp)
 
 lemma length_zip [simp]:
   "length (zip xs ys) = min (length xs) (length ys)"
@@ -3072,7 +3071,6 @@
   then show "xs \<in> ?L" by induct auto
 qed
 
-
 subsubsection \<open>\<^const>\<open>fold\<close> with natural argument order\<close>
 
 lemma fold_simps [code]: \<comment> \<open>eta-expanded variant for generated code -- enables tail-recursion optimisation in Scala\<close>
@@ -3421,7 +3419,6 @@
     by simp
 qed
 
-
 subsubsection \<open>\<open>upto\<close>: interval-list on \<^typ>\<open>int\<close>\<close>
 
 function upto :: "int \<Rightarrow> int \<Rightarrow> int list" ("(1[_../_])") where
@@ -4159,7 +4156,7 @@
 
 lemma remdups_adj_append'': "xs \<noteq> []
   \<Longrightarrow> remdups_adj (xs @ ys) = remdups_adj xs @ remdups_adj (dropWhile (\<lambda>y. y = last xs) ys)"
-by (induction xs rule: remdups_adj.induct) (auto simp: remdups_adj_Cons')
+  by (induction xs rule: remdups_adj.induct) (auto simp: remdups_adj_Cons')
 
 
 subsection \<open>@{const distinct_adj}\<close>
@@ -4462,9 +4459,14 @@
   distinct (removeAll [] xs) \<and>
   (\<forall>ys. ys \<in> set xs \<longrightarrow> distinct ys) \<and>
   (\<forall>ys zs. ys \<in> set xs \<and> zs \<in> set xs \<and> ys \<noteq> zs \<longrightarrow> set ys \<inter> set zs = {})"
-apply (induct xs)
- apply(simp_all, safe, auto)
-by (metis Int_iff UN_I empty_iff equals0I set_empty)
+  apply (fold disjnt_def)
+proof(induct xs)
+  case Nil
+  then show ?case by simp
+next
+  case (Cons a xs)
+  show ?case by (auto simp: Cons Ball_def disjnt_def[symmetric] disjnt_sym)
+qed
 
 
 subsubsection \<open>\<^const>\<open>replicate\<close>\<close>
@@ -4946,7 +4948,6 @@
   with Cons show ?case by(simp add: nths_Cons cong:filter_cong)
 qed
 
-
 subsubsection \<open>\<^const>\<open>subseqs\<close> and \<^const>\<open>List.n_lists\<close>\<close>
 
 lemma length_subseqs: "length (subseqs xs) = 2 ^ length xs"
@@ -5050,7 +5051,16 @@
   "z # zs \<in> shuffles xs ys \<longleftrightarrow>
     (xs \<noteq> [] \<and> hd xs = z \<and> zs \<in> shuffles (tl xs) ys \<or>
      ys \<noteq> [] \<and> hd ys = z \<and> zs \<in> shuffles xs (tl ys))"
-  by (induct xs ys rule: shuffles.induct) auto
+proof(induct xs ys rule: shuffles.induct)
+  case (1 ys)
+  then show ?case by auto
+next
+  case (2 xs)
+  then show ?case by auto
+next
+  case (3 x xs y ys)
+  show ?case by (auto simp add: 3)
+qed
 
 lemma splice_in_shuffles [simp, intro]: "splice xs ys \<in> shuffles xs ys"
   by (induction xs ys rule: splice.induct) (simp_all add: Cons_in_shuffles_iff shuffles_commutes)
@@ -5197,20 +5207,29 @@
   (is "max _ ?foldB = Suc (max _ ?foldA)")
 proof (cases "(filter (\<lambda>ys. ys \<noteq> []) xss) = []")
   case True
-  hence "foldr (\<lambda>xs. max (length xs)) xss 0 = 0"
+  then show ?thesis 
   proof (induct xss)
-    case (Cons x xs)
-    then have "x = []" by (cases x) auto
-    with Cons show ?case by auto
-  qed simp
-  thus ?thesis using True by simp
+    case Nil
+    then show ?case by simp
+  next
+    case (Cons a xsss)
+    then show ?case 
+      by (cases a; simp add: filter_def)
+  qed
 next
   case False
 
   have foldA: "?foldA = foldr (\<lambda>x. max (length x)) (filter (\<lambda>ys. ys \<noteq> []) xss) 0 - 1"
-    by (induct xss) auto
+  proof(induct xss)
+    case Nil
+    then show ?case by simp
+  next
+    case IH: (Cons a xss)
+    then show ?case by (cases a; simp add: filter_def)
+  qed
+
   have foldB: "?foldB = foldr (\<lambda>x. max (length x)) (filter (\<lambda>ys. ys \<noteq> []) xss) 0"
-    by (induct xss) auto
+    by (induct xss; simp) 
 
   have "0 < ?foldB"
   proof -
@@ -6363,7 +6382,7 @@
 
 lemma sorted_list_of_set_lessThan_Suc [simp]:
   "sorted_list_of_set {..<Suc k} = sorted_list_of_set {..<k} @ [k]"
-  using le0 lessThan_atLeast0 sorted_list_of_set_range upt_Suc_append by presburger
+  using lessThan_atLeast0 by auto
 
 lemma sorted_list_of_set_atMost_Suc [simp]:
   "sorted_list_of_set {..Suc k} = sorted_list_of_set {..k} @ [Suc k]"
@@ -6835,7 +6854,7 @@
     by blast
   hence "((u@v)!i, (w@z)!i) \<in> r"
     unfolding nth_append using less_le_trans[OF \<open>i < length w\<close> assms(2)] \<open>(u!i,w!i) \<in> r\<close>
-    by presburger
+    by auto
   moreover have "i < min (length (u@v)) (length (w@z))"
     using assms(2) \<open>i < length w\<close> by simp
   moreover have "take i (u@v) = take i (w@z)"
diff -urN ./MacLaurin.thy /cygdrive/c/Isabelle2022/src/HOL/MacLaurin.thy
--- ./MacLaurin.thy	2023-05-30 11:50:42.798563100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/MacLaurin.thy	2023-05-31 14:26:38.879025000 +0900
@@ -22,7 +22,7 @@
 
 lemma eq_diff_eq': "x = y - z \<longleftrightarrow> y = x + z"
   for x y z :: real
-  by arith
+  by (auto elim: iffE)
 
 lemma fact_diff_Suc: "n < Suc m \<Longrightarrow> fact (Suc m - n) = (Suc m - n) * fact (m - n)"
   by (subst fact_reduce) auto
@@ -343,25 +343,37 @@
 lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
 
+lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "even m")
+  case t: True
+    then show ?thesis by (simp add: sin_coeff_def sin_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: sin_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_sin_expansion2:
   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
 proof (cases "n = 0 \<or> x = 0")
+  case True
+  then show ?thesis by auto
+next
   case False
-  let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
-  have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
+    let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
+    have tex: "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
       (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
-  proof (rule Maclaurin_all_lt)
-    show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
+    proof (rule Maclaurin_all_lt)
+      show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
            sin (x + 1/2 * real (Suc m) * pi)) (at x)"
-      by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
-  qed (use False in auto)
-  then show ?thesis
-    apply (rule ex_forward, simp)
-    apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
-qed auto
+        by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
+    qed (use False in auto)
+    from tex show ?thesis
+      apply (rule ex_forward, simp)
+      apply (rule sum.cong[OF refl])
+      by (simp add: sin_coeff_lemma)
+  qed
 
 lemma Maclaurin_sin_expansion:
   "\<exists>t. sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -385,8 +397,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 lemma Maclaurin_sin_expansion4:
@@ -406,8 +417,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 
@@ -419,6 +429,16 @@
 lemma cos_expansion_lemma: "cos (x + real (Suc m) * pi / 2) = - sin (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add distrib_right add_divide_distrib)
 
+lemma cos_coeff_lemma: "cos_coeff m * x ^ m  = cos (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "odd m")
+  case t: True
+    then show ?thesis by (simp add: cos_coeff_def cos_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: cos_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_cos_expansion:
   "\<exists>t::real. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     cos x = (\<Sum>m<n. cos_coeff m * x ^ m) + (cos(t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -436,8 +456,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE simp del: of_nat_Suc)
-    done
+    by (simp add: cos_coeff_lemma)
 qed auto
 
 lemma Maclaurin_cos_expansion2:
@@ -456,8 +475,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 lemma Maclaurin_minus_cos_expansion:
@@ -476,8 +494,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 
@@ -537,7 +554,7 @@
   shows "\<exists>t::real. c < t \<and> t < b \<and>
     f b = (\<Sum>m<n. (diff m c / fact m) * (b - c)^m) + (diff n t / fact n) * (b - c)^n"
 proof -
-  from INTERV have "0 < b - c" by arith
+  from INTERV have "0 < b - c" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -573,7 +590,7 @@
   shows "\<exists>t. a < t \<and> t < c \<and>
     f a = (\<Sum>m<n. (diff m c / fact m) * (a - c)^m) + (diff n t / fact n) * (a - c)^n"
 proof -
-  from INTERV have "a-c < 0" by arith
+  from INTERV have "a-c < 0" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -627,9 +644,9 @@
   moreover have "\<forall>m t. m < n \<and> a \<le> t \<and> t \<le> x \<longrightarrow> DERIV (diff m) t :> diff (Suc m) t"
     using DERIV and INTERV by fastforce
   moreover from INTERV have "a \<le> c"
-    by arith
+    by simp
   moreover from False and INTERV have "c < x"
-    by arith
+    by simp
   ultimately have "\<exists>t>c. t < x \<and> f x =
     (\<Sum>m<n. diff m c / (fact m) * (x - c) ^ m) + diff n t / (fact n) * (x - c) ^ n"
     by (rule Taylor_up)
diff -urN ./Main.thy /cygdrive/c/Isabelle2022/src/HOL/Main.thy
--- ./Main.thy	2023-05-30 11:49:55.729754800 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Main.thy	2023-05-31 14:26:38.879025000 +0900
@@ -8,10 +8,10 @@
 theory Main
   imports
     Predicate_Compile
-    Quickcheck_Narrowing
+    (*Quickcheck_Narrowing*)
     Mirabelle
     Extraction
-    Nunchaku
+    (*Nunchaku*)
     BNF_Greatest_Fixpoint
     Filter
     Conditionally_Complete_Lattices
diff -urN ./Nitpick.thy /cygdrive/c/Isabelle2022/src/HOL/Nitpick.thy
--- ./Nitpick.thy	2023-05-30 11:49:54.739036200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Nitpick.thy	2023-05-31 14:26:38.879025000 +0900
@@ -8,7 +8,7 @@
 section \<open>Nitpick: Yet Another Counterexample Generator for Isabelle/HOL\<close>
 
 theory Nitpick
-imports Record GCD
+imports Record GCD Sledgehammer
 keywords
   "nitpick" :: diag and
   "nitpick_params" :: thy_decl
diff -urN ./Predicate_Compile.thy /cygdrive/c/Isabelle2022/src/HOL/Predicate_Compile.thy
--- ./Predicate_Compile.thy	2023-05-30 11:49:55.926685800 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Predicate_Compile.thy	2023-05-31 14:26:38.879025000 +0900
@@ -1,11 +1,7 @@
-(*  Title:      HOL/Predicate_Compile.thy
-    Author:     Stefan Berghofer, Lukas Bulwahn, Florian Haftmann, TU Muenchen
-*)
-
 section \<open>A compiler for predicates defined by introduction rules\<close>
 
 theory Predicate_Compile
-imports Random_Sequence Quickcheck_Exhaustive
+imports Random_Sequence Random_Prep (*Quickcheck_Exhaustive*)
 keywords
   "code_pred" :: thy_goal and
   "values" :: diag
diff -urN ./Quickcheck_Exhaustive.thy /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Exhaustive.thy
--- ./Quickcheck_Exhaustive.thy	2023-05-30 11:49:56.585222900 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Exhaustive.thy	2023-05-31 14:26:38.894298600 +0900
@@ -15,14 +15,14 @@
   where [code_unfold]: "x orelse y = (case x of Some x' \<Rightarrow> Some x' | None \<Rightarrow> y)"
 
 
-subsection \<open>Exhaustive generator type classes\<close>
+(*subsection \<open>Exhaustive generator type classes\<close>
 
 class exhaustive = term_of +
   fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
 
 class full_exhaustive = term_of +
   fixes full_exhaustive ::
-    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"*)
 
 instantiation natural :: full_exhaustive
 begin
@@ -226,7 +226,7 @@
      else
       f valterm_emptyset orelse
       full_exhaustive_set
-        (\<lambda>A. f A orelse Quickcheck_Exhaustive.full_exhaustive
+        (\<lambda>A. f A orelse Random_Prep.full_exhaustive
           (\<lambda>x. if fst x \<in> fst A then None else f (valtermify_insert x A)) (i - 1)) (i - 1))"
 
 instance ..
@@ -649,7 +649,7 @@
     (Quickcheck) "(((_); NONE) handle Exhaustive'_Generators.Counterexample ts \<Rightarrow> SOME ts)"
 
 
-subsection \<open>Continuation passing style functions as plus monad\<close>
+(*subsection \<open>Continuation passing style functions as plus monad\<close>
 
 type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
 
@@ -731,7 +731,7 @@
 
 definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
   where "pos_bound_cps_not n =
-    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"*)
 
 
 subsection \<open>Defining generators for any first-order data type\<close>
@@ -766,13 +766,13 @@
   check_all enum_term_of
   orelse unknown mk_map_term check_all_n_lists check_all_subsets
 
-hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+(*hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
 
 hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
   pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
   pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
   neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
   neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
-  Unknown Known Unknown_value Value No_value
+  Unknown Known Unknown_value Value No_value*)
 
 end
diff -urN ./Quickcheck_Random.thy /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Random.thy
--- ./Quickcheck_Random.thy	2023-05-30 11:49:56.406913000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Random.thy	2023-05-31 14:26:38.896504500 +0900
@@ -5,7 +5,7 @@
 section \<open>A simple counterexample generator performing random testing\<close>
 
 theory Quickcheck_Random
-imports Random Code_Evaluation Enum
+  imports Random_Prep
 begin
 
 setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>
@@ -19,7 +19,7 @@
 
 code_reserved Quickcheck Match
 
-subsection \<open>The \<open>random\<close> class\<close>
+(*subsection \<open>The \<open>random\<close> class\<close>
 
 class random = typerep +
   fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
@@ -182,7 +182,7 @@
 
 instance ..
 
-end
+end*)
 
 text \<open>Towards type copies and datatypes\<close>
 
@@ -213,7 +213,7 @@
 
 end
 
-instantiation set :: (random) random
+instantiation set :: (Random_Prep.random) Random_Prep.random
 begin
 
 context
@@ -227,12 +227,13 @@
     collapse (Random.select_weight
       [(1, Pair valterm_emptyset),
        (Code_Numeral.Suc i,
-        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+        Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
 
 lemma [code]:
   "random_aux_set i j =
     collapse (Random.select_weight [(1, Pair valterm_emptyset),
-      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+      (i, Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
 proof (induct i rule: natural.induct)
   case zero
   show ?case by (subst select_weight_drop_zero [symmetric])
@@ -259,6 +260,10 @@
 
 subsection \<open>Deriving random generators for datatypes\<close>
 
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
 ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
 ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
 
@@ -266,15 +271,15 @@
 subsection \<open>Code setup\<close>
 
 code_printing
-  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  constant Random_Prep.random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
   \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
   for this reason we use a distinguished target \<open>Quickcheck\<close>
   not spoiling the regular trusted code generation\<close>
 
 code_reserved Quickcheck Random_Generators
 
-hide_const (open) catch_match random collapse beyond random_fun_aux random_fun_lift
+hide_const (open) catch_match random collapse beyond (*random_fun_aux random_fun_lift*)
 
-hide_fact (open) collapse_def beyond_def random_fun_lift_def
+hide_fact (open) collapse_def beyond_def (*random_fun_lift_def*)
 
 end
diff -urN ./R /cygdrive/c/Isabelle2022/src/HOL/R
--- ./R	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/R	2023-05-30 16:51:07.314648500 +0900
@@ -0,0 +1,112 @@
+--- Enum.thy	2022-10-25 03:37:32.000000000 +0900
++++ Enum.thy	2023-05-30 15:37:49.000000000 +0900
+@@ -985,21 +1047,56 @@
+    | _ \<Rightarrow> a\<^sub>3)"
+ definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>1 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2)"
+ definition "x - y = x + (- y :: finite_3)"
++definition [simp]: "1 = a\<^sub>2"
+ definition "x * y = (case (x, y) of (a\<^sub>2, a\<^sub>2) \<Rightarrow> a\<^sub>2 | (a\<^sub>3, a\<^sub>3) \<Rightarrow> a\<^sub>2 | (a\<^sub>2, a\<^sub>3) \<Rightarrow> a\<^sub>3 | (a\<^sub>3, a\<^sub>2) \<Rightarrow> a\<^sub>3 | _ \<Rightarrow> a\<^sub>1)"
+ definition "inverse = (\<lambda>x :: finite_3. x)" 
+ definition "x div y = x * inverse (y :: finite_3)"
++
++
++instance
++proof(intro_classes)
++  fix a b c :: finite_3
++  show "a + b + c = a + (b + c)" 
++    by (cases a; cases b; cases c; simp add: plus_finite_3_def)
++  show "0 + a = a" by (cases a; simp add: plus_finite_3_def)
++  show "-a + a = 0" by (cases a; simp add: plus_finite_3_def uminus_finite_3_def)
++  show "a - b = a + -b" by (simp add: minus_finite_3_def)
++  show "a * b * c = a * (b * c)" by (cases a; cases b; cases c; simp add: times_finite_3_def)
++  show "a * b = b * a" by (cases a; cases b; simp add: times_finite_3_def)
++  show "1 * a = a" by (cases a; simp add: times_finite_3_def)
++  show "a + b = b + a" by (cases a; cases b; simp add: plus_finite_3_def)
++  show "(a + b) * c = a * c + b * c" 
++    by (cases a; cases b; cases c; simp add: plus_finite_3_def times_finite_3_def)
++  show "(0::finite_3) \<noteq> 1" by simp
++  show "a \<noteq> 0 \<Longrightarrow> inverse a * a = 1" 
++    by (cases a; simp add: times_finite_3_def inverse_finite_3_def)
++  show "a div b = a * inverse b" by (simp add: divide_finite_3_def)
++  show "inverse (0::finite_3) = 0" by (simp add: inverse_finite_3_def)
++qed
++  
++end
++
++instantiation finite_3 :: "{idom_abs_sgn, idom_modulo}" begin
+ definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
+ definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
+ definition "sgn = (\<lambda>x :: finite_3. x)"
++
+ instance
+-  by standard
+-    (subproofs
+-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+-        times_finite_3_def
+-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
+-        abs_finite_3_def sgn_finite_3_def
+-        less_finite_3_def
+-        split: finite_3.splits\<close>)
++proof(intro_classes)
++  fix a b :: finite_3
++  show "sgn a * \<bar>a\<bar> = a" by (cases a; simp add: abs_finite_3_def sgn_finite_3_def)
++  show "sgn (sgn a) = sgn a" by (simp add: sgn_finite_3_def)
++  show "\<bar>\<bar>a\<bar>\<bar> = \<bar>a\<bar>" by (cases a; simp add: abs_finite_3_def)
++  show "\<bar>(0::finite_3)\<bar> = 0" by (simp add: abs_finite_3_def)
++  show "sgn (0::finite_3) = 0" by (simp add: sgn_finite_3_def)
++  show "sgn (1::finite_3) = 1" by (simp add: sgn_finite_3_def)
++  show "sgn (- (1::finite_3)) = - 1" by (simp add: sgn_finite_3_def)
++  show "sgn (a * b) = sgn a * sgn b" by (simp add: sgn_finite_3_def)
++  show "a / b * b + a mod b = a" 
++    by (cases a; cases b; 
++        simp add: plus_finite_3_def times_finite_3_def modulo_finite_3_def 
++          divide_finite_3_def inverse_finite_3_def)
++qed
+ end
+ 
+ lemma two_finite_3 [simp]:
+--- MacLaurin.thy	2022-10-25 03:37:32.000000000 +0900
++++ MacLaurin.thy	2023-05-30 15:37:49.000000000 +0900
+@@ -343,25 +343,37 @@
+ lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
+   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
+ 
++lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
++proof(cases "even m")
++  case t: True
++    then show ?thesis by (simp add: sin_coeff_def sin_zero_iff)
++ next
++  case False
++    then show ?thesis using False 
++      by (auto simp add: sin_coeff_def elim: oddE simp del: of_nat_Suc) 
++qed
++
+ lemma Maclaurin_sin_expansion2:
+   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
+     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
+ proof (cases "n = 0 \<or> x = 0")
++  case True
++  then show ?thesis by auto
++next
+   case False
+   let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
+-  have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
++    have tex: "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
+       (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
+   proof (rule Maclaurin_all_lt)
+     show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
+            sin (x + 1/2 * real (Suc m) * pi)) (at x)"
+       by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
+   qed (use False in auto)
+-  then show ?thesis
++    from tex show ?thesis
+     apply (rule ex_forward, simp)
+     apply (rule sum.cong[OF refl])
+-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
+-    done
+-qed auto
++      by (simp add: sin_coeff_lemma)
++  qed
+ 
+ lemma Maclaurin_sin_expansion:
+   "\<exists>t. sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
diff -urN ./Random_Pred.thy /cygdrive/c/Isabelle2022/src/HOL/Random_Pred.thy
--- ./Random_Pred.thy	2023-05-30 11:49:57.822544100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Random_Pred.thy	2023-05-31 14:26:38.898682900 +0900
@@ -4,13 +4,13 @@
 section \<open>The Random-Predicate Monad\<close>
 
 theory Random_Pred
-imports Quickcheck_Random
+imports Random_Prep
 begin
 
 fun iter' :: "'a itself \<Rightarrow> natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
 where
   "iter' T nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter' T (nrandom - 1) sz seed')))"
 
 definition iter :: "natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
@@ -19,7 +19,7 @@
 
 lemma [code]:
   "iter nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter (nrandom - 1) sz seed')))"
    unfolding iter_def iter'.simps [of _ nrandom] ..
 
diff -urN ./Random_Prep.thy /cygdrive/c/Isabelle2022/src/HOL/Random_Prep.thy
--- ./Random_Prep.thy	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Random_Prep.thy	2023-05-31 14:31:21.495846600 +0900
@@ -0,0 +1,386 @@
+(*  Title:      HOL/Quickcheck_Random.thy
+    Author:     Florian Haftmann & Lukas Bulwahn, TU Muenchen
+*)
+
+section \<open>A simple counterexample generator performing random testing\<close>
+
+theory Random_Prep
+imports Random Code_Evaluation Enum
+begin
+
+(*setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>*)
+
+(*subsection \<open>Catching Match exceptions\<close>
+
+axiomatization catch_match :: "'a => 'a => 'a"
+
+code_printing
+  constant catch_match \<rightharpoonup> (Quickcheck) "((_) handle Match => _)"
+
+code_reserved Quickcheck Match*)
+
+subsection \<open>The \<open>random\<close> class\<close>
+
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
+subsection \<open>Fundamental and numeric types\<close>
+
+instantiation bool :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range 2 \<circ>\<rightarrow>
+    (\<lambda>k. Pair (if k = 0 then Code_Evaluation.valtermify False else Code_Evaluation.valtermify True))"
+
+instance ..
+
+end
+
+end
+
+instantiation itself :: (typerep) random
+begin
+
+definition
+  random_itself :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a itself \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where "random_itself _ = Pair (Code_Evaluation.valtermify TYPE('a))"
+
+instance ..
+
+end
+
+instantiation char :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random _ = Random.select (Enum.enum :: char list) \<circ>\<rightarrow> (\<lambda>c. Pair (c, \<lambda>u. Code_Evaluation.term_of c))"
+
+instance ..
+
+end
+
+end
+
+instantiation String.literal :: random
+begin
+
+definition
+  "random _ = Pair (STR '''', \<lambda>u. Code_Evaluation.term_of (STR ''''))"
+
+instance ..
+
+end
+
+instantiation nat :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_nat :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (nat \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_nat i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let n = nat_of_natural k
+     in (n, \<lambda>_. Code_Evaluation.term_of n)))"
+
+instance ..
+
+end
+
+end
+
+instantiation int :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then int (nat_of_natural (k - i)) else - (int (nat_of_natural (i - k))))
+     in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+instantiation natural :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_natural :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (natural \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_natural i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>n. Pair (n, \<lambda>_. Code_Evaluation.term_of n))"
+
+instance ..
+
+end
+
+end
+
+instantiation integer :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_integer :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (integer \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_integer i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then integer_of_natural (k - i) else - (integer_of_natural (i - k)))
+      in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+
+subsection \<open>Complex generators\<close>
+
+text \<open>Towards \<^typ>\<open>'a \<Rightarrow> 'b\<close>\<close>
+
+axiomatization random_fun_aux :: "typerep \<Rightarrow> typerep \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a \<Rightarrow> term)
+  \<Rightarrow> (Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> (Random.seed \<Rightarrow> Random.seed \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+definition random_fun_lift :: "(Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a::term_of \<Rightarrow> 'b::typerep) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where
+  "random_fun_lift f =
+    random_fun_aux TYPEREP('a) TYPEREP('b) (=) Code_Evaluation.term_of f Random.split_seed"
+
+instantiation "fun" :: ("{equal, term_of}", random) random
+begin
+
+definition
+  random_fun :: "natural \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+  where "random i = random_fun_lift (random i)"
+
+instance ..
+
+end
+
+(*text \<open>Towards type copies and datatypes\<close>
+
+context
+  includes state_combinator_syntax
+begin
+
+definition collapse :: "('a \<Rightarrow> ('a \<Rightarrow> 'b \<times> 'a) \<times> 'a) \<Rightarrow> 'a \<Rightarrow> 'b \<times> 'a"
+  where "collapse f = (f \<circ>\<rightarrow> id)"
+
+end
+
+definition beyond :: "natural \<Rightarrow> natural \<Rightarrow> natural"
+  where "beyond k l = (if l > k then l else 0)"
+
+lemma beyond_zero: "beyond k 0 = 0"
+  by (simp add: beyond_def)
+
+context
+  includes term_syntax
+begin
+
+definition [code_unfold]:
+  "valterm_emptyset = Code_Evaluation.valtermify ({} :: ('a :: typerep) set)"
+
+definition [code_unfold]:
+  "valtermify_insert x s = Code_Evaluation.valtermify insert {\<cdot>} (x :: ('a :: typerep * _)) {\<cdot>} s"
+
+end
+
+instantiation set :: (random) random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+
+fun random_aux_set
+where
+  "random_aux_set 0 j = collapse (Random.select_weight [(1, Pair valterm_emptyset)])"
+| "random_aux_set (Code_Numeral.Suc i) j =
+    collapse (Random.select_weight
+      [(1, Pair valterm_emptyset),
+       (Code_Numeral.Suc i,
+        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
+
+lemma [code]:
+  "random_aux_set i j =
+    collapse (Random.select_weight [(1, Pair valterm_emptyset),
+      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+proof (induct i rule: natural.induct)
+  case zero
+  show ?case by (subst select_weight_drop_zero [symmetric])
+    (simp add: random_aux_set.simps [simplified] less_natural_def)
+next
+  case (Suc i)
+  show ?case by (simp only: random_aux_set.simps(2) [of "i"] Suc_natural_minus_one)
+qed
+
+definition "random_set i = random_aux_set i i"
+
+instance ..
+
+end
+
+end
+
+lemma random_aux_rec:
+  fixes random_aux :: "natural \<Rightarrow> 'a"
+  assumes "random_aux 0 = rhs 0"
+    and "\<And>k. random_aux (Code_Numeral.Suc k) = rhs (Code_Numeral.Suc k)"
+  shows "random_aux k = rhs k"
+  using assms by (rule natural.induct)*)
+
+(*subsection \<open>Deriving random generators for datatypes\<close>
+
+ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
+ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
+
+
+subsection \<open>Code setup\<close>
+
+code_printing
+  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
+  for this reason we use a distinguished target \<open>Quickcheck\<close>
+  not spoiling the regular trusted code generation\<close>
+
+code_reserved Quickcheck Random_Generators*)
+
+hide_const (open) (*catch_match*) random (*collapse beyond*) random_fun_aux random_fun_lift
+
+hide_fact (open) (*collapse_def beyond_def*) random_fun_lift_def
+
+
+
+subsection \<open>Continuation passing style functions as plus monad\<close>
+
+type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
+
+definition cps_empty :: "'a cps"
+  where "cps_empty = (\<lambda>cont. None)"
+
+definition cps_single :: "'a \<Rightarrow> 'a cps"
+  where "cps_single v = (\<lambda>cont. cont v)"
+
+definition cps_bind :: "'a cps \<Rightarrow> ('a \<Rightarrow> 'b cps) \<Rightarrow> 'b cps"
+  where "cps_bind m f = (\<lambda>cont. m (\<lambda>a. (f a) cont))"
+
+definition cps_plus :: "'a cps \<Rightarrow> 'a cps \<Rightarrow> 'a cps"
+  where "cps_plus a b = (\<lambda>c. case a c of None \<Rightarrow> b c | Some x \<Rightarrow> Some x)"
+
+definition cps_if :: "bool \<Rightarrow> unit cps"
+  where "cps_if b = (if b then cps_single () else cps_empty)"
+
+definition cps_not :: "unit cps \<Rightarrow> unit cps"
+  where "cps_not n = (\<lambda>c. case n (\<lambda>u. Some []) of None \<Rightarrow> c () | Some _ \<Rightarrow> None)"
+
+type_synonym 'a pos_bound_cps =
+  "('a \<Rightarrow> (bool * term list) option) \<Rightarrow> natural \<Rightarrow> (bool * term list) option"
+
+definition pos_bound_cps_empty :: "'a pos_bound_cps"
+  where "pos_bound_cps_empty = (\<lambda>cont i. None)"
+
+definition pos_bound_cps_single :: "'a \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_single v = (\<lambda>cont i. cont v)"
+
+definition pos_bound_cps_bind :: "'a pos_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b pos_bound_cps) \<Rightarrow> 'b pos_bound_cps"
+  where "pos_bound_cps_bind m f = (\<lambda>cont i. if i = 0 then None else (m (\<lambda>a. (f a) cont i) (i - 1)))"
+
+definition pos_bound_cps_plus :: "'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_plus a b = (\<lambda>c i. case a c i of None \<Rightarrow> b c i | Some x \<Rightarrow> Some x)"
+
+definition pos_bound_cps_if :: "bool \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_if b = (if b then pos_bound_cps_single () else pos_bound_cps_empty)"
+
+datatype (plugins only: code extraction) (dead 'a) unknown =
+  Unknown | Known 'a
+
+datatype (plugins only: code extraction) (dead 'a) three_valued =
+  Unknown_value | Value 'a | No_value
+
+type_synonym 'a neg_bound_cps =
+  "('a unknown \<Rightarrow> term list three_valued) \<Rightarrow> natural \<Rightarrow> term list three_valued"
+
+definition neg_bound_cps_empty :: "'a neg_bound_cps"
+  where "neg_bound_cps_empty = (\<lambda>cont i. No_value)"
+
+definition neg_bound_cps_single :: "'a \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_single v = (\<lambda>cont i. cont (Known v))"
+
+definition neg_bound_cps_bind :: "'a neg_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b neg_bound_cps) \<Rightarrow> 'b neg_bound_cps"
+  where "neg_bound_cps_bind m f =
+    (\<lambda>cont i.
+      if i = 0 then cont Unknown
+      else m (\<lambda>a. case a of Unknown \<Rightarrow> cont Unknown | Known a' \<Rightarrow> f a' cont i) (i - 1))"
+
+definition neg_bound_cps_plus :: "'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_plus a b =
+    (\<lambda>c i.
+      case a c i of
+        No_value \<Rightarrow> b c i
+      | Value x \<Rightarrow> Value x
+      | Unknown_value \<Rightarrow>
+          (case b c i of
+            No_value \<Rightarrow> Unknown_value
+          | Value x \<Rightarrow> Value x
+          | Unknown_value \<Rightarrow> Unknown_value))"
+
+definition neg_bound_cps_if :: "bool \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_if b = (if b then neg_bound_cps_single () else neg_bound_cps_empty)"
+
+definition neg_bound_cps_not :: "unit pos_bound_cps \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Some (True, [])) i of None \<Rightarrow> c (Known ()) | Some _ \<Rightarrow> No_value)"
+
+definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+
+hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+
+hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
+  pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
+  pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
+  neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
+  neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
+  Unknown Known Unknown_value Value No_value
+
+class exhaustive = term_of +
+  fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+class full_exhaustive = term_of +
+  fixes full_exhaustive ::
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+
+
+end
diff -urN ./Rat.thy /cygdrive/c/Isabelle2022/src/HOL/Rat.thy
--- ./Rat.thy	2023-05-30 11:50:42.466861600 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Rat.thy	2023-05-31 14:26:38.902063300 +0900
@@ -1010,7 +1010,7 @@
   by (cases p) (simp add: quotient_of_Fract of_rat_rat)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1129,7 +1129,7 @@
   inverse_rat_inst.inverse_rat
   one_rat_inst.one_rat ord_rat_inst.less_rat
   ord_rat_inst.less_eq_rat plus_rat_inst.plus_rat times_rat_inst.times_rat
-  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat
+  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat*)
 
 
 subsection \<open>Float syntax\<close>
diff -urN ./Real.thy /cygdrive/c/Isabelle2022/src/HOL/Real.thy
--- ./Real.thy	2023-05-30 11:50:42.529129200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Real.thy	2023-05-31 14:26:38.904474700 +0900
@@ -1655,7 +1655,7 @@
       of_int_floor_le of_rat_of_int_eq real_less_eq_code)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1731,7 +1731,7 @@
 lemmas [nitpick_unfold] = inverse_real_inst.inverse_real one_real_inst.one_real
   ord_real_inst.less_real ord_real_inst.less_eq_real plus_real_inst.plus_real
   times_real_inst.times_real uminus_real_inst.uminus_real
-  zero_real_inst.zero_real
+  zero_real_inst.zero_real*)
 
 
 subsection \<open>Setup for SMT\<close>
diff -urN ./String.thy /cygdrive/c/Isabelle2022/src/HOL/String.thy
--- ./String.thy	2023-05-30 11:50:00.046418000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/String.thy	2023-05-31 17:18:55.605821500 +0900
@@ -40,11 +40,21 @@
 
 lemma (in comm_semiring_1) of_nat_of_char:
   \<open>of_nat (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(* this is more explicit:
+ by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_nat_add of_nat_mult of_nat_of_bool of_nat_numeral of_nat_0)
+*)
 
 lemma (in comm_ring_1) of_int_of_char:
   \<open>of_int (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(*
+  by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_int_add of_int_mult of_int_of_bool of_int_numeral of_int_0)
+*)
 
 lemma nat_of_char [simp]:
   \<open>nat (of_char c) = of_char c\<close>
@@ -698,9 +708,9 @@
 
 lemma [code]:
   \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
-    [foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
+    [foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
 proof -
-  have \<open>foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
+  have \<open>foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
     by simp
   moreover have \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
     [of_char (Char b0 b1 b2 b3 b4 b5 b6 False)] + s\<close>
diff -urN ./String.thy~ /cygdrive/c/Isabelle2022/src/HOL/String.thy~
--- ./String.thy~	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/String.thy~	2023-05-31 16:19:40.728405900 +0900
@@ -0,0 +1,866 @@
+(* Author: Tobias Nipkow, Florian Haftmann, TU Muenchen *)
+
+section \<open>Character and string types\<close>
+
+theory String
+imports Enum Bit_Operations Code_Numeral
+begin
+
+subsection \<open>Strings as list of bytes\<close>
+
+text \<open>
+  When modelling strings, we follow the approach given
+  in \<^url>\<open>https://utf8everywhere.org/\<close>:
+
+  \<^item> Strings are a list of bytes (8 bit).
+
+  \<^item> Byte values from 0 to 127 are US-ASCII.
+
+  \<^item> Byte values from 128 to 255 are uninterpreted blobs.
+\<close>
+
+subsubsection \<open>Bytes as datatype\<close>
+
+datatype char =
+  Char (digit0: bool) (digit1: bool) (digit2: bool) (digit3: bool)
+       (digit4: bool) (digit5: bool) (digit6: bool) (digit7: bool)
+
+context comm_semiring_1
+begin
+
+definition of_char :: \<open>char \<Rightarrow> 'a\<close>
+  where \<open>of_char c = horner_sum of_bool 2 [digit0 c, digit1 c, digit2 c, digit3 c, digit4 c, digit5 c, digit6 c, digit7 c]\<close>
+
+lemma of_char_Char [simp]:
+  \<open>of_char (Char b0 b1 b2 b3 b4 b5 b6 b7) =
+    horner_sum of_bool 2 [b0, b1, b2, b3, b4, b5, b6, b7]\<close>
+  by (simp add: of_char_def)
+
+end
+
+lemma (in comm_semiring_1) of_nat_of_char:
+  \<open>of_nat (of_char c) = of_char c\<close>
+  by (cases c) simp
+
+lemma (in comm_ring_1) of_int_of_char:
+  \<open>of_int (of_char c) = of_char c\<close>
+  by (cases c) simp
+
+lemma nat_of_char [simp]:
+  \<open>nat (of_char c) = of_char c\<close>
+  by (cases c) (simp only: of_char_Char nat_horner_sum)
+
+
+context unique_euclidean_semiring_with_bit_operations
+begin
+
+definition char_of :: \<open>'a \<Rightarrow> char\<close>
+  where \<open>char_of n = Char (bit n 0) (bit n 1) (bit n 2) (bit n 3) (bit n 4) (bit n 5) (bit n 6) (bit n 7)\<close>
+
+lemma char_of_take_bit_eq:
+  \<open>char_of (take_bit n m) = char_of m\<close> if \<open>n \<ge> 8\<close>
+  using that by (simp add: char_of_def bit_take_bit_iff)
+
+lemma char_of_char [simp]:
+  \<open>char_of (of_char c) = c\<close>
+  by (simp only: of_char_def char_of_def bit_horner_sum_bit_iff) simp
+
+lemma char_of_comp_of_char [simp]:
+  "char_of \<circ> of_char = id"
+  by (simp add: fun_eq_iff)
+
+lemma inj_of_char:
+  \<open>inj of_char\<close>
+proof (rule injI)
+  fix c d
+  assume "of_char c = of_char d"
+  then have "char_of (of_char c) = char_of (of_char d)"
+    by simp
+  then show "c = d"
+    by simp
+qed
+
+lemma of_char_eqI:
+  \<open>c = d\<close> if \<open>of_char c = of_char d\<close>
+  using that inj_of_char by (simp add: inj_eq)
+
+lemma of_char_eq_iff [simp]:
+  \<open>of_char c = of_char d \<longleftrightarrow> c = d\<close>
+  by (auto intro: of_char_eqI)
+
+lemma of_char_of [simp]:
+  \<open>of_char (char_of a) = a mod 256\<close>
+proof -
+  have \<open>[0..<8] = [0, Suc 0, 2, 3, 4, 5, 6, 7 :: nat]\<close>
+    by (simp add: upt_eq_Cons_conv)
+  then have \<open>[bit a 0, bit a 1, bit a 2, bit a 3, bit a 4, bit a 5, bit a 6, bit a 7] = map (bit a) [0..<8]\<close>
+    by simp
+  then have \<open>of_char (char_of a) = take_bit 8 a\<close>
+    by (simp only: char_of_def of_char_def char.sel horner_sum_bit_eq_take_bit)
+  then show ?thesis
+    by (simp add: take_bit_eq_mod)
+qed
+
+lemma char_of_mod_256 [simp]:
+  \<open>char_of (n mod 256) = char_of n\<close>
+  by (rule of_char_eqI) simp
+
+lemma of_char_mod_256 [simp]:
+  \<open>of_char c mod 256 = of_char c\<close>
+proof -
+  have \<open>of_char (char_of (of_char c)) mod 256 = of_char (char_of (of_char c))\<close>
+    by (simp only: of_char_of) simp
+  then show ?thesis
+    by simp
+qed
+
+lemma char_of_quasi_inj [simp]:
+  \<open>char_of m = char_of n \<longleftrightarrow> m mod 256 = n mod 256\<close> (is \<open>?P \<longleftrightarrow> ?Q\<close>)
+proof
+  assume ?Q
+  then show ?P
+    by (auto intro: of_char_eqI)
+next
+  assume ?P
+  then have \<open>of_char (char_of m) = of_char (char_of n)\<close>
+    by simp
+  then show ?Q
+    by simp
+qed
+
+lemma char_of_eq_iff:
+  \<open>char_of n = c \<longleftrightarrow> take_bit 8 n = of_char c\<close>
+  by (auto intro: of_char_eqI simp add: take_bit_eq_mod)
+
+lemma char_of_nat [simp]:
+  \<open>char_of (of_nat n) = char_of n\<close>
+  by (simp add: char_of_def String.char_of_def drop_bit_of_nat bit_simps possible_bit_def)
+
+end
+
+lemma inj_on_char_of_nat [simp]:
+  "inj_on char_of {0::nat..<256}"
+  by (rule inj_onI) simp
+
+lemma nat_of_char_less_256 [simp]:
+  "of_char c < (256 :: nat)"
+proof -
+  have "of_char c mod (256 :: nat) < 256"
+    by arith
+  then show ?thesis by simp
+qed
+
+lemma range_nat_of_char:
+  "range of_char = {0::nat..<256}"
+proof (rule; rule)
+  fix n :: nat
+  assume "n \<in> range of_char"
+  then show "n \<in> {0..<256}"
+    by auto
+next
+  fix n :: nat
+  assume "n \<in> {0..<256}"
+  then have "n = of_char (char_of n)"
+    by simp
+  then show "n \<in> range of_char"
+    by (rule range_eqI)
+qed
+
+lemma UNIV_char_of_nat:
+  "UNIV = char_of ` {0::nat..<256}"
+proof -
+  have "range (of_char :: char \<Rightarrow> nat) = of_char ` char_of ` {0::nat..<256}"
+    by (auto simp add: range_nat_of_char intro!: image_eqI)
+  with inj_of_char [where ?'a = nat] show ?thesis
+    by (simp add: inj_image_eq_iff)
+qed
+
+lemma card_UNIV_char:
+  "card (UNIV :: char set) = 256"
+  by (auto simp add: UNIV_char_of_nat card_image)
+
+context
+  includes lifting_syntax integer.lifting natural.lifting
+begin
+
+lemma [transfer_rule]:
+  \<open>(pcr_integer ===> (=)) char_of char_of\<close>
+  by (unfold char_of_def) transfer_prover
+
+lemma [transfer_rule]:
+  \<open>((=) ===> pcr_integer) of_char of_char\<close>
+  by (unfold of_char_def) transfer_prover
+
+lemma [transfer_rule]:
+  \<open>(pcr_natural ===> (=)) char_of char_of\<close>
+  by (unfold char_of_def) transfer_prover
+
+lemma [transfer_rule]:
+  \<open>((=) ===> pcr_natural) of_char of_char\<close>
+  by (unfold of_char_def) transfer_prover
+
+end
+
+lifting_update integer.lifting
+lifting_forget integer.lifting
+
+lifting_update natural.lifting
+lifting_forget natural.lifting
+
+lemma size_char_eq_0 [simp, code]:
+  \<open>size c = 0\<close> for c :: char
+  by (cases c) simp
+
+lemma size'_char_eq_0 [simp, code]:
+  \<open>size_char c = 0\<close>
+  by (cases c) simp
+
+syntax
+  "_Char" :: "str_position \<Rightarrow> char"    ("CHR _")
+  "_Char_ord" :: "num_const \<Rightarrow> char"   ("CHR _")
+
+type_synonym string = "char list"
+
+syntax
+  "_String" :: "str_position \<Rightarrow> string"    ("_")
+
+ML_file \<open>Tools/string_syntax.ML\<close>
+
+instantiation char :: enum
+begin
+
+definition
+  "Enum.enum = [
+    CHR 0x00, CHR 0x01, CHR 0x02, CHR 0x03,
+    CHR 0x04, CHR 0x05, CHR 0x06, CHR 0x07,
+    CHR 0x08, CHR 0x09, CHR ''\<newline>'', CHR 0x0B,
+    CHR 0x0C, CHR 0x0D, CHR 0x0E, CHR 0x0F,
+    CHR 0x10, CHR 0x11, CHR 0x12, CHR 0x13,
+    CHR 0x14, CHR 0x15, CHR 0x16, CHR 0x17,
+    CHR 0x18, CHR 0x19, CHR 0x1A, CHR 0x1B,
+    CHR 0x1C, CHR 0x1D, CHR 0x1E, CHR 0x1F,
+    CHR '' '', CHR ''!'', CHR 0x22, CHR ''#'',
+    CHR ''$'', CHR ''%'', CHR ''&'', CHR 0x27,
+    CHR ''('', CHR '')'', CHR ''*'', CHR ''+'',
+    CHR '','', CHR ''-'', CHR ''.'', CHR ''/'',
+    CHR ''0'', CHR ''1'', CHR ''2'', CHR ''3'',
+    CHR ''4'', CHR ''5'', CHR ''6'', CHR ''7'',
+    CHR ''8'', CHR ''9'', CHR '':'', CHR '';'',
+    CHR ''<'', CHR ''='', CHR ''>'', CHR ''?'',
+    CHR ''@'', CHR ''A'', CHR ''B'', CHR ''C'',
+    CHR ''D'', CHR ''E'', CHR ''F'', CHR ''G'',
+    CHR ''H'', CHR ''I'', CHR ''J'', CHR ''K'',
+    CHR ''L'', CHR ''M'', CHR ''N'', CHR ''O'',
+    CHR ''P'', CHR ''Q'', CHR ''R'', CHR ''S'',
+    CHR ''T'', CHR ''U'', CHR ''V'', CHR ''W'',
+    CHR ''X'', CHR ''Y'', CHR ''Z'', CHR ''['',
+    CHR 0x5C, CHR '']'', CHR ''^'', CHR ''_'',
+    CHR 0x60, CHR ''a'', CHR ''b'', CHR ''c'',
+    CHR ''d'', CHR ''e'', CHR ''f'', CHR ''g'',
+    CHR ''h'', CHR ''i'', CHR ''j'', CHR ''k'',
+    CHR ''l'', CHR ''m'', CHR ''n'', CHR ''o'',
+    CHR ''p'', CHR ''q'', CHR ''r'', CHR ''s'',
+    CHR ''t'', CHR ''u'', CHR ''v'', CHR ''w'',
+    CHR ''x'', CHR ''y'', CHR ''z'', CHR ''{'',
+    CHR ''|'', CHR ''}'', CHR ''~'', CHR 0x7F,
+    CHR 0x80, CHR 0x81, CHR 0x82, CHR 0x83,
+    CHR 0x84, CHR 0x85, CHR 0x86, CHR 0x87,
+    CHR 0x88, CHR 0x89, CHR 0x8A, CHR 0x8B,
+    CHR 0x8C, CHR 0x8D, CHR 0x8E, CHR 0x8F,
+    CHR 0x90, CHR 0x91, CHR 0x92, CHR 0x93,
+    CHR 0x94, CHR 0x95, CHR 0x96, CHR 0x97,
+    CHR 0x98, CHR 0x99, CHR 0x9A, CHR 0x9B,
+    CHR 0x9C, CHR 0x9D, CHR 0x9E, CHR 0x9F,
+    CHR 0xA0, CHR 0xA1, CHR 0xA2, CHR 0xA3,
+    CHR 0xA4, CHR 0xA5, CHR 0xA6, CHR 0xA7,
+    CHR 0xA8, CHR 0xA9, CHR 0xAA, CHR 0xAB,
+    CHR 0xAC, CHR 0xAD, CHR 0xAE, CHR 0xAF,
+    CHR 0xB0, CHR 0xB1, CHR 0xB2, CHR 0xB3,
+    CHR 0xB4, CHR 0xB5, CHR 0xB6, CHR 0xB7,
+    CHR 0xB8, CHR 0xB9, CHR 0xBA, CHR 0xBB,
+    CHR 0xBC, CHR 0xBD, CHR 0xBE, CHR 0xBF,
+    CHR 0xC0, CHR 0xC1, CHR 0xC2, CHR 0xC3,
+    CHR 0xC4, CHR 0xC5, CHR 0xC6, CHR 0xC7,
+    CHR 0xC8, CHR 0xC9, CHR 0xCA, CHR 0xCB,
+    CHR 0xCC, CHR 0xCD, CHR 0xCE, CHR 0xCF,
+    CHR 0xD0, CHR 0xD1, CHR 0xD2, CHR 0xD3,
+    CHR 0xD4, CHR 0xD5, CHR 0xD6, CHR 0xD7,
+    CHR 0xD8, CHR 0xD9, CHR 0xDA, CHR 0xDB,
+    CHR 0xDC, CHR 0xDD, CHR 0xDE, CHR 0xDF,
+    CHR 0xE0, CHR 0xE1, CHR 0xE2, CHR 0xE3,
+    CHR 0xE4, CHR 0xE5, CHR 0xE6, CHR 0xE7,
+    CHR 0xE8, CHR 0xE9, CHR 0xEA, CHR 0xEB,
+    CHR 0xEC, CHR 0xED, CHR 0xEE, CHR 0xEF,
+    CHR 0xF0, CHR 0xF1, CHR 0xF2, CHR 0xF3,
+    CHR 0xF4, CHR 0xF5, CHR 0xF6, CHR 0xF7,
+    CHR 0xF8, CHR 0xF9, CHR 0xFA, CHR 0xFB,
+    CHR 0xFC, CHR 0xFD, CHR 0xFE, CHR 0xFF]"
+
+definition
+  "Enum.enum_all P \<longleftrightarrow> list_all P (Enum.enum :: char list)"
+
+definition
+  "Enum.enum_ex P \<longleftrightarrow> list_ex P (Enum.enum :: char list)"
+
+lemma enum_char_unfold:
+  "Enum.enum = map char_of [0..<256]"
+proof -
+  have "map (of_char :: char \<Rightarrow> nat) Enum.enum = [0..<256]"
+    by (simp add: enum_char_def of_char_def upt_conv_Cons_Cons numeral_2_eq_2 [symmetric])
+  then have "map char_of (map (of_char :: char \<Rightarrow> nat) Enum.enum) =
+    map char_of [0..<256]"
+    by simp
+  then show ?thesis
+    by simp
+qed
+
+instance proof
+  show UNIV: "UNIV = set (Enum.enum :: char list)"
+    by (simp add: enum_char_unfold UNIV_char_of_nat atLeast0LessThan)
+  show "distinct (Enum.enum :: char list)"
+    by (auto simp add: enum_char_unfold distinct_map intro: inj_onI)
+  show "\<And>P. Enum.enum_all P \<longleftrightarrow> Ball (UNIV :: char set) P"
+    by (simp add: UNIV enum_all_char_def list_all_iff)
+  show "\<And>P. Enum.enum_ex P \<longleftrightarrow> Bex (UNIV :: char set) P"
+    by (simp add: UNIV enum_ex_char_def list_ex_iff)
+qed
+
+end
+
+lemma linorder_char:
+  "class.linorder (\<lambda>c d. of_char c \<le> (of_char d :: nat)) (\<lambda>c d. of_char c < (of_char d :: nat))"
+  by standard auto
+
+text \<open>Optimized version for execution\<close>
+
+definition char_of_integer :: "integer \<Rightarrow> char"
+  where [code_abbrev]: "char_of_integer = char_of"
+
+definition integer_of_char :: "char \<Rightarrow> integer"
+  where [code_abbrev]: "integer_of_char = of_char"
+
+lemma char_of_integer_code [code]:
+  "char_of_integer k = (let
+     (q0, b0) = bit_cut_integer k;
+     (q1, b1) = bit_cut_integer q0;
+     (q2, b2) = bit_cut_integer q1;
+     (q3, b3) = bit_cut_integer q2;
+     (q4, b4) = bit_cut_integer q3;
+     (q5, b5) = bit_cut_integer q4;
+     (q6, b6) = bit_cut_integer q5;
+     (_, b7) = bit_cut_integer q6
+    in Char b0 b1 b2 b3 b4 b5 b6 b7)"
+  by (simp add: bit_cut_integer_def char_of_integer_def char_of_def div_mult2_numeral_eq bit_iff_odd_drop_bit drop_bit_eq_div)
+
+lemma integer_of_char_code [code]:
+  "integer_of_char (Char b0 b1 b2 b3 b4 b5 b6 b7) =
+    ((((((of_bool b7 * 2 + of_bool b6) * 2 +
+      of_bool b5) * 2 + of_bool b4) * 2 +
+        of_bool b3) * 2 + of_bool b2) * 2 +
+          of_bool b1) * 2 + of_bool b0"
+  by (simp add: integer_of_char_def of_char_def)
+
+
+subsection \<open>Strings as dedicated type for target language code generation\<close>
+
+subsubsection \<open>Logical specification\<close>
+
+context
+begin
+
+qualified definition ascii_of :: "char \<Rightarrow> char"
+  where "ascii_of c = Char (digit0 c) (digit1 c) (digit2 c) (digit3 c) (digit4 c) (digit5 c) (digit6 c) False"
+
+qualified lemma ascii_of_Char [simp]:
+  "ascii_of (Char b0 b1 b2 b3 b4 b5 b6 b7) = Char b0 b1 b2 b3 b4 b5 b6 False"
+  by (simp add: ascii_of_def)
+
+qualified lemma digit0_ascii_of_iff [simp]:
+  "digit0 (String.ascii_of c) \<longleftrightarrow> digit0 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma digit1_ascii_of_iff [simp]:
+  "digit1 (String.ascii_of c) \<longleftrightarrow> digit1 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma digit2_ascii_of_iff [simp]:
+  "digit2 (String.ascii_of c) \<longleftrightarrow> digit2 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma digit3_ascii_of_iff [simp]:
+  "digit3 (String.ascii_of c) \<longleftrightarrow> digit3 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma digit4_ascii_of_iff [simp]:
+  "digit4 (String.ascii_of c) \<longleftrightarrow> digit4 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma digit5_ascii_of_iff [simp]:
+  "digit5 (String.ascii_of c) \<longleftrightarrow> digit5 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma digit6_ascii_of_iff [simp]:
+  "digit6 (String.ascii_of c) \<longleftrightarrow> digit6 c"
+  by (simp add: String.ascii_of_def)
+
+qualified lemma not_digit7_ascii_of [simp]:
+  "\<not> digit7 (ascii_of c)"
+  by (simp add: ascii_of_def)
+
+qualified lemma ascii_of_idem:
+  "ascii_of c = c" if "\<not> digit7 c"
+  using that by (cases c) simp
+
+qualified typedef literal = "{cs. \<forall>c\<in>set cs. \<not> digit7 c}"
+  morphisms explode Abs_literal
+proof
+  show "[] \<in> {cs. \<forall>c\<in>set cs. \<not> digit7 c}"
+    by simp
+qed
+
+qualified setup_lifting type_definition_literal
+
+qualified lift_definition implode :: "string \<Rightarrow> literal"
+  is "map ascii_of"
+  by auto
+
+qualified lemma implode_explode_eq [simp]:
+  "String.implode (String.explode s) = s"
+proof transfer
+  fix cs
+  show "map ascii_of cs = cs" if "\<forall>c\<in>set cs. \<not> digit7 c"
+    using that
+      by (induction cs) (simp_all add: ascii_of_idem)
+qed
+
+qualified lemma explode_implode_eq [simp]:
+  "String.explode (String.implode cs) = map ascii_of cs"
+  by transfer rule
+
+end
+
+context unique_euclidean_semiring_with_bit_operations
+begin
+
+context
+begin
+
+qualified lemma char_of_ascii_of [simp]:
+  \<open>of_char (String.ascii_of c) = take_bit 7 (of_char c)\<close>
+  by (cases c) (simp only: String.ascii_of_Char of_char_Char take_bit_horner_sum_bit_eq, simp)
+
+qualified lemma ascii_of_char_of:
+  \<open>String.ascii_of (char_of a) = char_of (take_bit 7 a)\<close>
+  by (simp add: char_of_def bit_simps)
+
+end
+
+end
+
+
+subsubsection \<open>Syntactic representation\<close>
+
+text \<open>
+  Logical ground representations for literals are:
+
+  \<^enum> \<open>0\<close> for the empty literal;
+
+  \<^enum> \<open>Literal b0 \<dots> b6 s\<close> for a literal starting with one
+    character and continued by another literal.
+
+  Syntactic representations for literals are:
+
+  \<^enum> Printable text as string prefixed with \<open>STR\<close>;
+
+  \<^enum> A single ascii value as numerical hexadecimal value prefixed with \<open>STR\<close>.
+\<close>
+
+instantiation String.literal :: zero
+begin
+
+context
+begin
+
+qualified lift_definition zero_literal :: String.literal
+  is Nil
+  by simp
+
+instance ..
+
+end
+
+end
+
+context
+begin
+
+qualified abbreviation (output) empty_literal :: String.literal
+  where "empty_literal \<equiv> 0"
+
+qualified lift_definition Literal :: "bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> String.literal \<Rightarrow> String.literal"
+  is "\<lambda>b0 b1 b2 b3 b4 b5 b6 cs. Char b0 b1 b2 b3 b4 b5 b6 False # cs"
+  by auto
+
+qualified lemma Literal_eq_iff [simp]:
+  "Literal b0 b1 b2 b3 b4 b5 b6 s = Literal c0 c1 c2 c3 c4 c5 c6 t
+     \<longleftrightarrow> (b0 \<longleftrightarrow> c0) \<and> (b1 \<longleftrightarrow> c1) \<and> (b2 \<longleftrightarrow> c2) \<and> (b3 \<longleftrightarrow> c3)
+         \<and> (b4 \<longleftrightarrow> c4) \<and> (b5 \<longleftrightarrow> c5) \<and> (b6 \<longleftrightarrow> c6) \<and> s = t"
+  by transfer simp
+
+qualified lemma empty_neq_Literal [simp]:
+  "empty_literal \<noteq> Literal b0 b1 b2 b3 b4 b5 b6 s"
+  by transfer simp
+
+qualified lemma Literal_neq_empty [simp]:
+  "Literal b0 b1 b2 b3 b4 b5 b6 s \<noteq> empty_literal"
+  by transfer simp
+
+end
+
+code_datatype "0 :: String.literal" String.Literal
+
+syntax
+  "_Literal" :: "str_position \<Rightarrow> String.literal"   ("STR _")
+  "_Ascii" :: "num_const \<Rightarrow> String.literal"        ("STR _")
+
+ML_file \<open>Tools/literal.ML\<close>
+
+
+subsubsection \<open>Operations\<close>
+
+instantiation String.literal :: plus
+begin
+
+context
+begin
+
+qualified lift_definition plus_literal :: "String.literal \<Rightarrow> String.literal \<Rightarrow> String.literal"
+  is "(@)"
+  by auto
+
+instance ..
+
+end
+
+end
+
+instance String.literal :: monoid_add
+  by (standard; transfer) simp_all
+
+instantiation String.literal :: size
+begin
+
+context
+  includes literal.lifting
+begin
+
+lift_definition size_literal :: "String.literal \<Rightarrow> nat"
+  is length .
+
+end
+
+instance ..
+
+end
+
+instantiation String.literal :: equal
+begin
+
+context
+begin
+
+qualified lift_definition equal_literal :: "String.literal \<Rightarrow> String.literal \<Rightarrow> bool"
+  is HOL.equal .
+
+instance
+  by (standard; transfer) (simp add: equal)
+
+end
+
+end
+
+instantiation String.literal :: linorder
+begin
+
+context
+begin
+
+qualified lift_definition less_eq_literal :: "String.literal \<Rightarrow> String.literal \<Rightarrow> bool"
+  is "ord.lexordp_eq (\<lambda>c d. of_char c < (of_char d :: nat))"
+  .
+
+qualified lift_definition less_literal :: "String.literal \<Rightarrow> String.literal \<Rightarrow> bool"
+  is "ord.lexordp (\<lambda>c d. of_char c < (of_char d :: nat))"
+  .
+
+instance proof -
+  from linorder_char interpret linorder "ord.lexordp_eq (\<lambda>c d. of_char c < (of_char d :: nat))"
+    "ord.lexordp (\<lambda>c d. of_char c < (of_char d :: nat)) :: string \<Rightarrow> string \<Rightarrow> bool"
+    by (rule linorder.lexordp_linorder)
+  show "PROP ?thesis"
+    by (standard; transfer) (simp_all add: less_le_not_le linear)
+qed
+
+end
+
+end
+
+lemma infinite_literal:
+  "infinite (UNIV :: String.literal set)"
+proof -
+  define S where "S = range (\<lambda>n. replicate n CHR ''A'')"
+  have "inj_on String.implode S"
+  proof (rule inj_onI)
+    fix cs ds
+    assume "String.implode cs = String.implode ds"
+    then have "String.explode (String.implode cs) = String.explode (String.implode ds)"
+      by simp
+    moreover assume "cs \<in> S" and "ds \<in> S"
+    ultimately show "cs = ds"
+      by (auto simp add: S_def)
+  qed
+  moreover have "infinite S"
+    by (auto simp add: S_def dest: finite_range_imageI [of _ length])
+  ultimately have "infinite (String.implode ` S)"
+    by (simp add: finite_image_iff)
+  then show ?thesis
+    by (auto intro: finite_subset)
+qed
+
+
+subsubsection \<open>Executable conversions\<close>
+
+context
+begin
+
+qualified lift_definition asciis_of_literal :: "String.literal \<Rightarrow> integer list"
+  is "map of_char"
+  .
+
+qualified lemma asciis_of_zero [simp, code]:
+  "asciis_of_literal 0 = []"
+  by transfer simp
+
+qualified lemma asciis_of_Literal [simp, code]:
+  "asciis_of_literal (String.Literal b0 b1 b2 b3 b4 b5 b6 s) =
+    of_char (Char b0 b1 b2 b3 b4 b5 b6 False) # asciis_of_literal s "
+  by transfer simp
+
+qualified lift_definition literal_of_asciis :: "integer list \<Rightarrow> String.literal"
+  is "map (String.ascii_of \<circ> char_of)"
+  by auto
+
+qualified lemma literal_of_asciis_Nil [simp, code]:
+  "literal_of_asciis [] = 0"
+  by transfer simp
+
+qualified lemma literal_of_asciis_Cons [simp, code]:
+  "literal_of_asciis (k # ks) = (case char_of k
+    of Char b0 b1 b2 b3 b4 b5 b6 b7 \<Rightarrow> String.Literal b0 b1 b2 b3 b4 b5 b6 (literal_of_asciis ks))"
+  by (simp add: char_of_def) (transfer, simp add: char_of_def)
+
+qualified lemma literal_of_asciis_of_literal [simp]:
+  "literal_of_asciis (asciis_of_literal s) = s"
+proof transfer
+  fix cs
+  assume "\<forall>c\<in>set cs. \<not> digit7 c"
+  then show "map (String.ascii_of \<circ> char_of) (map of_char cs) = cs"
+    by (induction cs) (simp_all add: String.ascii_of_idem)
+qed
+
+qualified lemma explode_code [code]:
+  "String.explode s = map char_of (asciis_of_literal s)"
+  by transfer simp
+
+qualified lemma implode_code [code]:
+  "String.implode cs = literal_of_asciis (map of_char cs)"
+  by transfer simp
+
+qualified lemma equal_literal [code]:
+  "HOL.equal (String.Literal b0 b1 b2 b3 b4 b5 b6 s)
+    (String.Literal a0 a1 a2 a3 a4 a5 a6 r)
+    \<longleftrightarrow> (b0 \<longleftrightarrow> a0) \<and> (b1 \<longleftrightarrow> a1) \<and> (b2 \<longleftrightarrow> a2) \<and> (b3 \<longleftrightarrow> a3)
+      \<and> (b4 \<longleftrightarrow> a4) \<and> (b5 \<longleftrightarrow> a5) \<and> (b6 \<longleftrightarrow> a6) \<and> (s = r)"
+  by (simp add: equal)
+
+end
+
+
+subsubsection \<open>Technical code generation setup\<close>
+
+text \<open>Alternative constructor for generated computations\<close>
+
+context
+begin
+
+qualified definition Literal' :: "bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> String.literal \<Rightarrow> String.literal"
+  where [simp]: "Literal' = String.Literal"
+
+lemma [code]:
+  \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
+    [foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
+proof -
+  have \<open>foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
+    by simp
+  moreover have \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
+    [of_char (Char b0 b1 b2 b3 b4 b5 b6 False)] + s\<close>
+    by (unfold Literal'_def) (transfer, simp only: list.simps comp_apply char_of_char, simp)
+  ultimately show ?thesis
+    by simp
+qed
+
+lemma [code_computation_unfold]:
+  "String.Literal = Literal'"
+  by simp
+
+end
+
+code_reserved SML string String Char Str_Literal
+code_reserved OCaml string String Char Str_Literal
+code_reserved Haskell Prelude
+code_reserved Scala string
+
+code_identifier
+  code_module String \<rightharpoonup>
+    (SML) Str and (OCaml) Str and (Haskell) Str and (Scala) Str
+
+code_printing
+  type_constructor String.literal \<rightharpoonup>
+    (SML) "string"
+    and (OCaml) "string"
+    and (Haskell) "String"
+    and (Scala) "String"
+| constant "STR ''''" \<rightharpoonup>
+    (SML) "\"\""
+    and (OCaml) "\"\""
+    and (Haskell) "\"\""
+    and (Scala) "\"\""
+
+setup \<open>
+  fold Literal.add_code ["SML", "OCaml", "Haskell", "Scala"]
+\<close>
+
+code_printing
+  code_module "Str_Literal" \<rightharpoonup>
+    (SML) \<open>structure Str_Literal =
+struct
+
+fun map f [] = []
+  | map f (x :: xs) = f x :: map f xs; (* deliberate clone not relying on List._ module *)
+
+fun check_ascii (k : IntInf.int) =
+  if 0 <= k andalso k < 128
+  then k
+  else raise Fail "Non-ASCII character in literal";
+
+val char_of_ascii = Char.chr o IntInf.toInt o check_ascii;
+
+val ascii_of_char = check_ascii o IntInf.fromInt o Char.ord;
+
+val literal_of_asciis = String.implode o map char_of_ascii;
+
+val asciis_of_literal = map ascii_of_char o String.explode;
+
+end;\<close> for constant String.literal_of_asciis String.asciis_of_literal
+    and (OCaml) \<open>module Str_Literal =
+struct
+
+let implode f xs =
+  let rec length xs = match xs with
+      [] -> 0
+    | x :: xs -> 1 + length xs in
+  let rec nth xs n = match xs with
+    (x :: xs) -> if n <= 0 then x else nth xs (n - 1)
+  in String.init (length xs) (fun n -> f (nth xs n));;
+
+let explode f s =
+  let rec map_range f n =
+    if n <= 0 then [] else map_range f (n - 1) @ [f n]
+  in map_range (fun n -> f (String.get s n)) (String.length s);;
+
+let z_128 = Z.of_int 128;;
+
+let check_ascii (k : Z.t) =
+  if Z.leq Z.zero k && Z.lt k z_128
+  then k
+  else failwith "Non-ASCII character in literal";;
+
+let char_of_ascii k = Char.chr (Z.to_int (check_ascii k));;
+
+let ascii_of_char c = check_ascii (Z.of_int (Char.code c));;
+
+let literal_of_asciis ks = implode char_of_ascii ks;;
+
+let asciis_of_literal s = explode ascii_of_char s;;
+
+end;;\<close> for constant String.literal_of_asciis String.asciis_of_literal
+| constant "(+) :: String.literal \<Rightarrow> String.literal \<Rightarrow> String.literal" \<rightharpoonup>
+    (SML) infixl 18 "^"
+    and (OCaml) infixr 6 "^"
+    and (Haskell) infixr 5 "++"
+    and (Scala) infixl 7 "+"
+| constant String.literal_of_asciis \<rightharpoonup>
+    (SML) "Str'_Literal.literal'_of'_asciis"
+    and (OCaml) "Str'_Literal.literal'_of'_asciis"
+    and (Haskell) "map/ (let chr k | (0 <= k && k < 128) = Prelude.toEnum k :: Prelude.Char in chr . Prelude.fromInteger)"
+    and (Scala) "\"\"/ ++/ _.map((k: BigInt) => if (BigInt(0) <= k && k < BigInt(128)) k.charValue else sys.error(\"Non-ASCII character in literal\"))"
+| constant String.asciis_of_literal \<rightharpoonup>
+    (SML) "Str'_Literal.asciis'_of'_literal"
+    and (OCaml) "Str'_Literal.asciis'_of'_literal"
+    and (Haskell) "map/ (let ord k | (k < 128) = Prelude.toInteger k in ord . (Prelude.fromEnum :: Prelude.Char -> Prelude.Int))"
+    and (Scala) "!(_.toList.map(c => { val k: Int = c.toInt; if (k < 128) BigInt(k) else sys.error(\"Non-ASCII character in literal\") }))"
+| class_instance String.literal :: equal \<rightharpoonup>
+    (Haskell) -
+| constant "HOL.equal :: String.literal \<Rightarrow> String.literal \<Rightarrow> bool" \<rightharpoonup>
+    (SML) "!((_ : string) = _)"
+    and (OCaml) "!((_ : string) = _)"
+    and (Haskell) infix 4 "=="
+    and (Scala) infixl 5 "=="
+| constant "(\<le>) :: String.literal \<Rightarrow> String.literal \<Rightarrow> bool" \<rightharpoonup>
+    (SML) "!((_ : string) <= _)"
+    and (OCaml) "!((_ : string) <= _)"
+    and (Haskell) infix 4 "<="
+    \<comment> \<open>Order operations for \<^typ>\<open>String.literal\<close> work in Haskell only
+          if no type class instance needs to be generated, because String = [Char] in Haskell
+          and \<^typ>\<open>char list\<close> need not have the same order as \<^typ>\<open>String.literal\<close>.\<close>
+    and (Scala) infixl 4 "<="
+    and (Eval) infixl 6 "<="
+| constant "(<) :: String.literal \<Rightarrow> String.literal \<Rightarrow> bool" \<rightharpoonup>
+    (SML) "!((_ : string) < _)"
+    and (OCaml) "!((_ : string) < _)"
+    and (Haskell) infix 4 "<"
+    and (Scala) infixl 4 "<"
+    and (Eval) infixl 6 "<"
+
+
+subsubsection \<open>Code generation utility\<close>
+
+setup \<open>Sign.map_naming (Name_Space.mandatory_path "Code")\<close>
+
+definition abort :: "String.literal \<Rightarrow> (unit \<Rightarrow> 'a) \<Rightarrow> 'a"
+  where [simp]: "abort _ f = f ()"
+
+declare [[code drop: Code.abort]]
+
+lemma abort_cong:
+  "msg = msg' \<Longrightarrow> Code.abort msg f = Code.abort msg' f"
+  by simp
+
+setup \<open>Sign.map_naming Name_Space.parent_path\<close>
+
+setup \<open>Code_Simp.map_ss (Simplifier.add_cong @{thm Code.abort_cong})\<close>
+
+code_printing
+  constant Code.abort \<rightharpoonup>
+    (SML) "!(raise/ Fail/ _)"
+    and (OCaml) "failwith"
+    and (Haskell) "!(error/ ::/ forall a./ String -> (() -> a) -> a)"
+    and (Scala) "!{/ sys.error((_));/ ((_)).apply(())/ }"
+
+
+subsubsection \<open>Finally\<close>
+
+lifting_update literal.lifting
+lifting_forget literal.lifting
+
+end
diff -urN ./Tools/Predicate_Compile/predicate_compile_compilations.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML
--- ./Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-30 11:49:58.264752400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-31 14:26:38.908985500 +0900
@@ -76,21 +76,21 @@
       (Type ("fun", [Type ("fun", [T, \<^typ>\<open>term list option\<close>]), \<^typ>\<open>term list option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
@@ -98,7 +98,7 @@
 fun mk_not t =
   let
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_not\<close>, T --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.cps_not\<close>, T --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -127,33 +127,33 @@
   \<^typ>\<open>natural => (bool * term list) option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], [])
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.pos_bound_cps_plus\<close>
 
 fun mk_if cond =
-  Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_if\<close>,
+  Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_if\<close>,
     HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
 
 fun mk_not t =
   let
-    val nT = \<^typ>\<open>(unit Quickcheck_Exhaustive.unknown =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued) => natural =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+    val nT = \<^typ>\<open>(unit Random_Prep.unknown =>
+      Code_Evaluation.term list Random_Prep.three_valued) => natural =>
+      Code_Evaluation.term list Random_Prep.three_valued\<close>
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_not\<close>, nT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_not\<close>, nT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -176,31 +176,31 @@
 struct
 
 fun mk_monadT T =
-  (Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T])
-    --> \<^typ>\<open>Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>)
-    --> \<^typ>\<open>natural => Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+  (Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T])
+    --> \<^typ>\<open>Code_Evaluation.term list Random_Prep.three_valued\<close>)
+    --> \<^typ>\<open>natural => Code_Evaluation.term list Random_Prep.three_valued\<close>
 
 fun dest_monadT
-    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T]),
-      \<^typ>\<open>term list Quickcheck_Exhaustive.three_valued\<close>]),
-      \<^typ>\<open>natural => term list Quickcheck_Exhaustive.three_valued\<close>])) = T
+    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T]),
+      \<^typ>\<open>term list Random_Prep.three_valued\<close>]),
+      \<^typ>\<open>natural => term list Random_Prep.three_valued\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.neg_bound_cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented"
@@ -210,7 +210,7 @@
     val T = mk_monadT HOLogic.unitT
     val pT = \<^typ>\<open>(unit => (bool * Code_Evaluation.term list) option)\<close>
       --> \<^typ>\<open>natural => (bool * Code_Evaluation.term list) option\<close>
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_not\<close>, pT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_not\<close>, pT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
diff -urN ./Tools/Predicate_Compile/predicate_compile_compilations.ML.rej /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML.rej
--- ./Tools/Predicate_Compile/predicate_compile_compilations.ML.rej	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML.rej	2023-05-30 16:53:56.944734800 +0900
@@ -0,0 +1,133 @@
+--- /Applications/Isabelle2022.app/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-30 15:37:49.000000000 +0900
++++ ./Tools/Predicate_Compile/predicate_compile_compilations.ML	2022-10-25 03:37:32.000000000 +0900
+@@ -76,21 +76,21 @@
+       (Type ("fun", [Type ("fun", [T, \<^typ>\<open>term list option\<close>]), \<^typ>\<open>term list option\<close>])) = T
+   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
+ 
+-fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.cps_empty\<close>, mk_monadT T)
++fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_empty\<close>, mk_monadT T)
+ 
+ fun mk_single t =
+   let val T = fastype_of t
+-  in Const(\<^const_name>\<open>Random_Prep.cps_single\<close>, T --> mk_monadT T) $ t end
++  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.cps_single\<close>, T --> mk_monadT T) $ t end
+ 
+ fun mk_bind (x, f) =
+   let val T as Type ("fun", [_, U]) = fastype_of f
+   in
+-    Const (\<^const_name>\<open>Random_Prep.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
++    Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+   end
+ 
+-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.cps_plus\<close>
++val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.cps_plus\<close>
+ 
+-fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.cps_if\<close>,
++fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_if\<close>,
+   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
+ 
+ fun mk_iterate_upto _ _ = error "not implemented yet"
+@@ -98,7 +98,7 @@
+ fun mk_not t =
+   let
+     val T = mk_monadT HOLogic.unitT
+-  in Const (\<^const_name>\<open>Random_Prep.cps_not\<close>, T --> T) $ t end
++  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_not\<close>, T --> T) $ t end
+ 
+ fun mk_Enum _ = error "not implemented"
+ 
+@@ -127,33 +127,33 @@
+   \<^typ>\<open>natural => (bool * term list) option\<close>])) = T
+   | dest_monadT T = raise TYPE ("dest_monadT", [T], [])
+ 
+-fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_empty\<close>, mk_monadT T)
++fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_empty\<close>, mk_monadT T)
+ 
+ fun mk_single t =
+   let val T = fastype_of t
+-  in Const(\<^const_name>\<open>Random_Prep.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
++  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+ 
+ fun mk_bind (x, f) =
+   let val T as Type ("fun", [_, U]) = fastype_of f
+   in
+-    Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
++    Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+   end;
+ 
+-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.pos_bound_cps_plus\<close>
++val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_plus\<close>
+ 
+ fun mk_if cond =
+-  Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_if\<close>,
++  Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_if\<close>,
+     HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
+ 
+ fun mk_iterate_upto _ _ = error "not implemented yet"
+ 
+ fun mk_not t =
+   let
+-    val nT = \<^typ>\<open>(unit Random_Prep.unknown =>
+-      Code_Evaluation.term list Random_Prep.three_valued) => natural =>
+-      Code_Evaluation.term list Random_Prep.three_valued\<close>
++    val nT = \<^typ>\<open>(unit Quickcheck_Exhaustive.unknown =>
++      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued) => natural =>
++      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+     val T = mk_monadT HOLogic.unitT
+-  in Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_not\<close>, nT --> T) $ t end
++  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_not\<close>, nT --> T) $ t end
+ 
+ fun mk_Enum _ = error "not implemented"
+ 
+@@ -176,31 +176,31 @@
+ struct
+ 
+ fun mk_monadT T =
+-  (Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T])
+-    --> \<^typ>\<open>Code_Evaluation.term list Random_Prep.three_valued\<close>)
+-    --> \<^typ>\<open>natural => Code_Evaluation.term list Random_Prep.three_valued\<close>
++  (Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T])
++    --> \<^typ>\<open>Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>)
++    --> \<^typ>\<open>natural => Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+ 
+ fun dest_monadT
+-    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T]),
+-      \<^typ>\<open>term list Random_Prep.three_valued\<close>]),
+-      \<^typ>\<open>natural => term list Random_Prep.three_valued\<close>])) = T
++    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T]),
++      \<^typ>\<open>term list Quickcheck_Exhaustive.three_valued\<close>]),
++      \<^typ>\<open>natural => term list Quickcheck_Exhaustive.three_valued\<close>])) = T
+   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
+ 
+-fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_empty\<close>, mk_monadT T)
++fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_empty\<close>, mk_monadT T)
+ 
+ fun mk_single t =
+   let val T = fastype_of t
+-  in Const(\<^const_name>\<open>Random_Prep.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
++  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+ 
+ fun mk_bind (x, f) =
+   let val T as Type ("fun", [_, U]) = fastype_of f
+   in
+-    Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
++    Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+   end;
+ 
+-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.neg_bound_cps_plus\<close>
++val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_plus\<close>
+ 
+-fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_if\<close>,
++fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_if\<close>,
+   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
+ 
+ fun mk_iterate_upto _ _ = error "not implemented"
+@@ -210,7 +210,7 @@
+     val T = mk_monadT HOLogic.unitT
+     val pT = \<^typ>\<open>(unit => (bool * Code_Evaluation.term list) option)\<close>
+       --> \<^typ>\<open>natural => (bool * Code_Evaluation.term list) option\<close>
+-  in Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_not\<close>, pT --> T) $ t end
++  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_not\<close>, pT --> T) $ t end
+ 
+ fun mk_Enum _ = error "not implemented"
+ 
diff -urN ./Tools/Predicate_Compile/predicate_compile_core.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML
--- ./Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-30 11:49:58.043626700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-31 14:26:38.908985500 +0900
@@ -435,7 +435,7 @@
   compfuns = Random_Sequence_CompFuns.compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -472,7 +472,7 @@
   compfuns = New_Pos_Random_Sequence_CompFuns.depth_limited_compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -536,7 +536,7 @@
   compfuns = Pos_Bounded_CPS_Comp_Funs.compfuns,
   mk_random =
     (fn T => fn _ =>
-       Const (\<^const_name>\<open>Quickcheck_Exhaustive.exhaustive\<close>,
+       Const (\<^const_name>\<open>Random_Prep.exhaustive\<close>,
        (T --> \<^typ>\<open>(bool * term list) option\<close>) -->
          \<^typ>\<open>natural => (bool * term list) option\<close>)),
   modify_funT = I,
diff -urN ./Tools/Predicate_Compile/predicate_compile_core.ML.rej /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML.rej
--- ./Tools/Predicate_Compile/predicate_compile_core.ML.rej	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML.rej	2023-05-30 16:53:58.497585300 +0900
@@ -0,0 +1,29 @@
+--- /Applications/Isabelle2022.app/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-30 15:37:49.000000000 +0900
++++ ./Tools/Predicate_Compile/predicate_compile_core.ML	2022-10-25 03:37:32.000000000 +0900
+@@ -435,7 +435,7 @@
+   compfuns = Random_Sequence_CompFuns.compfuns,
+   mk_random = (fn T => fn _ =>
+   let
+-    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
++    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
+         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
+   in
+@@ -472,7 +472,7 @@
+   compfuns = New_Pos_Random_Sequence_CompFuns.depth_limited_compfuns,
+   mk_random = (fn T => fn _ =>
+   let
+-    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
++    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
+         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
+   in
+@@ -536,7 +536,7 @@
+   compfuns = Pos_Bounded_CPS_Comp_Funs.compfuns,
+   mk_random =
+     (fn T => fn _ =>
+-       Const (\<^const_name>\<open>Random_Prep.exhaustive\<close>,
++       Const (\<^const_name>\<open>Quickcheck_Exhaustive.exhaustive\<close>,
+        (T --> \<^typ>\<open>(bool * term list) option\<close>) -->
+          \<^typ>\<open>natural => (bool * term list) option\<close>)),
+   modify_funT = I,
diff -urN ./Tools/Quickcheck/random_generators.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML
--- ./Tools/Quickcheck/random_generators.ML	2023-05-30 11:50:41.406853100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML	2023-05-31 14:26:38.908985500 +0900
@@ -204,7 +204,7 @@
         val T = Type (tyco, Ts);
         fun mk_random_fun_lift [] t = t
           | mk_random_fun_lift (fT :: fTs) t =
-              mk_const \<^const_name>\<open>random_fun_lift\<close> [fTs ---> T, fT] $
+              mk_const \<^const_name>\<open>Random_Prep.random_fun_lift\<close> [fTs ---> T, fT] $
                 mk_random_fun_lift fTs t;
         val t = mk_random_fun_lift fTs (nth random_auxs k $ size_pred $ size');
         val size = Option.map snd (Old_Datatype_Aux.find_shortest_path descr k)
diff -urN ./Tools/Quickcheck/random_generators.ML.rej /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML.rej
--- ./Tools/Quickcheck/random_generators.ML.rej	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML.rej	2023-05-30 16:53:59.833577400 +0900
@@ -0,0 +1,11 @@
+--- /Applications/Isabelle2022.app/src/HOL/Tools/Quickcheck/random_generators.ML	2023-05-30 15:37:49.000000000 +0900
++++ ./Tools/Quickcheck/random_generators.ML	2022-10-25 03:37:32.000000000 +0900
+@@ -204,7 +204,7 @@
+         val T = Type (tyco, Ts);
+         fun mk_random_fun_lift [] t = t
+           | mk_random_fun_lift (fT :: fTs) t =
+-              mk_const \<^const_name>\<open>Random_Prep.random_fun_lift\<close> [fTs ---> T, fT] $
++              mk_const \<^const_name>\<open>random_fun_lift\<close> [fTs ---> T, fT] $
+                 mk_random_fun_lift fTs t;
+         val t = mk_random_fun_lift fTs (nth random_auxs k $ size_pred $ size');
+         val size = Option.map snd (Old_Datatype_Aux.find_shortest_path descr k)
diff -urN ./Transcendental.thy /cygdrive/c/Isabelle2022/src/HOL/Transcendental.thy
--- ./Transcendental.thy	2023-05-30 11:50:41.644512700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Transcendental.thy	2023-05-31 14:26:38.908985500 +0900
@@ -3422,12 +3422,14 @@
     have "(-1) ^ ((n - Suc 0) div 2) * (-1) ^ ((p - Suc n) div 2) = - ((-1 :: real) ^ (p div 2))"
       if np: "odd n" "even p"
     proof -
-      have "p > 0"
-        using \<open>n \<le> p\<close> neq0_conv that(1) by blast
+      have n1: "Suc 0 \<le>  n" using odd_pos[OF that(1)] by simp
+      have opn: "odd (p - n)" using np \<open>n \<le> p\<close> by simp
+      have snp: "Suc n \<le> p" using odd_pos[OF opn] by simp
+      then have p2: "2 \<le> p" using \<open>n \<le> p\<close> that(2) by (auto elim: oddE)
       then have \<section>: "(- 1::real) ^ (p div 2 - Suc 0) = - ((- 1) ^ (p div 2))"
-        using \<open>even p\<close> by (auto simp add: dvd_def power_eq_if)
-      from \<open>n \<le> p\<close> np have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" "Suc (Suc 0) \<le> p"
-        by arith+
+        by (simp add: power_eq_if)
+      from n1 p2 snp have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" 
+        by simp
       have "(p - Suc (Suc 0)) div 2 = p div 2 - Suc 0"
         by simp
       with \<open>n \<le> p\<close> np  \<section> * show ?thesis
